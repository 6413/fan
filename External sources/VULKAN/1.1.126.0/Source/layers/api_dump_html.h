
/* Copyright (c) 2015-2017, 2019 Valve Corporation
 * Copyright (c) 2015-2017, 2019 LunarG, Inc.
 * Copyright (c) 2015-2017, 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Author: Lenny Komow <lenny@lunarg.com>
 * Author: Joey Bzdek <joey@lunarg.com>
 * Author: Shannon McPherson <shannon@lunarg.com>
 * Author: Charles Giessen <charles@lunarg.com>
 */

/*
 * This file is generated from the Khronos Vulkan XML API Registry.
 */

#pragma once

#include "api_dump.h"

std::ostream& dump_html_VkMemoryRequirements(const VkMemoryRequirements& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceQueueGlobalPriorityCreateInfoEXT(const VkDeviceQueueGlobalPriorityCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPresentTimeGOOGLE(const VkPresentTimeGOOGLE& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRenderPassFragmentDensityMapCreateInfoEXT(const VkRenderPassFragmentDensityMapCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceCoverageReductionModeFeaturesNV(const VkPhysicalDeviceCoverageReductionModeFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPerformanceValueINTEL(const VkPerformanceValueINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageStencilUsageCreateInfoEXT(const VkImageStencilUsageCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPresentInfoKHR(const VkPresentInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderClockFeaturesKHR(const VkPhysicalDeviceShaderClockFeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkValidationFeaturesEXT(const VkValidationFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPresentTimesInfoGOOGLE(const VkPresentTimesInfoGOOGLE& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkFilterCubicImageViewImageFormatPropertiesEXT(const VkFilterCubicImageViewImageFormatPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkInitializePerformanceApiInfoINTEL(const VkInitializePerformanceApiInfoINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkLayerProperties(const VkLayerProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkFramebufferMixedSamplesCombinationNV(const VkFramebufferMixedSamplesCombinationNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageFormatProperties(const VkImageFormatProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSurfaceInfo2KHR(const VkPhysicalDeviceSurfaceInfo2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineCompilerControlCreateInfoAMD(const VkPipelineCompilerControlCreateInfoAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExtent3D(const VkExtent3D& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR(const VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(const VkPhysicalDeviceScalarBlockLayoutFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageSwapchainCreateInfoKHR(const VkImageSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineCoverageReductionStateCreateInfoNV(const VkPipelineCoverageReductionStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCooperativeMatrixPropertiesNV(const VkCooperativeMatrixPropertiesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryAllocateInfo(const VkMemoryAllocateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceCoherentMemoryFeaturesAMD(const VkPhysicalDeviceCoherentMemoryFeaturesAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSparseImageMemoryRequirements(const VkSparseImageMemoryRequirements& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkQueryPoolCreateInfoINTEL(const VkQueryPoolCreateInfoINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSparseImageFormatProperties(const VkSparseImageFormatProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAcquireNextImageInfoKHR(const VkAcquireNextImageInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCalibratedTimestampInfoEXT(const VkCalibratedTimestampInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceMemoryPriorityFeaturesEXT(const VkPhysicalDeviceMemoryPriorityFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineRasterizationStateStreamCreateInfoEXT(const VkPipelineRasterizationStateStreamCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPerformanceMarkerInfoINTEL(const VkPerformanceMarkerInfoINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSurfaceCapabilities2KHR(const VkSurfaceCapabilities2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineViewportSwizzleStateCreateInfoNV(const VkPipelineViewportSwizzleStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDevice8BitStorageFeaturesKHR(const VkPhysicalDevice8BitStorageFeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSurfaceFormat2KHR(const VkSurfaceFormat2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBindImageMemorySwapchainInfoKHR(const VkBindImageMemorySwapchainInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderCorePropertiesAMD(const VkPhysicalDeviceShaderCorePropertiesAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceMemoryBudgetPropertiesEXT(const VkPhysicalDeviceMemoryBudgetPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPerformanceStreamMarkerInfoINTEL(const VkPerformanceStreamMarkerInfoINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkViewportSwizzleNV(const VkViewportSwizzleNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryHostPointerPropertiesEXT(const VkMemoryHostPointerPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSubmitInfo(const VkSubmitInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPerformanceOverrideInfoINTEL(const VkPerformanceOverrideInfoINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceProperties(const VkPhysicalDeviceProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryPriorityAllocateInfoEXT(const VkMemoryPriorityAllocateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPerformanceConfigurationAcquireInfoINTEL(const VkPerformanceConfigurationAcquireInfoINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDebugMarkerObjectNameInfoEXT(const VkDebugMarkerObjectNameInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImportMemoryHostPointerInfoEXT(const VkImportMemoryHostPointerInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSurfaceProtectedCapabilitiesKHR(const VkSurfaceProtectedCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(const VkPhysicalDeviceExternalMemoryHostPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayProperties2KHR(const VkDisplayProperties2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderCoreProperties2AMD(const VkPhysicalDeviceShaderCoreProperties2AMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceCooperativeMatrixPropertiesNV(const VkPhysicalDeviceCooperativeMatrixPropertiesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMappedMemoryRange(const VkMappedMemoryRange& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(const VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceLimits(const VkPhysicalDeviceLimits& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayPlaneProperties2KHR(const VkDisplayPlaneProperties2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkQueueFamilyProperties(const VkQueueFamilyProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayPropertiesKHR(const VkDisplayPropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSparseProperties(const VkPhysicalDeviceSparseProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGroupPresentInfoKHR(const VkDeviceGroupPresentInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGroupPresentCapabilitiesKHR(const VkDeviceGroupPresentCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDebugMarkerObjectTagInfoEXT(const VkDebugMarkerObjectTagInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplaySurfaceCreateInfoKHR(const VkDisplaySurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkSurfaceFullScreenExclusiveInfoEXT(const VkSurfaceFullScreenExclusiveInfoEXT& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkSparseMemoryBind(const VkSparseMemoryBind& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkSurfaceCapabilitiesFullScreenExclusiveEXT(const VkSurfaceCapabilitiesFullScreenExclusiveEXT& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkBufferDeviceAddressInfoEXT(const VkBufferDeviceAddressInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceMemoryProperties(const VkPhysicalDeviceMemoryProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDebugMarkerMarkerInfoEXT(const VkDebugMarkerMarkerInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineRasterizationStateRasterizationOrderAMD(const VkPipelineRasterizationStateRasterizationOrderAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGroupSwapchainCreateInfoKHR(const VkDeviceGroupSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSparseBufferMemoryBindInfo(const VkSparseBufferMemoryBindInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBindSparseInfo(const VkBindSparseInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceCooperativeMatrixFeaturesNV(const VkPhysicalDeviceCooperativeMatrixFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayPlanePropertiesKHR(const VkDisplayPlanePropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(const VkPhysicalDeviceShaderAtomicInt64FeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayModeCreateInfoKHR(const VkDisplayModeCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayModeProperties2KHR(const VkDisplayModeProperties2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSparseImageOpaqueMemoryBindInfo(const VkSparseImageOpaqueMemoryBindInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryType(const VkMemoryType& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceMemoryOverallocationCreateInfoAMD(const VkDeviceMemoryOverallocationCreateInfoAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBufferDeviceAddressCreateInfoEXT(const VkBufferDeviceAddressCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBufferMemoryRequirementsInfo2(const VkBufferMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSurfaceCapabilities2EXT(const VkSurfaceCapabilities2EXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDevicePushDescriptorPropertiesKHR(const VkPhysicalDevicePushDescriptorPropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorBufferInfo(const VkDescriptorBufferInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageMemoryRequirementsInfo2(const VkImageMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorImageInfo(const VkDescriptorImageInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSampleLocationsInfoEXT(const VkSampleLocationsInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineColorBlendAttachmentState(const VkPipelineColorBlendAttachmentState& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkWriteDescriptorSet(const VkWriteDescriptorSet& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkWin32SurfaceCreateInfoKHR(const VkWin32SurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkAttachmentSampleLocationsEXT(const VkAttachmentSampleLocationsEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageSparseMemoryRequirementsInfo2(const VkImageSparseMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDevicePCIBusInfoPropertiesEXT(const VkPhysicalDevicePCIBusInfoPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCopyDescriptorSet(const VkCopyDescriptorSet& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSubpassSampleLocationsEXT(const VkSubpassSampleLocationsEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryRequirements2(const VkMemoryRequirements2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderImageFootprintFeaturesNV(const VkPhysicalDeviceShaderImageFootprintFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSparseImageMemoryRequirements2(const VkSparseImageMemoryRequirements2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceDiscardRectanglePropertiesEXT(const VkPhysicalDeviceDiscardRectanglePropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayNativeHdrSurfaceCapabilitiesAMD(const VkDisplayNativeHdrSurfaceCapabilitiesAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRenderPassSampleLocationsBeginInfoEXT(const VkRenderPassSampleLocationsBeginInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineDiscardRectangleStateCreateInfoEXT(const VkPipelineDiscardRectangleStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSampleLocationsPropertiesEXT(const VkPhysicalDeviceSampleLocationsPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceExclusiveScissorFeaturesNV(const VkPhysicalDeviceExclusiveScissorFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkConditionalRenderingBeginInfoEXT(const VkConditionalRenderingBeginInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayPowerInfoEXT(const VkDisplayPowerInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCommandBufferInheritanceConditionalRenderingInfoEXT(const VkCommandBufferInheritanceConditionalRenderingInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceEventInfoEXT(const VkDeviceEventInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineSampleLocationsStateCreateInfoEXT(const VkPipelineSampleLocationsStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSwapchainDisplayNativeHdrCreateInfoAMD(const VkSwapchainDisplayNativeHdrCreateInfoAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineViewportExclusiveScissorStateCreateInfoNV(const VkPipelineViewportExclusiveScissorStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceConditionalRenderingFeaturesEXT(const VkPhysicalDeviceConditionalRenderingFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayEventInfoEXT(const VkDisplayEventInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMultisamplePropertiesEXT(const VkMultisamplePropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceFeatures2(const VkPhysicalDeviceFeatures2& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_FUCHSIA)
std::ostream& dump_html_VkImagePipeSurfaceCreateInfoFUCHSIA(const VkImagePipeSurfaceCreateInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_FUCHSIA
std::ostream& dump_html_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(const VkPhysicalDeviceConservativeRasterizationPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageViewHandleInfoNVX(const VkImageViewHandleInfoNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkFramebufferCreateInfo(const VkFramebufferCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSwapchainCounterCreateInfoEXT(const VkSwapchainCounterCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineRasterizationConservativeStateCreateInfoEXT(const VkPipelineRasterizationConservativeStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(const VkPipelineRepresentativeFragmentTestStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkQueueFamilyCheckpointPropertiesNV(const VkQueueFamilyCheckpointPropertiesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceProperties2(const VkPhysicalDeviceProperties2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(const VkPhysicalDeviceShaderFloat16Int8FeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkFormatProperties2(const VkFormatProperties2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCheckpointDataNV(const VkCheckpointDataNV& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_METAL_EXT)
std::ostream& dump_html_VkMetalSurfaceCreateInfoEXT(const VkMetalSurfaceCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_METAL_EXT
std::ostream& dump_html_VkPresentRegionKHR(const VkPresentRegionKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageFormatProperties2(const VkImageFormatProperties2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceDepthClipEnableFeaturesEXT(const VkPhysicalDeviceDepthClipEnableFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageFormatListCreateInfoKHR(const VkImageFormatListCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRectLayerKHR(const VkRectLayerKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPresentRegionsKHR(const VkPresentRegionsKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(const VkPhysicalDeviceFragmentDensityMapFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRefreshCycleDurationGOOGLE(const VkRefreshCycleDurationGOOGLE& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceImageFormatInfo2(const VkPhysicalDeviceImageFormatInfo2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceImageViewImageFormatInfoEXT(const VkPhysicalDeviceImageViewImageFormatInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRenderPassCreateInfo(const VkRenderPassCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(const VkPhysicalDeviceFragmentDensityMapPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAttachmentDescription(const VkAttachmentDescription& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayPresentInfoKHR(const VkDisplayPresentInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPastPresentationTimingGOOGLE(const VkPastPresentationTimingGOOGLE& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkQueueFamilyProperties2(const VkQueueFamilyProperties2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageResolve(const VkImageResolve& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineExecutableInternalRepresentationKHR(const VkPipelineExecutableInternalRepresentationKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkHdrMetadataEXT(const VkHdrMetadataEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCmdReserveSpaceForCommandsInfoNVX(const VkCmdReserveSpaceForCommandsInfoNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayModeParametersKHR(const VkDisplayModeParametersKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayModePropertiesKHR(const VkDisplayModePropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceMemoryProperties2(const VkPhysicalDeviceMemoryProperties2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayPlaneCapabilities2KHR(const VkDisplayPlaneCapabilities2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkTextureLODGatherFormatPropertiesAMD(const VkTextureLODGatherFormatPropertiesAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSurfaceCapabilitiesKHR(const VkSurfaceCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineRasterizationDepthClipStateCreateInfoEXT(const VkPipelineRasterizationDepthClipStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSparseImageFormatProperties2(const VkSparseImageFormatProperties2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkXYColorEXT(const VkXYColorEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayPlaneInfo2KHR(const VkDisplayPlaneInfo2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkObjectTableCreateInfoNVX(const VkObjectTableCreateInfoNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkShaderStatisticsInfoAMD(const VkShaderStatisticsInfoAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSparseImageFormatInfo2(const VkPhysicalDeviceSparseImageFormatInfo2& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkShaderResourceUsageAMD(const VkShaderResourceUsageAMD& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkObjectTableEntryNVX(const VkObjectTableEntryNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDisplayPlaneCapabilitiesKHR(const VkDisplayPlaneCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkHeadlessSurfaceCreateInfoEXT(const VkHeadlessSurfaceCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBufferMemoryBarrier(const VkBufferMemoryBarrier& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryBarrier(const VkMemoryBarrier& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceLineRasterizationFeaturesEXT(const VkPhysicalDeviceLineRasterizationFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkComputePipelineCreateInfo(const VkComputePipelineCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageMemoryBarrier(const VkImageMemoryBarrier& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSurfaceFormatKHR(const VkSurfaceFormatKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceLineRasterizationPropertiesEXT(const VkPhysicalDeviceLineRasterizationPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceImagelessFramebufferFeaturesKHR(const VkPhysicalDeviceImagelessFramebufferFeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkObjectTablePipelineEntryNVX(const VkObjectTablePipelineEntryNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkObjectTableVertexBufferEntryNVX(const VkObjectTableVertexBufferEntryNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCommandPoolCreateInfo(const VkCommandPoolCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkObjectTableDescriptorSetEntryNVX(const VkObjectTableDescriptorSetEntryNVX& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_XLIB_KHR)
std::ostream& dump_html_VkXlibSurfaceCreateInfoKHR(const VkXlibSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_XLIB_KHR
std::ostream& dump_html_VkPipelineRasterizationLineStateCreateInfoEXT(const VkPipelineRasterizationLineStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPushConstantRange(const VkPushConstantRange& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkFramebufferAttachmentsCreateInfoKHR(const VkFramebufferAttachmentsCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkObjectTableIndexBufferEntryNVX(const VkObjectTableIndexBufferEntryNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineLayoutCreateInfo(const VkPipelineLayoutCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkFramebufferAttachmentImageInfoKHR(const VkFramebufferAttachmentImageInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceHostQueryResetFeaturesEXT(const VkPhysicalDeviceHostQueryResetFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_IOS_MVK)
std::ostream& dump_html_VkIOSSurfaceCreateInfoMVK(const VkIOSSurfaceCreateInfoMVK& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_IOS_MVK
std::ostream& dump_html_VkObjectTablePushConstantEntryNVX(const VkObjectTablePushConstantEntryNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceTransformFeedbackPropertiesEXT(const VkPhysicalDeviceTransformFeedbackPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDevicePointClippingProperties(const VkPhysicalDevicePointClippingProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRenderPassAttachmentBeginInfoKHR(const VkRenderPassAttachmentBeginInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRenderPassInputAttachmentAspectCreateInfo(const VkRenderPassInputAttachmentAspectCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceTransformFeedbackFeaturesEXT(const VkPhysicalDeviceTransformFeedbackFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_GGP)
std::ostream& dump_html_VkStreamDescriptorSurfaceCreateInfoGGP(const VkStreamDescriptorSurfaceCreateInfoGGP& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_GGP
std::ostream& dump_html_VkCommandBufferAllocateInfo(const VkCommandBufferAllocateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkFormatProperties(const VkFormatProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBindBufferMemoryInfo(const VkBindBufferMemoryInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceRayTracingPropertiesNV(const VkPhysicalDeviceRayTracingPropertiesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkVertexInputBindingDivisorDescriptionEXT(const VkVertexInputBindingDivisorDescriptionEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSparseImageMemoryBindInfo(const VkSparseImageMemoryBindInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAccelerationStructureMemoryRequirementsInfoNV(const VkAccelerationStructureMemoryRequirementsInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceCornerSampledImageFeaturesNV(const VkPhysicalDeviceCornerSampledImageFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkOffset3D(const VkOffset3D& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_GGP)
std::ostream& dump_html_VkPresentFrameTokenGGP(const VkPresentFrameTokenGGP& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_GGP
std::ostream& dump_html_VkInstanceCreateInfo(const VkInstanceCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageSubresource(const VkImageSubresource& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBufferCopy(const VkBufferCopy& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSparseImageMemoryBind(const VkSparseImageMemoryBind& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBindImageMemoryInfo(const VkBindImageMemoryInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineVertexInputDivisorStateCreateInfoEXT(const VkPipelineVertexInputDivisorStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDevice16BitStorageFeatures(const VkPhysicalDevice16BitStorageFeatures& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageCopy(const VkImageCopy& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalImageFormatPropertiesNV(const VkExternalImageFormatPropertiesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageSubresourceLayers(const VkImageSubresourceLayers& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineCreationFeedbackCreateInfoEXT(const VkPipelineCreationFeedbackCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalMemoryImageCreateInfoNV(const VkExternalMemoryImageCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineCreationFeedbackEXT(const VkPipelineCreationFeedbackEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGeneratedCommandsFeaturesNVX(const VkDeviceGeneratedCommandsFeaturesNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGeneratedCommandsLimitsNVX(const VkDeviceGeneratedCommandsLimitsNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExportMemoryAllocateInfoNV(const VkExportMemoryAllocateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryDedicatedRequirements(const VkMemoryDedicatedRequirements& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceDriverPropertiesKHR(const VkPhysicalDeviceDriverPropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkIndirectCommandsTokenNVX(const VkIndirectCommandsTokenNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageBlit(const VkImageBlit& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkImportMemoryWin32HandleInfoNV(const VkImportMemoryWin32HandleInfoNV& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkFenceCreateInfo(const VkFenceCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryDedicatedAllocateInfo(const VkMemoryDedicatedAllocateInfo& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkExportMemoryWin32HandleInfoNV(const VkExportMemoryWin32HandleInfoNV& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkConformanceVersionKHR(const VkConformanceVersionKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkIndirectCommandsLayoutCreateInfoNVX(const VkIndirectCommandsLayoutCreateInfoNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkIndirectCommandsLayoutTokenNVX(const VkIndirectCommandsLayoutTokenNVX& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkWin32KeyedMutexAcquireReleaseInfoNV(const VkWin32KeyedMutexAcquireReleaseInfoNV& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkDeviceGroupRenderPassBeginInfo(const VkDeviceGroupRenderPassBeginInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryAllocateFlagsInfo(const VkMemoryAllocateFlagsInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBufferImageCopy(const VkBufferImageCopy& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCmdProcessCommandsInfoNVX(const VkCmdProcessCommandsInfoNVX& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceFloatControlsPropertiesKHR(const VkPhysicalDeviceFloatControlsPropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSubpassDescription2KHR(const VkSubpassDescription2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAttachmentDescription2KHR(const VkAttachmentDescription2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRenderPassCreateInfo2KHR(const VkRenderPassCreateInfo2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(const VkPhysicalDeviceIndexTypeUint8FeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkShaderModuleCreateInfo(const VkShaderModuleCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCoarseSampleOrderCustomNV(const VkCoarseSampleOrderCustomNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDedicatedAllocationImageCreateInfoNV(const VkDedicatedAllocationImageCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkImportSemaphoreWin32HandleInfoKHR(const VkImportSemaphoreWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkBufferViewCreateInfo(const VkBufferViewCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDedicatedAllocationBufferCreateInfoNV(const VkDedicatedAllocationBufferCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAttachmentReference2KHR(const VkAttachmentReference2KHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkExportSemaphoreWin32HandleInfoKHR(const VkExportSemaphoreWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkSubpassDependency2KHR(const VkSubpassDependency2KHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineDepthStencilStateCreateInfo(const VkPipelineDepthStencilStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDedicatedAllocationMemoryAllocateInfoNV(const VkDedicatedAllocationMemoryAllocateInfoNV& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkD3D12FenceSubmitInfoKHR(const VkD3D12FenceSubmitInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkStencilOpState(const VkStencilOpState& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineCacheCreateInfo(const VkPipelineCacheCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineInfoKHR(const VkPipelineInfoKHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkExportMemoryWin32HandleInfoKHR(const VkExportMemoryWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkRayTracingShaderGroupCreateInfoNV(const VkRayTracingShaderGroupCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRayTracingPipelineCreateInfoNV(const VkRayTracingPipelineCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineExecutablePropertiesKHR(const VkPipelineExecutablePropertiesKHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkSemaphoreGetWin32HandleInfoKHR(const VkSemaphoreGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkImageCreateInfo(const VkImageCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineColorBlendStateCreateInfo(const VkPipelineColorBlendStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImportSemaphoreFdInfoKHR(const VkImportSemaphoreFdInfoKHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkAndroidHardwareBufferUsageANDROID(const VkAndroidHardwareBufferUsageANDROID& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkGeometryTrianglesNV(const VkGeometryTrianglesNV& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkAndroidHardwareBufferFormatPropertiesANDROID(const VkAndroidHardwareBufferFormatPropertiesANDROID& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkGeometryAABBNV(const VkGeometryAABBNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineExecutableInfoKHR(const VkPipelineExecutableInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkGraphicsPipelineCreateInfo(const VkGraphicsPipelineCreateInfo& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkAndroidHardwareBufferPropertiesANDROID(const VkAndroidHardwareBufferPropertiesANDROID& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkPipelineExecutableStatisticKHR(const VkPipelineExecutableStatisticKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSemaphoreGetFdInfoKHR(const VkSemaphoreGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSubpassBeginInfoKHR(const VkSubpassBeginInfoKHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkImportAndroidHardwareBufferInfoANDROID(const VkImportAndroidHardwareBufferInfoANDROID& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkPipelineShaderStageCreateInfo(const VkPipelineShaderStageCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGroupCommandBufferBeginInfo(const VkDeviceGroupCommandBufferBeginInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExportFenceCreateInfo(const VkExportFenceCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(const VkPhysicalDeviceImageDrmFormatModifierInfoEXT& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_MACOS_MVK)
std::ostream& dump_html_VkMacOSSurfaceCreateInfoMVK(const VkMacOSSurfaceCreateInfoMVK& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_MACOS_MVK
std::ostream& dump_html_VkImageViewUsageCreateInfo(const VkImageViewUsageCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkInputAttachmentAspectReference(const VkInputAttachmentAspectReference& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSamplerCreateInfo(const VkSamplerCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGroupSubmitInfo(const VkDeviceGroupSubmitInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSubpassEndInfoKHR(const VkSubpassEndInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkMemoryWin32HandlePropertiesKHR(const VkMemoryWin32HandlePropertiesKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkDebugUtilsObjectNameInfoEXT(const VkDebugUtilsObjectNameInfoEXT& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkMemoryGetAndroidHardwareBufferInfoANDROID(const VkMemoryGetAndroidHardwareBufferInfoANDROID& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkExternalFormatANDROID(const VkExternalFormatANDROID& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkSubresourceLayout(const VkSubresourceLayout& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExportSemaphoreCreateInfo(const VkExportSemaphoreCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSharedPresentSurfaceCapabilitiesKHR(const VkSharedPresentSurfaceCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDebugUtilsObjectTagInfoEXT(const VkDebugUtilsObjectTagInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineColorBlendAdvancedStateCreateInfoEXT(const VkPipelineColorBlendAdvancedStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineViewportStateCreateInfo(const VkPipelineViewportStateCreateInfo& object, const ApiDumpSettings& settings, int indents, bool is_dynamic_viewport, bool is_dynamic_scissor);
std::ostream& dump_html_VkPipelineTessellationDomainOriginStateCreateInfo(const VkPipelineTessellationDomainOriginStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDrmFormatModifierPropertiesEXT(const VkDrmFormatModifierPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDrmFormatModifierPropertiesListEXT(const VkDrmFormatModifierPropertiesListEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGroupBindSparseInfo(const VkDeviceGroupBindSparseInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRenderPassMultiviewCreateInfo(const VkRenderPassMultiviewCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDebugUtilsMessengerCallbackDataEXT(const VkDebugUtilsMessengerCallbackDataEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkRect2D(const VkRect2D& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkViewport(const VkViewport& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkImportFenceWin32HandleInfoKHR(const VkImportFenceWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkMemoryGetWin32HandleInfoKHR(const VkMemoryGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkExportFenceWin32HandleInfoKHR(const VkExportFenceWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkPhysicalDeviceMultiviewFeatures(const VkPhysicalDeviceMultiviewFeatures& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageDrmFormatModifierExplicitCreateInfoEXT(const VkImageDrmFormatModifierExplicitCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageViewCreateInfo(const VkImageViewCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineDynamicStateCreateInfo(const VkPipelineDynamicStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageSubresourceRange(const VkImageSubresourceRange& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceExternalSemaphoreInfo(const VkPhysicalDeviceExternalSemaphoreInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(const VkPhysicalDeviceInlineUniformBlockPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorPoolCreateInfo(const VkDescriptorPoolCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceProtectedMemoryFeatures(const VkPhysicalDeviceProtectedMemoryFeatures& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalSemaphoreProperties(const VkExternalSemaphoreProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSamplerReductionModeCreateInfoEXT(const VkSamplerReductionModeCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryFdPropertiesKHR(const VkMemoryFdPropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorPoolSize(const VkDescriptorPoolSize& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageDrmFormatModifierListCreateInfoEXT(const VkImageDrmFormatModifierListCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDebugUtilsLabelEXT(const VkDebugUtilsLabelEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorSetLayoutSupport(const VkDescriptorSetLayoutSupport& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineCoverageModulationStateCreateInfoNV(const VkPipelineCoverageModulationStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBindImageMemoryDeviceGroupInfo(const VkBindImageMemoryDeviceGroupInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkComponentMapping(const VkComponentMapping& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExtent2D(const VkExtent2D& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDebugUtilsMessengerCreateInfoEXT(const VkDebugUtilsMessengerCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkOffset2D(const VkOffset2D& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineCoverageToColorStateCreateInfoNV(const VkPipelineCoverageToColorStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImportMemoryFdInfoKHR(const VkImportMemoryFdInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageDrmFormatModifierPropertiesEXT(const VkImageDrmFormatModifierPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineRasterizationStateCreateInfo(const VkPipelineRasterizationStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBindBufferMemoryDeviceGroupInfo(const VkBindBufferMemoryDeviceGroupInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceMultiviewProperties(const VkPhysicalDeviceMultiviewProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(const VkPhysicalDeviceInlineUniformBlockFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceGroupProperties(const VkPhysicalDeviceGroupProperties& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkFenceGetWin32HandleInfoKHR(const VkFenceGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkPhysicalDeviceMaintenance3Properties(const VkPhysicalDeviceMaintenance3Properties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryGetFdInfoKHR(const VkMemoryGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceVariablePointersFeatures(const VkPhysicalDeviceVariablePointersFeatures& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImportFenceFdInfoKHR(const VkImportFenceFdInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(const VkDescriptorPoolInlineUniformBlockCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkValidationCacheCreateInfoEXT(const VkValidationCacheCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderDrawParametersFeatures(const VkPhysicalDeviceShaderDrawParametersFeatures& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorSetAllocateInfo(const VkDescriptorSetAllocateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceProtectedMemoryProperties(const VkPhysicalDeviceProtectedMemoryProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkShaderModuleValidationCacheCreateInfoEXT(const VkShaderModuleValidationCacheCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkFenceGetFdInfoKHR(const VkFenceGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorSetLayoutCreateInfo(const VkDescriptorSetLayoutCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceQueueInfo2(const VkDeviceQueueInfo2& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkWin32KeyedMutexAcquireReleaseInfoKHR(const VkWin32KeyedMutexAcquireReleaseInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkWriteDescriptorSetInlineUniformBlockEXT(const VkWriteDescriptorSetInlineUniformBlockEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorSetLayoutBinding(const VkDescriptorSetLayoutBinding& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceGroupDeviceCreateInfo(const VkDeviceGroupDeviceCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSampleLocationEXT(const VkSampleLocationEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineMultisampleStateCreateInfo(const VkPipelineMultisampleStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkProtectedSubmitInfo(const VkProtectedSubmitInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkApplicationInfo(const VkApplicationInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAllocationCallbacks(const VkAllocationCallbacks& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineVertexInputStateCreateInfo(const VkPipelineVertexInputStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorUpdateTemplateEntry(const VkDescriptorUpdateTemplateEntry& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalBufferProperties(const VkExternalBufferProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkMemoryHeap(const VkMemoryHeap& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSubpassDescription(const VkSubpassDescription& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorUpdateTemplateCreateInfo(const VkDescriptorUpdateTemplateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkGeometryDataNV(const VkGeometryDataNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceIDProperties(const VkPhysicalDeviceIDProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCommandBufferBeginInfo(const VkCommandBufferBeginInfo& object, const ApiDumpSettings& settings, int indents, VkCommandBuffer cmd_buffer);
std::ostream& dump_html_VkDeviceQueueCreateInfo(const VkDeviceQueueCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalMemoryImageCreateInfo(const VkExternalMemoryImageCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(const VkPhysicalDeviceDescriptorIndexingFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkGeometryNV(const VkGeometryNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDebugReportCallbackCreateInfoEXT(const VkDebugReportCallbackCreateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSpecializationInfo(const VkSpecializationInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCommandBufferInheritanceInfo(const VkCommandBufferInheritanceInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSpecializationMapEntry(const VkSpecializationMapEntry& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAttachmentReference(const VkAttachmentReference& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSubpassDependency(const VkSubpassDependency& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDeviceCreateInfo(const VkDeviceCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkShadingRatePaletteNV(const VkShadingRatePaletteNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalMemoryBufferCreateInfo(const VkExternalMemoryBufferCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAccelerationStructureInfoNV(const VkAccelerationStructureInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSwapchainCreateInfoKHR(const VkSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(const VkPhysicalDeviceDescriptorIndexingPropertiesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExportMemoryAllocateInfo(const VkExportMemoryAllocateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkVertexInputBindingDescription(const VkVertexInputBindingDescription& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineViewportShadingRateImageStateCreateInfoNV(const VkPipelineViewportShadingRateImageStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBufferCreateInfo(const VkBufferCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineInputAssemblyStateCreateInfo(const VkPipelineInputAssemblyStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShadingRateImagePropertiesNV(const VkPhysicalDeviceShadingRateImagePropertiesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkVertexInputAttributeDescription(const VkVertexInputAttributeDescription& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkAccelerationStructureCreateInfoNV(const VkAccelerationStructureCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShadingRateImageFeaturesNV(const VkPhysicalDeviceShadingRateImageFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExtensionProperties(const VkExtensionProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceExternalFenceInfo(const VkPhysicalDeviceExternalFenceInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalFenceProperties(const VkExternalFenceProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBindAccelerationStructureMemoryInfoNV(const VkBindAccelerationStructureMemoryInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceFeatures(const VkPhysicalDeviceFeatures& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalMemoryProperties(const VkExternalMemoryProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceExternalImageFormatInfo(const VkPhysicalDeviceExternalImageFormatInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkWriteDescriptorSetAccelerationStructureNV(const VkWriteDescriptorSetAccelerationStructureNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkCoarseSampleLocationNV(const VkCoarseSampleLocationNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineTessellationStateCreateInfo(const VkPipelineTessellationStateCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkExternalImageFormatProperties(const VkExternalImageFormatProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceExternalBufferInfo(const VkPhysicalDeviceExternalBufferInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceTimelineSemaphorePropertiesKHR(const VkPhysicalDeviceTimelineSemaphorePropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR(const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSamplerYcbcrConversionCreateInfo(const VkSamplerYcbcrConversionCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDrawIndirectCommand(const VkDrawIndirectCommand& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSubpassDescriptionDepthStencilResolveKHR(const VkSubpassDescriptionDepthStencilResolveKHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_VI_NN)
std::ostream& dump_html_VkViSurfaceCreateInfoNN(const VkViSurfaceCreateInfoNN& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_VI_NN
std::ostream& dump_html_VkTimelineSemaphoreSubmitInfoKHR(const VkTimelineSemaphoreSubmitInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBaseOutStructure(const VkBaseOutStructure& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_XCB_KHR)
std::ostream& dump_html_VkXcbSurfaceCreateInfoKHR(const VkXcbSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_XCB_KHR
std::ostream& dump_html_VkPhysicalDeviceDepthStencilResolvePropertiesKHR(const VkPhysicalDeviceDepthStencilResolvePropertiesKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSemaphoreCreateInfo(const VkSemaphoreCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSemaphoreTypeCreateInfoKHR(const VkSemaphoreTypeCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkViewportWScalingNV(const VkViewportWScalingNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSamplerYcbcrConversionInfo(const VkSamplerYcbcrConversionInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImageViewASTCDecodeModeEXT(const VkImageViewASTCDecodeModeEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceMeshShaderPropertiesNV(const VkPhysicalDeviceMeshShaderPropertiesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkEventCreateInfo(const VkEventCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSemaphoreWaitInfoKHR(const VkSemaphoreWaitInfoKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceASTCDecodeFeaturesEXT(const VkPhysicalDeviceASTCDecodeFeaturesEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineViewportWScalingStateCreateInfoNV(const VkPipelineViewportWScalingStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkBindImagePlaneMemoryInfo(const VkBindImagePlaneMemoryInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkClearDepthStencilValue(const VkClearDepthStencilValue& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSemaphoreSignalInfoKHR(const VkSemaphoreSignalInfoKHR& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
std::ostream& dump_html_VkWaylandSurfaceCreateInfoKHR(const VkWaylandSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WAYLAND_KHR
std::ostream& dump_html_VkRenderPassBeginInfo(const VkRenderPassBeginInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkImagePlaneMemoryRequirementsInfo(const VkImagePlaneMemoryRequirementsInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceMeshShaderFeaturesNV(const VkPhysicalDeviceMeshShaderFeaturesNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSamplerYcbcrConversionFeatures(const VkPhysicalDeviceSamplerYcbcrConversionFeatures& object, const ApiDumpSettings& settings, int indents);
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkImportMemoryWin32HandleInfoKHR(const VkImportMemoryWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkAndroidSurfaceCreateInfoKHR(const VkAndroidSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkBaseInStructure(const VkBaseInStructure& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkClearAttachment(const VkClearAttachment& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkSamplerYcbcrConversionImageFormatProperties(const VkSamplerYcbcrConversionImageFormatProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkClearRect(const VkClearRect& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDrawMeshTasksIndirectCommandNV(const VkDrawMeshTasksIndirectCommandNV& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkQueryPoolCreateInfo(const VkQueryPoolCreateInfo& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPhysicalDeviceSubgroupProperties(const VkPhysicalDeviceSubgroupProperties& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDispatchIndirectCommand(const VkDispatchIndirectCommand& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkValidationFlagsEXT(const VkValidationFlagsEXT& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkDrawIndexedIndirectCommand(const VkDrawIndexedIndirectCommand& object, const ApiDumpSettings& settings, int indents);


#if defined(VK_USE_PLATFORM_WIN32_KHR)
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkSurfaceFullScreenExclusiveWin32InfoEXT(const VkSurfaceFullScreenExclusiveWin32InfoEXT& object, const ApiDumpSettings& settings, int indents);
#endif // VK_USE_PLATFORM_WIN32_KHR
#endif // VK_USE_PLATFORM_WIN32_KHR


std::ostream& dump_html_VkPerformanceValueDataINTEL(const VkPerformanceValueDataINTEL& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkClearColorValue(const VkClearColorValue& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkPipelineExecutableStatisticValueKHR(const VkPipelineExecutableStatisticValueKHR& object, const ApiDumpSettings& settings, int indents);
std::ostream& dump_html_VkClearValue(const VkClearValue& object, const ApiDumpSettings& settings, int indents);

//======================== pNext Chain Implementation =======================//

std::ostream& dump_html_pNext_trampoline(const void* object, const ApiDumpSettings& settings, int indents)
{
    switch((int64_t) (static_cast<const VkBaseInStructure*>(object)->sType)) {

    case 1000174000:
        dump_html_pNext<const VkDeviceQueueGlobalPriorityCreateInfoEXT>(static_cast<const VkDeviceQueueGlobalPriorityCreateInfoEXT*>(object), settings, "VkDeviceQueueGlobalPriorityCreateInfoEXT", indents, dump_html_VkDeviceQueueGlobalPriorityCreateInfoEXT);
        break;
    case 1000218002:
        dump_html_pNext<const VkRenderPassFragmentDensityMapCreateInfoEXT>(static_cast<const VkRenderPassFragmentDensityMapCreateInfoEXT*>(object), settings, "VkRenderPassFragmentDensityMapCreateInfoEXT", indents, dump_html_VkRenderPassFragmentDensityMapCreateInfoEXT);
        break;
    case 1000250000:
        dump_html_pNext<const VkPhysicalDeviceCoverageReductionModeFeaturesNV>(static_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(object), settings, "VkPhysicalDeviceCoverageReductionModeFeaturesNV", indents, dump_html_VkPhysicalDeviceCoverageReductionModeFeaturesNV);
        break;
    case 1000246000:
        dump_html_pNext<const VkImageStencilUsageCreateInfoEXT>(static_cast<const VkImageStencilUsageCreateInfoEXT*>(object), settings, "VkImageStencilUsageCreateInfoEXT", indents, dump_html_VkImageStencilUsageCreateInfoEXT);
        break;
    case 1000181000:
        dump_html_pNext<const VkPhysicalDeviceShaderClockFeaturesKHR>(static_cast<const VkPhysicalDeviceShaderClockFeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderClockFeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderClockFeaturesKHR);
        break;
    case 1000247000:
        dump_html_pNext<const VkValidationFeaturesEXT>(static_cast<const VkValidationFeaturesEXT*>(object), settings, "VkValidationFeaturesEXT", indents, dump_html_VkValidationFeaturesEXT);
        break;
    case 1000092000:
        dump_html_pNext<const VkPresentTimesInfoGOOGLE>(static_cast<const VkPresentTimesInfoGOOGLE*>(object), settings, "VkPresentTimesInfoGOOGLE", indents, dump_html_VkPresentTimesInfoGOOGLE);
        break;
    case 1000170001:
        dump_html_pNext<const VkFilterCubicImageViewImageFormatPropertiesEXT>(static_cast<const VkFilterCubicImageViewImageFormatPropertiesEXT*>(object), settings, "VkFilterCubicImageViewImageFormatPropertiesEXT", indents, dump_html_VkFilterCubicImageViewImageFormatPropertiesEXT);
        break;
    case 1000183000:
        dump_html_pNext<const VkPipelineCompilerControlCreateInfoAMD>(static_cast<const VkPipelineCompilerControlCreateInfoAMD*>(object), settings, "VkPipelineCompilerControlCreateInfoAMD", indents, dump_html_VkPipelineCompilerControlCreateInfoAMD);
        break;
    case 1000175000:
        dump_html_pNext<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR>(static_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR);
        break;
    case 1000221000:
        dump_html_pNext<const VkPhysicalDeviceScalarBlockLayoutFeaturesEXT>(static_cast<const VkPhysicalDeviceScalarBlockLayoutFeaturesEXT*>(object), settings, "VkPhysicalDeviceScalarBlockLayoutFeaturesEXT", indents, dump_html_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT);
        break;
    case 1000060008:
        dump_html_pNext<const VkImageSwapchainCreateInfoKHR>(static_cast<const VkImageSwapchainCreateInfoKHR*>(object), settings, "VkImageSwapchainCreateInfoKHR", indents, dump_html_VkImageSwapchainCreateInfoKHR);
        break;
    case 1000250001:
        dump_html_pNext<const VkPipelineCoverageReductionStateCreateInfoNV>(static_cast<const VkPipelineCoverageReductionStateCreateInfoNV*>(object), settings, "VkPipelineCoverageReductionStateCreateInfoNV", indents, dump_html_VkPipelineCoverageReductionStateCreateInfoNV);
        break;
    case 1000225000:
        dump_html_pNext<const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT>(static_cast<const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT*>(object), settings, "VkPhysicalDeviceSubgroupSizeControlPropertiesEXT", indents, dump_html_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT);
        break;
    case 1000229000:
        dump_html_pNext<const VkPhysicalDeviceCoherentMemoryFeaturesAMD>(static_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(object), settings, "VkPhysicalDeviceCoherentMemoryFeaturesAMD", indents, dump_html_VkPhysicalDeviceCoherentMemoryFeaturesAMD);
        break;
    case 1000097000:
        dump_html_pNext<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>(static_cast<const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX*>(object), settings, "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX", indents, dump_html_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX);
        break;
    case 1000238000:
        dump_html_pNext<const VkPhysicalDeviceMemoryPriorityFeaturesEXT>(static_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(object), settings, "VkPhysicalDeviceMemoryPriorityFeaturesEXT", indents, dump_html_VkPhysicalDeviceMemoryPriorityFeaturesEXT);
        break;
    case 1000028002:
        dump_html_pNext<const VkPipelineRasterizationStateStreamCreateInfoEXT>(static_cast<const VkPipelineRasterizationStateStreamCreateInfoEXT*>(object), settings, "VkPipelineRasterizationStateStreamCreateInfoEXT", indents, dump_html_VkPipelineRasterizationStateStreamCreateInfoEXT);
        break;
    case 1000225002:
        dump_html_pNext<const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT>(static_cast<const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT*>(object), settings, "VkPhysicalDeviceSubgroupSizeControlFeaturesEXT", indents, dump_html_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT);
        break;
    case 1000251000:
        dump_html_pNext<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>(static_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(object), settings, "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT", indents, dump_html_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT);
        break;
    case 1000098000:
        dump_html_pNext<const VkPipelineViewportSwizzleStateCreateInfoNV>(static_cast<const VkPipelineViewportSwizzleStateCreateInfoNV*>(object), settings, "VkPipelineViewportSwizzleStateCreateInfoNV", indents, dump_html_VkPipelineViewportSwizzleStateCreateInfoNV);
        break;
    case 1000177000:
        dump_html_pNext<const VkPhysicalDevice8BitStorageFeaturesKHR>(static_cast<const VkPhysicalDevice8BitStorageFeaturesKHR*>(object), settings, "VkPhysicalDevice8BitStorageFeaturesKHR", indents, dump_html_VkPhysicalDevice8BitStorageFeaturesKHR);
        break;
    case 1000060009:
        dump_html_pNext<const VkBindImageMemorySwapchainInfoKHR>(static_cast<const VkBindImageMemorySwapchainInfoKHR*>(object), settings, "VkBindImageMemorySwapchainInfoKHR", indents, dump_html_VkBindImageMemorySwapchainInfoKHR);
        break;
    case 1000185000:
        dump_html_pNext<const VkPhysicalDeviceShaderCorePropertiesAMD>(static_cast<const VkPhysicalDeviceShaderCorePropertiesAMD*>(object), settings, "VkPhysicalDeviceShaderCorePropertiesAMD", indents, dump_html_VkPhysicalDeviceShaderCorePropertiesAMD);
        break;
    case 1000237000:
        dump_html_pNext<const VkPhysicalDeviceMemoryBudgetPropertiesEXT>(static_cast<const VkPhysicalDeviceMemoryBudgetPropertiesEXT*>(object), settings, "VkPhysicalDeviceMemoryBudgetPropertiesEXT", indents, dump_html_VkPhysicalDeviceMemoryBudgetPropertiesEXT);
        break;
    case 1000252000:
        dump_html_pNext<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>(static_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(object), settings, "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT", indents, dump_html_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT);
        break;
    case 1000225001:
        dump_html_pNext<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT>(static_cast<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT*>(object), settings, "VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT", indents, dump_html_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT);
        break;
    case 1000238001:
        dump_html_pNext<const VkMemoryPriorityAllocateInfoEXT>(static_cast<const VkMemoryPriorityAllocateInfoEXT*>(object), settings, "VkMemoryPriorityAllocateInfoEXT", indents, dump_html_VkMemoryPriorityAllocateInfoEXT);
        break;
    case 1000178000:
        dump_html_pNext<const VkImportMemoryHostPointerInfoEXT>(static_cast<const VkImportMemoryHostPointerInfoEXT*>(object), settings, "VkImportMemoryHostPointerInfoEXT", indents, dump_html_VkImportMemoryHostPointerInfoEXT);
        break;
    case 1000239000:
        dump_html_pNext<const VkSurfaceProtectedCapabilitiesKHR>(static_cast<const VkSurfaceProtectedCapabilitiesKHR*>(object), settings, "VkSurfaceProtectedCapabilitiesKHR", indents, dump_html_VkSurfaceProtectedCapabilitiesKHR);
        break;
    case 1000178002:
        dump_html_pNext<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT>(static_cast<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT*>(object), settings, "VkPhysicalDeviceExternalMemoryHostPropertiesEXT", indents, dump_html_VkPhysicalDeviceExternalMemoryHostPropertiesEXT);
        break;
    case 1000227000:
        dump_html_pNext<const VkPhysicalDeviceShaderCoreProperties2AMD>(static_cast<const VkPhysicalDeviceShaderCoreProperties2AMD*>(object), settings, "VkPhysicalDeviceShaderCoreProperties2AMD", indents, dump_html_VkPhysicalDeviceShaderCoreProperties2AMD);
        break;
    case 1000249002:
        dump_html_pNext<const VkPhysicalDeviceCooperativeMatrixPropertiesNV>(static_cast<const VkPhysicalDeviceCooperativeMatrixPropertiesNV*>(object), settings, "VkPhysicalDeviceCooperativeMatrixPropertiesNV", indents, dump_html_VkPhysicalDeviceCooperativeMatrixPropertiesNV);
        break;
    case 1000253000:
        dump_html_pNext<const VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR>(static_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR*>(object), settings, "VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR", indents, dump_html_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR);
        break;
    case 1000240000:
        dump_html_pNext<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>(static_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(object), settings, "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV", indents, dump_html_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV);
        break;
    case 1000060011:
        dump_html_pNext<const VkDeviceGroupPresentInfoKHR>(static_cast<const VkDeviceGroupPresentInfoKHR*>(object), settings, "VkDeviceGroupPresentInfoKHR", indents, dump_html_VkDeviceGroupPresentInfoKHR);
        break;
    case 1000244000:
        dump_html_pNext<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>(static_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(object), settings, "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT", indents, dump_html_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000255000:
        dump_html_pNext<const VkSurfaceFullScreenExclusiveInfoEXT>(static_cast<const VkSurfaceFullScreenExclusiveInfoEXT*>(object), settings, "VkSurfaceFullScreenExclusiveInfoEXT", indents, dump_html_VkSurfaceFullScreenExclusiveInfoEXT);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000255002:
        dump_html_pNext<const VkSurfaceCapabilitiesFullScreenExclusiveEXT>(static_cast<const VkSurfaceCapabilitiesFullScreenExclusiveEXT*>(object), settings, "VkSurfaceCapabilitiesFullScreenExclusiveEXT", indents, dump_html_VkSurfaceCapabilitiesFullScreenExclusiveEXT);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000018000:
        dump_html_pNext<const VkPipelineRasterizationStateRasterizationOrderAMD>(static_cast<const VkPipelineRasterizationStateRasterizationOrderAMD*>(object), settings, "VkPipelineRasterizationStateRasterizationOrderAMD", indents, dump_html_VkPipelineRasterizationStateRasterizationOrderAMD);
        break;
    case 1000060012:
        dump_html_pNext<const VkDeviceGroupSwapchainCreateInfoKHR>(static_cast<const VkDeviceGroupSwapchainCreateInfoKHR*>(object), settings, "VkDeviceGroupSwapchainCreateInfoKHR", indents, dump_html_VkDeviceGroupSwapchainCreateInfoKHR);
        break;
    case 1000249000:
        dump_html_pNext<const VkPhysicalDeviceCooperativeMatrixFeaturesNV>(static_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(object), settings, "VkPhysicalDeviceCooperativeMatrixFeaturesNV", indents, dump_html_VkPhysicalDeviceCooperativeMatrixFeaturesNV);
        break;
    case 1000180000:
        dump_html_pNext<const VkPhysicalDeviceShaderAtomicInt64FeaturesKHR>(static_cast<const VkPhysicalDeviceShaderAtomicInt64FeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderAtomicInt64FeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR);
        break;
    case 1000189000:
        dump_html_pNext<const VkDeviceMemoryOverallocationCreateInfoAMD>(static_cast<const VkDeviceMemoryOverallocationCreateInfoAMD*>(object), settings, "VkDeviceMemoryOverallocationCreateInfoAMD", indents, dump_html_VkDeviceMemoryOverallocationCreateInfoAMD);
        break;
    case 1000244002:
        dump_html_pNext<const VkBufferDeviceAddressCreateInfoEXT>(static_cast<const VkBufferDeviceAddressCreateInfoEXT*>(object), settings, "VkBufferDeviceAddressCreateInfoEXT", indents, dump_html_VkBufferDeviceAddressCreateInfoEXT);
        break;
    case 1000080000:
        dump_html_pNext<const VkPhysicalDevicePushDescriptorPropertiesKHR>(static_cast<const VkPhysicalDevicePushDescriptorPropertiesKHR*>(object), settings, "VkPhysicalDevicePushDescriptorPropertiesKHR", indents, dump_html_VkPhysicalDevicePushDescriptorPropertiesKHR);
        break;
    case 1000143000:
        dump_html_pNext<const VkSampleLocationsInfoEXT>(static_cast<const VkSampleLocationsInfoEXT*>(object), settings, "VkSampleLocationsInfoEXT", indents, dump_html_VkSampleLocationsInfoEXT);
        break;
    case 1000211000:
        dump_html_pNext<const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR>(static_cast<const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR*>(object), settings, "VkPhysicalDeviceVulkanMemoryModelFeaturesKHR", indents, dump_html_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000212000:
        dump_html_pNext<const VkPhysicalDevicePCIBusInfoPropertiesEXT>(static_cast<const VkPhysicalDevicePCIBusInfoPropertiesEXT*>(object), settings, "VkPhysicalDevicePCIBusInfoPropertiesEXT", indents, dump_html_VkPhysicalDevicePCIBusInfoPropertiesEXT);
        break;
    case 1000203000:
        dump_html_pNext<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV>(static_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV*>(object), settings, "VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV", indents, dump_html_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV);
        break;
    case 1000204000:
        dump_html_pNext<const VkPhysicalDeviceShaderImageFootprintFeaturesNV>(static_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(object), settings, "VkPhysicalDeviceShaderImageFootprintFeaturesNV", indents, dump_html_VkPhysicalDeviceShaderImageFootprintFeaturesNV);
        break;
    case 1000099000:
        dump_html_pNext<const VkPhysicalDeviceDiscardRectanglePropertiesEXT>(static_cast<const VkPhysicalDeviceDiscardRectanglePropertiesEXT*>(object), settings, "VkPhysicalDeviceDiscardRectanglePropertiesEXT", indents, dump_html_VkPhysicalDeviceDiscardRectanglePropertiesEXT);
        break;
    case 1000213000:
        dump_html_pNext<const VkDisplayNativeHdrSurfaceCapabilitiesAMD>(static_cast<const VkDisplayNativeHdrSurfaceCapabilitiesAMD*>(object), settings, "VkDisplayNativeHdrSurfaceCapabilitiesAMD", indents, dump_html_VkDisplayNativeHdrSurfaceCapabilitiesAMD);
        break;
    case 1000143001:
        dump_html_pNext<const VkRenderPassSampleLocationsBeginInfoEXT>(static_cast<const VkRenderPassSampleLocationsBeginInfoEXT*>(object), settings, "VkRenderPassSampleLocationsBeginInfoEXT", indents, dump_html_VkRenderPassSampleLocationsBeginInfoEXT);
        break;
    case 1000099001:
        dump_html_pNext<const VkPipelineDiscardRectangleStateCreateInfoEXT>(static_cast<const VkPipelineDiscardRectangleStateCreateInfoEXT*>(object), settings, "VkPipelineDiscardRectangleStateCreateInfoEXT", indents, dump_html_VkPipelineDiscardRectangleStateCreateInfoEXT);
        break;
    case 1000143003:
        dump_html_pNext<const VkPhysicalDeviceSampleLocationsPropertiesEXT>(static_cast<const VkPhysicalDeviceSampleLocationsPropertiesEXT*>(object), settings, "VkPhysicalDeviceSampleLocationsPropertiesEXT", indents, dump_html_VkPhysicalDeviceSampleLocationsPropertiesEXT);
        break;
    case 1000205002:
        dump_html_pNext<const VkPhysicalDeviceExclusiveScissorFeaturesNV>(static_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(object), settings, "VkPhysicalDeviceExclusiveScissorFeaturesNV", indents, dump_html_VkPhysicalDeviceExclusiveScissorFeaturesNV);
        break;
    case 1000166000:
        dump_html_pNext<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>(static_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(object), settings, "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV", indents, dump_html_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV);
        break;
    case 1000081000:
        dump_html_pNext<const VkCommandBufferInheritanceConditionalRenderingInfoEXT>(static_cast<const VkCommandBufferInheritanceConditionalRenderingInfoEXT*>(object), settings, "VkCommandBufferInheritanceConditionalRenderingInfoEXT", indents, dump_html_VkCommandBufferInheritanceConditionalRenderingInfoEXT);
        break;
    case 1000143002:
        dump_html_pNext<const VkPipelineSampleLocationsStateCreateInfoEXT>(static_cast<const VkPipelineSampleLocationsStateCreateInfoEXT*>(object), settings, "VkPipelineSampleLocationsStateCreateInfoEXT", indents, dump_html_VkPipelineSampleLocationsStateCreateInfoEXT);
        break;
    case 1000213001:
        dump_html_pNext<const VkSwapchainDisplayNativeHdrCreateInfoAMD>(static_cast<const VkSwapchainDisplayNativeHdrCreateInfoAMD*>(object), settings, "VkSwapchainDisplayNativeHdrCreateInfoAMD", indents, dump_html_VkSwapchainDisplayNativeHdrCreateInfoAMD);
        break;
    case 1000205000:
        dump_html_pNext<const VkPipelineViewportExclusiveScissorStateCreateInfoNV>(static_cast<const VkPipelineViewportExclusiveScissorStateCreateInfoNV*>(object), settings, "VkPipelineViewportExclusiveScissorStateCreateInfoNV", indents, dump_html_VkPipelineViewportExclusiveScissorStateCreateInfoNV);
        break;
    case 1000081001:
        dump_html_pNext<const VkPhysicalDeviceConditionalRenderingFeaturesEXT>(static_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(object), settings, "VkPhysicalDeviceConditionalRenderingFeaturesEXT", indents, dump_html_VkPhysicalDeviceConditionalRenderingFeaturesEXT);
        break;
    case 1000059000:
        dump_html_pNext<const VkPhysicalDeviceFeatures2>(static_cast<const VkPhysicalDeviceFeatures2*>(object), settings, "VkPhysicalDeviceFeatures2", indents, dump_html_VkPhysicalDeviceFeatures2);
        break;
#if defined(VK_USE_PLATFORM_FUCHSIA)
#endif // VK_USE_PLATFORM_FUCHSIA
    case 1000101000:
        dump_html_pNext<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT>(static_cast<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT*>(object), settings, "VkPhysicalDeviceConservativeRasterizationPropertiesEXT", indents, dump_html_VkPhysicalDeviceConservativeRasterizationPropertiesEXT);
        break;
    case 1000091003:
        dump_html_pNext<const VkSwapchainCounterCreateInfoEXT>(static_cast<const VkSwapchainCounterCreateInfoEXT*>(object), settings, "VkSwapchainCounterCreateInfoEXT", indents, dump_html_VkSwapchainCounterCreateInfoEXT);
        break;
    case 1000101001:
        dump_html_pNext<const VkPipelineRasterizationConservativeStateCreateInfoEXT>(static_cast<const VkPipelineRasterizationConservativeStateCreateInfoEXT*>(object), settings, "VkPipelineRasterizationConservativeStateCreateInfoEXT", indents, dump_html_VkPipelineRasterizationConservativeStateCreateInfoEXT);
        break;
    case 1000166001:
        dump_html_pNext<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV>(static_cast<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV*>(object), settings, "VkPipelineRepresentativeFragmentTestStateCreateInfoNV", indents, dump_html_VkPipelineRepresentativeFragmentTestStateCreateInfoNV);
        break;
    case 1000206001:
        dump_html_pNext<const VkQueueFamilyCheckpointPropertiesNV>(static_cast<const VkQueueFamilyCheckpointPropertiesNV*>(object), settings, "VkQueueFamilyCheckpointPropertiesNV", indents, dump_html_VkQueueFamilyCheckpointPropertiesNV);
        break;
    case 1000082000:
        dump_html_pNext<const VkPhysicalDeviceShaderFloat16Int8FeaturesKHR>(static_cast<const VkPhysicalDeviceShaderFloat16Int8FeaturesKHR*>(object), settings, "VkPhysicalDeviceShaderFloat16Int8FeaturesKHR", indents, dump_html_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR);
        break;
#if defined(VK_USE_PLATFORM_METAL_EXT)
#endif // VK_USE_PLATFORM_METAL_EXT
    case 1000102000:
        dump_html_pNext<const VkPhysicalDeviceDepthClipEnableFeaturesEXT>(static_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(object), settings, "VkPhysicalDeviceDepthClipEnableFeaturesEXT", indents, dump_html_VkPhysicalDeviceDepthClipEnableFeaturesEXT);
        break;
    case 1000147000:
        dump_html_pNext<const VkImageFormatListCreateInfoKHR>(static_cast<const VkImageFormatListCreateInfoKHR*>(object), settings, "VkImageFormatListCreateInfoKHR", indents, dump_html_VkImageFormatListCreateInfoKHR);
        break;
    case 1000084000:
        dump_html_pNext<const VkPresentRegionsKHR>(static_cast<const VkPresentRegionsKHR*>(object), settings, "VkPresentRegionsKHR", indents, dump_html_VkPresentRegionsKHR);
        break;
    case 1000218000:
        dump_html_pNext<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT>(static_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(object), settings, "VkPhysicalDeviceFragmentDensityMapFeaturesEXT", indents, dump_html_VkPhysicalDeviceFragmentDensityMapFeaturesEXT);
        break;
    case 1000170000:
        dump_html_pNext<const VkPhysicalDeviceImageViewImageFormatInfoEXT>(static_cast<const VkPhysicalDeviceImageViewImageFormatInfoEXT*>(object), settings, "VkPhysicalDeviceImageViewImageFormatInfoEXT", indents, dump_html_VkPhysicalDeviceImageViewImageFormatInfoEXT);
        break;
    case 1000218001:
        dump_html_pNext<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT>(static_cast<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT*>(object), settings, "VkPhysicalDeviceFragmentDensityMapPropertiesEXT", indents, dump_html_VkPhysicalDeviceFragmentDensityMapPropertiesEXT);
        break;
    case 1000003000:
        dump_html_pNext<const VkDisplayPresentInfoKHR>(static_cast<const VkDisplayPresentInfoKHR*>(object), settings, "VkDisplayPresentInfoKHR", indents, dump_html_VkDisplayPresentInfoKHR);
        break;
    case 1000041000:
        dump_html_pNext<const VkTextureLODGatherFormatPropertiesAMD>(static_cast<const VkTextureLODGatherFormatPropertiesAMD*>(object), settings, "VkTextureLODGatherFormatPropertiesAMD", indents, dump_html_VkTextureLODGatherFormatPropertiesAMD);
        break;
    case 1000102001:
        dump_html_pNext<const VkPipelineRasterizationDepthClipStateCreateInfoEXT>(static_cast<const VkPipelineRasterizationDepthClipStateCreateInfoEXT*>(object), settings, "VkPipelineRasterizationDepthClipStateCreateInfoEXT", indents, dump_html_VkPipelineRasterizationDepthClipStateCreateInfoEXT);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000255001:
        dump_html_pNext<const VkSurfaceFullScreenExclusiveWin32InfoEXT>(static_cast<const VkSurfaceFullScreenExclusiveWin32InfoEXT*>(object), settings, "VkSurfaceFullScreenExclusiveWin32InfoEXT", indents, dump_html_VkSurfaceFullScreenExclusiveWin32InfoEXT);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000259000:
        dump_html_pNext<const VkPhysicalDeviceLineRasterizationFeaturesEXT>(static_cast<const VkPhysicalDeviceLineRasterizationFeaturesEXT*>(object), settings, "VkPhysicalDeviceLineRasterizationFeaturesEXT", indents, dump_html_VkPhysicalDeviceLineRasterizationFeaturesEXT);
        break;
    case 1000259002:
        dump_html_pNext<const VkPhysicalDeviceLineRasterizationPropertiesEXT>(static_cast<const VkPhysicalDeviceLineRasterizationPropertiesEXT*>(object), settings, "VkPhysicalDeviceLineRasterizationPropertiesEXT", indents, dump_html_VkPhysicalDeviceLineRasterizationPropertiesEXT);
        break;
    case 1000276000:
        dump_html_pNext<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT>(static_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT*>(object), settings, "VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT", indents, dump_html_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT);
        break;
    case 1000108000:
        dump_html_pNext<const VkPhysicalDeviceImagelessFramebufferFeaturesKHR>(static_cast<const VkPhysicalDeviceImagelessFramebufferFeaturesKHR*>(object), settings, "VkPhysicalDeviceImagelessFramebufferFeaturesKHR", indents, dump_html_VkPhysicalDeviceImagelessFramebufferFeaturesKHR);
        break;
#if defined(VK_USE_PLATFORM_XLIB_KHR)
#endif // VK_USE_PLATFORM_XLIB_KHR
    case 1000259001:
        dump_html_pNext<const VkPipelineRasterizationLineStateCreateInfoEXT>(static_cast<const VkPipelineRasterizationLineStateCreateInfoEXT*>(object), settings, "VkPipelineRasterizationLineStateCreateInfoEXT", indents, dump_html_VkPipelineRasterizationLineStateCreateInfoEXT);
        break;
    case 1000281000:
        dump_html_pNext<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>(static_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(object), settings, "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT", indents, dump_html_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT);
        break;
    case 1000108001:
        dump_html_pNext<const VkFramebufferAttachmentsCreateInfoKHR>(static_cast<const VkFramebufferAttachmentsCreateInfoKHR*>(object), settings, "VkFramebufferAttachmentsCreateInfoKHR", indents, dump_html_VkFramebufferAttachmentsCreateInfoKHR);
        break;
    case 1000261000:
        dump_html_pNext<const VkPhysicalDeviceHostQueryResetFeaturesEXT>(static_cast<const VkPhysicalDeviceHostQueryResetFeaturesEXT*>(object), settings, "VkPhysicalDeviceHostQueryResetFeaturesEXT", indents, dump_html_VkPhysicalDeviceHostQueryResetFeaturesEXT);
        break;
    case 1000281001:
        dump_html_pNext<const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT>(static_cast<const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT*>(object), settings, "VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT", indents, dump_html_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT);
        break;
#if defined(VK_USE_PLATFORM_IOS_MVK)
#endif // VK_USE_PLATFORM_IOS_MVK
    case 1000028001:
        dump_html_pNext<const VkPhysicalDeviceTransformFeedbackPropertiesEXT>(static_cast<const VkPhysicalDeviceTransformFeedbackPropertiesEXT*>(object), settings, "VkPhysicalDeviceTransformFeedbackPropertiesEXT", indents, dump_html_VkPhysicalDeviceTransformFeedbackPropertiesEXT);
        break;
    case 1000117000:
        dump_html_pNext<const VkPhysicalDevicePointClippingProperties>(static_cast<const VkPhysicalDevicePointClippingProperties*>(object), settings, "VkPhysicalDevicePointClippingProperties", indents, dump_html_VkPhysicalDevicePointClippingProperties);
        break;
    case 1000108003:
        dump_html_pNext<const VkRenderPassAttachmentBeginInfoKHR>(static_cast<const VkRenderPassAttachmentBeginInfoKHR*>(object), settings, "VkRenderPassAttachmentBeginInfoKHR", indents, dump_html_VkRenderPassAttachmentBeginInfoKHR);
        break;
    case 1000117001:
        dump_html_pNext<const VkRenderPassInputAttachmentAspectCreateInfo>(static_cast<const VkRenderPassInputAttachmentAspectCreateInfo*>(object), settings, "VkRenderPassInputAttachmentAspectCreateInfo", indents, dump_html_VkRenderPassInputAttachmentAspectCreateInfo);
        break;
    case 1000028000:
        dump_html_pNext<const VkPhysicalDeviceTransformFeedbackFeaturesEXT>(static_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(object), settings, "VkPhysicalDeviceTransformFeedbackFeaturesEXT", indents, dump_html_VkPhysicalDeviceTransformFeedbackFeaturesEXT);
        break;
#if defined(VK_USE_PLATFORM_GGP)
#endif // VK_USE_PLATFORM_GGP
    case 1000190000:
        dump_html_pNext<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>(static_cast<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT*>(object), settings, "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT", indents, dump_html_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT);
        break;
    case 1000165009:
        dump_html_pNext<const VkPhysicalDeviceRayTracingPropertiesNV>(static_cast<const VkPhysicalDeviceRayTracingPropertiesNV*>(object), settings, "VkPhysicalDeviceRayTracingPropertiesNV", indents, dump_html_VkPhysicalDeviceRayTracingPropertiesNV);
        break;
    case 1000050000:
        dump_html_pNext<const VkPhysicalDeviceCornerSampledImageFeaturesNV>(static_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(object), settings, "VkPhysicalDeviceCornerSampledImageFeaturesNV", indents, dump_html_VkPhysicalDeviceCornerSampledImageFeaturesNV);
        break;
#if defined(VK_USE_PLATFORM_GGP)
    case 1000191000:
        dump_html_pNext<const VkPresentFrameTokenGGP>(static_cast<const VkPresentFrameTokenGGP*>(object), settings, "VkPresentFrameTokenGGP", indents, dump_html_VkPresentFrameTokenGGP);
        break;
#endif // VK_USE_PLATFORM_GGP
    case 1000190001:
        dump_html_pNext<const VkPipelineVertexInputDivisorStateCreateInfoEXT>(static_cast<const VkPipelineVertexInputDivisorStateCreateInfoEXT*>(object), settings, "VkPipelineVertexInputDivisorStateCreateInfoEXT", indents, dump_html_VkPipelineVertexInputDivisorStateCreateInfoEXT);
        break;
    case 1000190002:
        dump_html_pNext<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT>(static_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT*>(object), settings, "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT", indents, dump_html_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT);
        break;
    case 1000083000:
        dump_html_pNext<const VkPhysicalDevice16BitStorageFeatures>(static_cast<const VkPhysicalDevice16BitStorageFeatures*>(object), settings, "VkPhysicalDevice16BitStorageFeatures", indents, dump_html_VkPhysicalDevice16BitStorageFeatures);
        break;
    case 1000192000:
        dump_html_pNext<const VkPipelineCreationFeedbackCreateInfoEXT>(static_cast<const VkPipelineCreationFeedbackCreateInfoEXT*>(object), settings, "VkPipelineCreationFeedbackCreateInfoEXT", indents, dump_html_VkPipelineCreationFeedbackCreateInfoEXT);
        break;
    case 1000056000:
        dump_html_pNext<const VkExternalMemoryImageCreateInfoNV>(static_cast<const VkExternalMemoryImageCreateInfoNV*>(object), settings, "VkExternalMemoryImageCreateInfoNV", indents, dump_html_VkExternalMemoryImageCreateInfoNV);
        break;
    case 1000056001:
        dump_html_pNext<const VkExportMemoryAllocateInfoNV>(static_cast<const VkExportMemoryAllocateInfoNV*>(object), settings, "VkExportMemoryAllocateInfoNV", indents, dump_html_VkExportMemoryAllocateInfoNV);
        break;
    case 1000127000:
        dump_html_pNext<const VkMemoryDedicatedRequirements>(static_cast<const VkMemoryDedicatedRequirements*>(object), settings, "VkMemoryDedicatedRequirements", indents, dump_html_VkMemoryDedicatedRequirements);
        break;
    case 1000196000:
        dump_html_pNext<const VkPhysicalDeviceDriverPropertiesKHR>(static_cast<const VkPhysicalDeviceDriverPropertiesKHR*>(object), settings, "VkPhysicalDeviceDriverPropertiesKHR", indents, dump_html_VkPhysicalDeviceDriverPropertiesKHR);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000057000:
        dump_html_pNext<const VkImportMemoryWin32HandleInfoNV>(static_cast<const VkImportMemoryWin32HandleInfoNV*>(object), settings, "VkImportMemoryWin32HandleInfoNV", indents, dump_html_VkImportMemoryWin32HandleInfoNV);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000127001:
        dump_html_pNext<const VkMemoryDedicatedAllocateInfo>(static_cast<const VkMemoryDedicatedAllocateInfo*>(object), settings, "VkMemoryDedicatedAllocateInfo", indents, dump_html_VkMemoryDedicatedAllocateInfo);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000057001:
        dump_html_pNext<const VkExportMemoryWin32HandleInfoNV>(static_cast<const VkExportMemoryWin32HandleInfoNV*>(object), settings, "VkExportMemoryWin32HandleInfoNV", indents, dump_html_VkExportMemoryWin32HandleInfoNV);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000058000:
        dump_html_pNext<const VkWin32KeyedMutexAcquireReleaseInfoNV>(static_cast<const VkWin32KeyedMutexAcquireReleaseInfoNV*>(object), settings, "VkWin32KeyedMutexAcquireReleaseInfoNV", indents, dump_html_VkWin32KeyedMutexAcquireReleaseInfoNV);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000060003:
        dump_html_pNext<const VkDeviceGroupRenderPassBeginInfo>(static_cast<const VkDeviceGroupRenderPassBeginInfo*>(object), settings, "VkDeviceGroupRenderPassBeginInfo", indents, dump_html_VkDeviceGroupRenderPassBeginInfo);
        break;
    case 1000060000:
        dump_html_pNext<const VkMemoryAllocateFlagsInfo>(static_cast<const VkMemoryAllocateFlagsInfo*>(object), settings, "VkMemoryAllocateFlagsInfo", indents, dump_html_VkMemoryAllocateFlagsInfo);
        break;
    case 1000197000:
        dump_html_pNext<const VkPhysicalDeviceFloatControlsPropertiesKHR>(static_cast<const VkPhysicalDeviceFloatControlsPropertiesKHR*>(object), settings, "VkPhysicalDeviceFloatControlsPropertiesKHR", indents, dump_html_VkPhysicalDeviceFloatControlsPropertiesKHR);
        break;
    case 1000164005:
        dump_html_pNext<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>(static_cast<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV*>(object), settings, "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV", indents, dump_html_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV);
        break;
    case 1000265000:
        dump_html_pNext<const VkPhysicalDeviceIndexTypeUint8FeaturesEXT>(static_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesEXT*>(object), settings, "VkPhysicalDeviceIndexTypeUint8FeaturesEXT", indents, dump_html_VkPhysicalDeviceIndexTypeUint8FeaturesEXT);
        break;
    case 1000026000:
        dump_html_pNext<const VkDedicatedAllocationImageCreateInfoNV>(static_cast<const VkDedicatedAllocationImageCreateInfoNV*>(object), settings, "VkDedicatedAllocationImageCreateInfoNV", indents, dump_html_VkDedicatedAllocationImageCreateInfoNV);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000026001:
        dump_html_pNext<const VkDedicatedAllocationBufferCreateInfoNV>(static_cast<const VkDedicatedAllocationBufferCreateInfoNV*>(object), settings, "VkDedicatedAllocationBufferCreateInfoNV", indents, dump_html_VkDedicatedAllocationBufferCreateInfoNV);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000078001:
        dump_html_pNext<const VkExportSemaphoreWin32HandleInfoKHR>(static_cast<const VkExportSemaphoreWin32HandleInfoKHR*>(object), settings, "VkExportSemaphoreWin32HandleInfoKHR", indents, dump_html_VkExportSemaphoreWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000269000:
        dump_html_pNext<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>(static_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(object), settings, "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR", indents, dump_html_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR);
        break;
    case 1000026002:
        dump_html_pNext<const VkDedicatedAllocationMemoryAllocateInfoNV>(static_cast<const VkDedicatedAllocationMemoryAllocateInfoNV*>(object), settings, "VkDedicatedAllocationMemoryAllocateInfoNV", indents, dump_html_VkDedicatedAllocationMemoryAllocateInfoNV);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000078002:
        dump_html_pNext<const VkD3D12FenceSubmitInfoKHR>(static_cast<const VkD3D12FenceSubmitInfoKHR*>(object), settings, "VkD3D12FenceSubmitInfoKHR", indents, dump_html_VkD3D12FenceSubmitInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000073001:
        dump_html_pNext<const VkExportMemoryWin32HandleInfoKHR>(static_cast<const VkExportMemoryWin32HandleInfoKHR*>(object), settings, "VkExportMemoryWin32HandleInfoKHR", indents, dump_html_VkExportMemoryWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129000:
        dump_html_pNext<const VkAndroidHardwareBufferUsageANDROID>(static_cast<const VkAndroidHardwareBufferUsageANDROID*>(object), settings, "VkAndroidHardwareBufferUsageANDROID", indents, dump_html_VkAndroidHardwareBufferUsageANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129002:
        dump_html_pNext<const VkAndroidHardwareBufferFormatPropertiesANDROID>(static_cast<const VkAndroidHardwareBufferFormatPropertiesANDROID*>(object), settings, "VkAndroidHardwareBufferFormatPropertiesANDROID", indents, dump_html_VkAndroidHardwareBufferFormatPropertiesANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129003:
        dump_html_pNext<const VkImportAndroidHardwareBufferInfoANDROID>(static_cast<const VkImportAndroidHardwareBufferInfoANDROID*>(object), settings, "VkImportAndroidHardwareBufferInfoANDROID", indents, dump_html_VkImportAndroidHardwareBufferInfoANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
    case 1000060004:
        dump_html_pNext<const VkDeviceGroupCommandBufferBeginInfo>(static_cast<const VkDeviceGroupCommandBufferBeginInfo*>(object), settings, "VkDeviceGroupCommandBufferBeginInfo", indents, dump_html_VkDeviceGroupCommandBufferBeginInfo);
        break;
    case 1000113000:
        dump_html_pNext<const VkExportFenceCreateInfo>(static_cast<const VkExportFenceCreateInfo*>(object), settings, "VkExportFenceCreateInfo", indents, dump_html_VkExportFenceCreateInfo);
        break;
    case 1000148000:
        dump_html_pNext<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>(static_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(object), settings, "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT", indents, dump_html_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT);
        break;
    case 1000158002:
        dump_html_pNext<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT>(static_cast<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT*>(object), settings, "VkPhysicalDeviceImageDrmFormatModifierInfoEXT", indents, dump_html_VkPhysicalDeviceImageDrmFormatModifierInfoEXT);
        break;
#if defined(VK_USE_PLATFORM_MACOS_MVK)
#endif // VK_USE_PLATFORM_MACOS_MVK
    case 1000117002:
        dump_html_pNext<const VkImageViewUsageCreateInfo>(static_cast<const VkImageViewUsageCreateInfo*>(object), settings, "VkImageViewUsageCreateInfo", indents, dump_html_VkImageViewUsageCreateInfo);
        break;
    case 1000060005:
        dump_html_pNext<const VkDeviceGroupSubmitInfo>(static_cast<const VkDeviceGroupSubmitInfo*>(object), settings, "VkDeviceGroupSubmitInfo", indents, dump_html_VkDeviceGroupSubmitInfo);
        break;
    case 1000148001:
        dump_html_pNext<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>(static_cast<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT*>(object), settings, "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT", indents, dump_html_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
    case 1000129005:
        dump_html_pNext<const VkExternalFormatANDROID>(static_cast<const VkExternalFormatANDROID*>(object), settings, "VkExternalFormatANDROID", indents, dump_html_VkExternalFormatANDROID);
        break;
#endif // VK_USE_PLATFORM_ANDROID_KHR
    case 1000077000:
        dump_html_pNext<const VkExportSemaphoreCreateInfo>(static_cast<const VkExportSemaphoreCreateInfo*>(object), settings, "VkExportSemaphoreCreateInfo", indents, dump_html_VkExportSemaphoreCreateInfo);
        break;
    case 1000111000:
        dump_html_pNext<const VkSharedPresentSurfaceCapabilitiesKHR>(static_cast<const VkSharedPresentSurfaceCapabilitiesKHR*>(object), settings, "VkSharedPresentSurfaceCapabilitiesKHR", indents, dump_html_VkSharedPresentSurfaceCapabilitiesKHR);
        break;
    case 1000148002:
        dump_html_pNext<const VkPipelineColorBlendAdvancedStateCreateInfoEXT>(static_cast<const VkPipelineColorBlendAdvancedStateCreateInfoEXT*>(object), settings, "VkPipelineColorBlendAdvancedStateCreateInfoEXT", indents, dump_html_VkPipelineColorBlendAdvancedStateCreateInfoEXT);
        break;
    case 1000117003:
        dump_html_pNext<const VkPipelineTessellationDomainOriginStateCreateInfo>(static_cast<const VkPipelineTessellationDomainOriginStateCreateInfo*>(object), settings, "VkPipelineTessellationDomainOriginStateCreateInfo", indents, dump_html_VkPipelineTessellationDomainOriginStateCreateInfo);
        break;
    case 1000158000:
        dump_html_pNext<const VkDrmFormatModifierPropertiesListEXT>(static_cast<const VkDrmFormatModifierPropertiesListEXT*>(object), settings, "VkDrmFormatModifierPropertiesListEXT", indents, dump_html_VkDrmFormatModifierPropertiesListEXT);
        break;
    case 1000060006:
        dump_html_pNext<const VkDeviceGroupBindSparseInfo>(static_cast<const VkDeviceGroupBindSparseInfo*>(object), settings, "VkDeviceGroupBindSparseInfo", indents, dump_html_VkDeviceGroupBindSparseInfo);
        break;
    case 1000053000:
        dump_html_pNext<const VkRenderPassMultiviewCreateInfo>(static_cast<const VkRenderPassMultiviewCreateInfo*>(object), settings, "VkRenderPassMultiviewCreateInfo", indents, dump_html_VkRenderPassMultiviewCreateInfo);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000114001:
        dump_html_pNext<const VkExportFenceWin32HandleInfoKHR>(static_cast<const VkExportFenceWin32HandleInfoKHR*>(object), settings, "VkExportFenceWin32HandleInfoKHR", indents, dump_html_VkExportFenceWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000053001:
        dump_html_pNext<const VkPhysicalDeviceMultiviewFeatures>(static_cast<const VkPhysicalDeviceMultiviewFeatures*>(object), settings, "VkPhysicalDeviceMultiviewFeatures", indents, dump_html_VkPhysicalDeviceMultiviewFeatures);
        break;
    case 1000158004:
        dump_html_pNext<const VkImageDrmFormatModifierExplicitCreateInfoEXT>(static_cast<const VkImageDrmFormatModifierExplicitCreateInfoEXT*>(object), settings, "VkImageDrmFormatModifierExplicitCreateInfoEXT", indents, dump_html_VkImageDrmFormatModifierExplicitCreateInfoEXT);
        break;
    case 1000138001:
        dump_html_pNext<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT>(static_cast<const VkPhysicalDeviceInlineUniformBlockPropertiesEXT*>(object), settings, "VkPhysicalDeviceInlineUniformBlockPropertiesEXT", indents, dump_html_VkPhysicalDeviceInlineUniformBlockPropertiesEXT);
        break;
    case 1000145001:
        dump_html_pNext<const VkPhysicalDeviceProtectedMemoryFeatures>(static_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(object), settings, "VkPhysicalDeviceProtectedMemoryFeatures", indents, dump_html_VkPhysicalDeviceProtectedMemoryFeatures);
        break;
    case 1000130001:
        dump_html_pNext<const VkSamplerReductionModeCreateInfoEXT>(static_cast<const VkSamplerReductionModeCreateInfoEXT*>(object), settings, "VkSamplerReductionModeCreateInfoEXT", indents, dump_html_VkSamplerReductionModeCreateInfoEXT);
        break;
    case 1000158003:
        dump_html_pNext<const VkImageDrmFormatModifierListCreateInfoEXT>(static_cast<const VkImageDrmFormatModifierListCreateInfoEXT*>(object), settings, "VkImageDrmFormatModifierListCreateInfoEXT", indents, dump_html_VkImageDrmFormatModifierListCreateInfoEXT);
        break;
    case 1000152000:
        dump_html_pNext<const VkPipelineCoverageModulationStateCreateInfoNV>(static_cast<const VkPipelineCoverageModulationStateCreateInfoNV*>(object), settings, "VkPipelineCoverageModulationStateCreateInfoNV", indents, dump_html_VkPipelineCoverageModulationStateCreateInfoNV);
        break;
    case 1000060014:
        dump_html_pNext<const VkBindImageMemoryDeviceGroupInfo>(static_cast<const VkBindImageMemoryDeviceGroupInfo*>(object), settings, "VkBindImageMemoryDeviceGroupInfo", indents, dump_html_VkBindImageMemoryDeviceGroupInfo);
        break;
    case 1000128004:
        dump_html_pNext<const VkDebugUtilsMessengerCreateInfoEXT>(static_cast<const VkDebugUtilsMessengerCreateInfoEXT*>(object), settings, "VkDebugUtilsMessengerCreateInfoEXT", indents, dump_html_VkDebugUtilsMessengerCreateInfoEXT);
        break;
    case 1000149000:
        dump_html_pNext<const VkPipelineCoverageToColorStateCreateInfoNV>(static_cast<const VkPipelineCoverageToColorStateCreateInfoNV*>(object), settings, "VkPipelineCoverageToColorStateCreateInfoNV", indents, dump_html_VkPipelineCoverageToColorStateCreateInfoNV);
        break;
    case 1000130000:
        dump_html_pNext<const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>(static_cast<const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT*>(object), settings, "VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT", indents, dump_html_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT);
        break;
    case 1000074000:
        dump_html_pNext<const VkImportMemoryFdInfoKHR>(static_cast<const VkImportMemoryFdInfoKHR*>(object), settings, "VkImportMemoryFdInfoKHR", indents, dump_html_VkImportMemoryFdInfoKHR);
        break;
    case 1000154000:
        dump_html_pNext<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>(static_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(object), settings, "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV", indents, dump_html_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV);
        break;
    case 1000060013:
        dump_html_pNext<const VkBindBufferMemoryDeviceGroupInfo>(static_cast<const VkBindBufferMemoryDeviceGroupInfo*>(object), settings, "VkBindBufferMemoryDeviceGroupInfo", indents, dump_html_VkBindBufferMemoryDeviceGroupInfo);
        break;
    case 1000053002:
        dump_html_pNext<const VkPhysicalDeviceMultiviewProperties>(static_cast<const VkPhysicalDeviceMultiviewProperties*>(object), settings, "VkPhysicalDeviceMultiviewProperties", indents, dump_html_VkPhysicalDeviceMultiviewProperties);
        break;
    case 1000138000:
        dump_html_pNext<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT>(static_cast<const VkPhysicalDeviceInlineUniformBlockFeaturesEXT*>(object), settings, "VkPhysicalDeviceInlineUniformBlockFeaturesEXT", indents, dump_html_VkPhysicalDeviceInlineUniformBlockFeaturesEXT);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000168000:
        dump_html_pNext<const VkPhysicalDeviceMaintenance3Properties>(static_cast<const VkPhysicalDeviceMaintenance3Properties*>(object), settings, "VkPhysicalDeviceMaintenance3Properties", indents, dump_html_VkPhysicalDeviceMaintenance3Properties);
        break;
    case 1000120000:
        dump_html_pNext<const VkPhysicalDeviceVariablePointersFeatures>(static_cast<const VkPhysicalDeviceVariablePointersFeatures*>(object), settings, "VkPhysicalDeviceVariablePointersFeatures", indents, dump_html_VkPhysicalDeviceVariablePointersFeatures);
        break;
    case 1000138003:
        dump_html_pNext<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT>(static_cast<const VkDescriptorPoolInlineUniformBlockCreateInfoEXT*>(object), settings, "VkDescriptorPoolInlineUniformBlockCreateInfoEXT", indents, dump_html_VkDescriptorPoolInlineUniformBlockCreateInfoEXT);
        break;
    case 1000154001:
        dump_html_pNext<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>(static_cast<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV*>(object), settings, "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV", indents, dump_html_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV);
        break;
    case 1000063000:
        dump_html_pNext<const VkPhysicalDeviceShaderDrawParametersFeatures>(static_cast<const VkPhysicalDeviceShaderDrawParametersFeatures*>(object), settings, "VkPhysicalDeviceShaderDrawParametersFeatures", indents, dump_html_VkPhysicalDeviceShaderDrawParametersFeatures);
        break;
    case 1000145002:
        dump_html_pNext<const VkPhysicalDeviceProtectedMemoryProperties>(static_cast<const VkPhysicalDeviceProtectedMemoryProperties*>(object), settings, "VkPhysicalDeviceProtectedMemoryProperties", indents, dump_html_VkPhysicalDeviceProtectedMemoryProperties);
        break;
    case 1000160001:
        dump_html_pNext<const VkShaderModuleValidationCacheCreateInfoEXT>(static_cast<const VkShaderModuleValidationCacheCreateInfoEXT*>(object), settings, "VkShaderModuleValidationCacheCreateInfoEXT", indents, dump_html_VkShaderModuleValidationCacheCreateInfoEXT);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000075000:
        dump_html_pNext<const VkWin32KeyedMutexAcquireReleaseInfoKHR>(static_cast<const VkWin32KeyedMutexAcquireReleaseInfoKHR*>(object), settings, "VkWin32KeyedMutexAcquireReleaseInfoKHR", indents, dump_html_VkWin32KeyedMutexAcquireReleaseInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
    case 1000138002:
        dump_html_pNext<const VkWriteDescriptorSetInlineUniformBlockEXT>(static_cast<const VkWriteDescriptorSetInlineUniformBlockEXT*>(object), settings, "VkWriteDescriptorSetInlineUniformBlockEXT", indents, dump_html_VkWriteDescriptorSetInlineUniformBlockEXT);
        break;
    case 1000070001:
        dump_html_pNext<const VkDeviceGroupDeviceCreateInfo>(static_cast<const VkDeviceGroupDeviceCreateInfo*>(object), settings, "VkDeviceGroupDeviceCreateInfo", indents, dump_html_VkDeviceGroupDeviceCreateInfo);
        break;
    case 1000145000:
        dump_html_pNext<const VkProtectedSubmitInfo>(static_cast<const VkProtectedSubmitInfo*>(object), settings, "VkProtectedSubmitInfo", indents, dump_html_VkProtectedSubmitInfo);
        break;
    case 1000071004:
        dump_html_pNext<const VkPhysicalDeviceIDProperties>(static_cast<const VkPhysicalDeviceIDProperties*>(object), settings, "VkPhysicalDeviceIDProperties", indents, dump_html_VkPhysicalDeviceIDProperties);
        break;
    case 1000072001:
        dump_html_pNext<const VkExternalMemoryImageCreateInfo>(static_cast<const VkExternalMemoryImageCreateInfo*>(object), settings, "VkExternalMemoryImageCreateInfo", indents, dump_html_VkExternalMemoryImageCreateInfo);
        break;
    case 1000161000:
        dump_html_pNext<const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT>(static_cast<const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT*>(object), settings, "VkDescriptorSetLayoutBindingFlagsCreateInfoEXT", indents, dump_html_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT);
        break;
    case 1000161001:
        dump_html_pNext<const VkPhysicalDeviceDescriptorIndexingFeaturesEXT>(static_cast<const VkPhysicalDeviceDescriptorIndexingFeaturesEXT*>(object), settings, "VkPhysicalDeviceDescriptorIndexingFeaturesEXT", indents, dump_html_VkPhysicalDeviceDescriptorIndexingFeaturesEXT);
        break;
    case 1000011000:
        dump_html_pNext<const VkDebugReportCallbackCreateInfoEXT>(static_cast<const VkDebugReportCallbackCreateInfoEXT*>(object), settings, "VkDebugReportCallbackCreateInfoEXT", indents, dump_html_VkDebugReportCallbackCreateInfoEXT);
        break;
    case 1000161004:
        dump_html_pNext<const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT>(static_cast<const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT*>(object), settings, "VkDescriptorSetVariableDescriptorCountLayoutSupportEXT", indents, dump_html_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT);
        break;
    case 1000072000:
        dump_html_pNext<const VkExternalMemoryBufferCreateInfo>(static_cast<const VkExternalMemoryBufferCreateInfo*>(object), settings, "VkExternalMemoryBufferCreateInfo", indents, dump_html_VkExternalMemoryBufferCreateInfo);
        break;
    case 1000161002:
        dump_html_pNext<const VkPhysicalDeviceDescriptorIndexingPropertiesEXT>(static_cast<const VkPhysicalDeviceDescriptorIndexingPropertiesEXT*>(object), settings, "VkPhysicalDeviceDescriptorIndexingPropertiesEXT", indents, dump_html_VkPhysicalDeviceDescriptorIndexingPropertiesEXT);
        break;
    case 1000072002:
        dump_html_pNext<const VkExportMemoryAllocateInfo>(static_cast<const VkExportMemoryAllocateInfo*>(object), settings, "VkExportMemoryAllocateInfo", indents, dump_html_VkExportMemoryAllocateInfo);
        break;
    case 1000164000:
        dump_html_pNext<const VkPipelineViewportShadingRateImageStateCreateInfoNV>(static_cast<const VkPipelineViewportShadingRateImageStateCreateInfoNV*>(object), settings, "VkPipelineViewportShadingRateImageStateCreateInfoNV", indents, dump_html_VkPipelineViewportShadingRateImageStateCreateInfoNV);
        break;
    case 1000164002:
        dump_html_pNext<const VkPhysicalDeviceShadingRateImagePropertiesNV>(static_cast<const VkPhysicalDeviceShadingRateImagePropertiesNV*>(object), settings, "VkPhysicalDeviceShadingRateImagePropertiesNV", indents, dump_html_VkPhysicalDeviceShadingRateImagePropertiesNV);
        break;
    case 1000164001:
        dump_html_pNext<const VkPhysicalDeviceShadingRateImageFeaturesNV>(static_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(object), settings, "VkPhysicalDeviceShadingRateImageFeaturesNV", indents, dump_html_VkPhysicalDeviceShadingRateImageFeaturesNV);
        break;
    case 1000071000:
        dump_html_pNext<const VkPhysicalDeviceExternalImageFormatInfo>(static_cast<const VkPhysicalDeviceExternalImageFormatInfo*>(object), settings, "VkPhysicalDeviceExternalImageFormatInfo", indents, dump_html_VkPhysicalDeviceExternalImageFormatInfo);
        break;
    case 1000165007:
        dump_html_pNext<const VkWriteDescriptorSetAccelerationStructureNV>(static_cast<const VkWriteDescriptorSetAccelerationStructureNV*>(object), settings, "VkWriteDescriptorSetAccelerationStructureNV", indents, dump_html_VkWriteDescriptorSetAccelerationStructureNV);
        break;
    case 1000161003:
        dump_html_pNext<const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT>(static_cast<const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT*>(object), settings, "VkDescriptorSetVariableDescriptorCountAllocateInfoEXT", indents, dump_html_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT);
        break;
    case 1000071001:
        dump_html_pNext<const VkExternalImageFormatProperties>(static_cast<const VkExternalImageFormatProperties*>(object), settings, "VkExternalImageFormatProperties", indents, dump_html_VkExternalImageFormatProperties);
        break;
    case 1000207001:
        dump_html_pNext<const VkPhysicalDeviceTimelineSemaphorePropertiesKHR>(static_cast<const VkPhysicalDeviceTimelineSemaphorePropertiesKHR*>(object), settings, "VkPhysicalDeviceTimelineSemaphorePropertiesKHR", indents, dump_html_VkPhysicalDeviceTimelineSemaphorePropertiesKHR);
        break;
    case 1000207000:
        dump_html_pNext<const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR>(static_cast<const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR*>(object), settings, "VkPhysicalDeviceTimelineSemaphoreFeaturesKHR", indents, dump_html_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR);
        break;
    case 1000199001:
        dump_html_pNext<const VkSubpassDescriptionDepthStencilResolveKHR>(static_cast<const VkSubpassDescriptionDepthStencilResolveKHR*>(object), settings, "VkSubpassDescriptionDepthStencilResolveKHR", indents, dump_html_VkSubpassDescriptionDepthStencilResolveKHR);
        break;
#if defined(VK_USE_PLATFORM_VI_NN)
#endif // VK_USE_PLATFORM_VI_NN
    case 1000207003:
        dump_html_pNext<const VkTimelineSemaphoreSubmitInfoKHR>(static_cast<const VkTimelineSemaphoreSubmitInfoKHR*>(object), settings, "VkTimelineSemaphoreSubmitInfoKHR", indents, dump_html_VkTimelineSemaphoreSubmitInfoKHR);
        break;
#if defined(VK_USE_PLATFORM_XCB_KHR)
#endif // VK_USE_PLATFORM_XCB_KHR
    case 1000199000:
        dump_html_pNext<const VkPhysicalDeviceDepthStencilResolvePropertiesKHR>(static_cast<const VkPhysicalDeviceDepthStencilResolvePropertiesKHR*>(object), settings, "VkPhysicalDeviceDepthStencilResolvePropertiesKHR", indents, dump_html_VkPhysicalDeviceDepthStencilResolvePropertiesKHR);
        break;
    case 1000207002:
        dump_html_pNext<const VkSemaphoreTypeCreateInfoKHR>(static_cast<const VkSemaphoreTypeCreateInfoKHR*>(object), settings, "VkSemaphoreTypeCreateInfoKHR", indents, dump_html_VkSemaphoreTypeCreateInfoKHR);
        break;
    case 1000066000:
        dump_html_pNext<const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT>(static_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT*>(object), settings, "VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT", indents, dump_html_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT);
        break;
    case 1000156001:
        dump_html_pNext<const VkSamplerYcbcrConversionInfo>(static_cast<const VkSamplerYcbcrConversionInfo*>(object), settings, "VkSamplerYcbcrConversionInfo", indents, dump_html_VkSamplerYcbcrConversionInfo);
        break;
    case 1000067000:
        dump_html_pNext<const VkImageViewASTCDecodeModeEXT>(static_cast<const VkImageViewASTCDecodeModeEXT*>(object), settings, "VkImageViewASTCDecodeModeEXT", indents, dump_html_VkImageViewASTCDecodeModeEXT);
        break;
    case 1000202001:
        dump_html_pNext<const VkPhysicalDeviceMeshShaderPropertiesNV>(static_cast<const VkPhysicalDeviceMeshShaderPropertiesNV*>(object), settings, "VkPhysicalDeviceMeshShaderPropertiesNV", indents, dump_html_VkPhysicalDeviceMeshShaderPropertiesNV);
        break;
    case 1000067001:
        dump_html_pNext<const VkPhysicalDeviceASTCDecodeFeaturesEXT>(static_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(object), settings, "VkPhysicalDeviceASTCDecodeFeaturesEXT", indents, dump_html_VkPhysicalDeviceASTCDecodeFeaturesEXT);
        break;
    case 1000087000:
        dump_html_pNext<const VkPipelineViewportWScalingStateCreateInfoNV>(static_cast<const VkPipelineViewportWScalingStateCreateInfoNV*>(object), settings, "VkPipelineViewportWScalingStateCreateInfoNV", indents, dump_html_VkPipelineViewportWScalingStateCreateInfoNV);
        break;
    case 1000156002:
        dump_html_pNext<const VkBindImagePlaneMemoryInfo>(static_cast<const VkBindImagePlaneMemoryInfo*>(object), settings, "VkBindImagePlaneMemoryInfo", indents, dump_html_VkBindImagePlaneMemoryInfo);
        break;
    case 1000201000:
        dump_html_pNext<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>(static_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV*>(object), settings, "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV", indents, dump_html_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV);
        break;
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
#endif // VK_USE_PLATFORM_WAYLAND_KHR
    case 1000156003:
        dump_html_pNext<const VkImagePlaneMemoryRequirementsInfo>(static_cast<const VkImagePlaneMemoryRequirementsInfo*>(object), settings, "VkImagePlaneMemoryRequirementsInfo", indents, dump_html_VkImagePlaneMemoryRequirementsInfo);
        break;
    case 1000202000:
        dump_html_pNext<const VkPhysicalDeviceMeshShaderFeaturesNV>(static_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(object), settings, "VkPhysicalDeviceMeshShaderFeaturesNV", indents, dump_html_VkPhysicalDeviceMeshShaderFeaturesNV);
        break;
    case 1000156004:
        dump_html_pNext<const VkPhysicalDeviceSamplerYcbcrConversionFeatures>(static_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(object), settings, "VkPhysicalDeviceSamplerYcbcrConversionFeatures", indents, dump_html_VkPhysicalDeviceSamplerYcbcrConversionFeatures);
        break;
#if defined(VK_USE_PLATFORM_WIN32_KHR)
    case 1000073000:
        dump_html_pNext<const VkImportMemoryWin32HandleInfoKHR>(static_cast<const VkImportMemoryWin32HandleInfoKHR*>(object), settings, "VkImportMemoryWin32HandleInfoKHR", indents, dump_html_VkImportMemoryWin32HandleInfoKHR);
        break;
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
#endif // VK_USE_PLATFORM_ANDROID_KHR
    case 1000156005:
        dump_html_pNext<const VkSamplerYcbcrConversionImageFormatProperties>(static_cast<const VkSamplerYcbcrConversionImageFormatProperties*>(object), settings, "VkSamplerYcbcrConversionImageFormatProperties", indents, dump_html_VkSamplerYcbcrConversionImageFormatProperties);
        break;
    case 1000209000:
        dump_html_pNext<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>(static_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(object), settings, "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL", indents, dump_html_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL);
        break;
    case 1000094000:
        dump_html_pNext<const VkPhysicalDeviceSubgroupProperties>(static_cast<const VkPhysicalDeviceSubgroupProperties*>(object), settings, "VkPhysicalDeviceSubgroupProperties", indents, dump_html_VkPhysicalDeviceSubgroupProperties);
        break;
    case 1000061000:
        dump_html_pNext<const VkValidationFlagsEXT>(static_cast<const VkValidationFlagsEXT*>(object), settings, "VkValidationFlagsEXT", indents, dump_html_VkValidationFlagsEXT);
        break;

    case 47: // VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO
    case 48: // VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO
        if(static_cast<const VkBaseInStructure*>(object)->pNext != nullptr){
            dump_html_pNext_trampoline(static_cast<const void*>(static_cast<const VkBaseInStructure*>(object)->pNext), settings, indents);
        } else {
            settings.stream() << "<details class='data'><summary>";
            dump_html_nametype(settings.stream(), settings.showType(), "pNext", "const void*");
            settings.stream() << "<div class='val'> NULL</div></summary></details>";
        }
        break;
    default:
        settings.stream() << "<details class='data'><summary>";
        dump_html_nametype(settings.stream(), settings.showType(), "pNext", "const void*");
        settings.stream() << "<div class='val'>UNKNOWN (" << (int64_t) (static_cast<const VkBaseInStructure*>(object)->sType) <<")</div></summary></details>";
    }
    return settings.stream(); 
}

inline std::ostream& dump_html_pNext_trampoline(const void* object, const ApiDumpSettings& settings, int indents, bool is_dynamic_viewport, bool is_dynamic_scissor)
{
    dump_html_pNext<const VkPipelineViewportStateCreateInfo>(static_cast<const VkPipelineViewportStateCreateInfo*>(object), settings, "VkPipelineViewportStateCreateInfo", indents, dump_html_VkPipelineViewportStateCreateInfo, is_dynamic_viewport, is_dynamic_scissor);
    return settings.stream(); 
}

inline std::ostream& dump_html_pNext_trampoline(const void* object, const ApiDumpSettings& settings, int indents, VkCommandBuffer cmd_buffer)
{
    dump_html_pNext<const VkCommandBufferBeginInfo>(static_cast<const VkCommandBufferBeginInfo*>(object), settings, "VkCommandBufferBeginInfo", indents, dump_html_VkCommandBufferBeginInfo, cmd_buffer);
    return settings.stream(); 
}

//=========================== Type Implementations ==========================//

inline std::ostream& dump_html_uint16_t(uint16_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_uint64_t(uint64_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_uint32_t(uint32_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_size_t(size_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_int64_t(int64_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_char(char object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_double(double object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_float(float object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_int32_t(int32_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << object;
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_uint8_t(uint8_t object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    settings.stream() << (uint32_t) object;
    return settings.stream() << "</div></summary>";
}

//========================= Basetype Implementations ========================//

inline std::ostream& dump_html_VkDeviceSize(VkDeviceSize object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
inline std::ostream& dump_html_VkDeviceAddress(VkDeviceAddress object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
inline std::ostream& dump_html_VkFlags(VkFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
inline std::ostream& dump_html_VkSampleMask(VkSampleMask object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
inline std::ostream& dump_html_VkBool32(VkBool32 object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}

//======================= System Type Implementations =======================//

#if defined(VK_USE_PLATFORM_XCB_KHR)
inline std::ostream& dump_html_xcb_window_t(const xcb_window_t object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
inline std::ostream& dump_html_wl_display(const wl_display object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_XLIB_KHR)
inline std::ostream& dump_html_Window(const Window object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline std::ostream& dump_html_HWND(const HWND object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_GGP)
inline std::ostream& dump_html_GgpFrameToken(const GgpFrameToken object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_GGP
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline std::ostream& dump_html_SECURITY_ATTRIBUTES(const SECURITY_ATTRIBUTES* object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline std::ostream& dump_html_HINSTANCE(const HINSTANCE object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_XLIB_KHR)
inline std::ostream& dump_html_VisualID(const VisualID object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline std::ostream& dump_html_LPCWSTR(const LPCWSTR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline std::ostream& dump_html_HMONITOR(const HMONITOR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
inline std::ostream& dump_html_xcb_connection_t(const xcb_connection_t* object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline std::ostream& dump_html_DWORD(const DWORD object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_XLIB_KHR)
inline std::ostream& dump_html_Display(const Display* object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
#if defined(VK_USE_PLATFORM_GGP)
inline std::ostream& dump_html_GgpStreamDescriptor(const GgpStreamDescriptor object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_GGP
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
inline std::ostream& dump_html_wl_surface(const wl_surface object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
inline std::ostream& dump_html_ANativeWindow(const ANativeWindow* object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_FUCHSIA)
inline std::ostream& dump_html_zx_handle_t(const zx_handle_t object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline std::ostream& dump_html_HANDLE(const HANDLE object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_XCB_KHR)
inline std::ostream& dump_html_xcb_visualid_t(const xcb_visualid_t object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
inline std::ostream& dump_html_AHardwareBuffer(const AHardwareBuffer* object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>" << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR

//========================== Handle Implementations =========================//

inline std::ostream& dump_html_VkDescriptorPool(const VkDescriptorPool object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkPipeline(const VkPipeline object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkInstance(const VkInstance object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkRenderPass(const VkRenderPass object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDebugReportCallbackEXT(const VkDebugReportCallbackEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDebugUtilsMessengerEXT(const VkDebugUtilsMessengerEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkImage(const VkImage object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkSurfaceKHR(const VkSurfaceKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkSamplerYcbcrConversion(const VkSamplerYcbcrConversion object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkSwapchainKHR(const VkSwapchainKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkFramebuffer(const VkFramebuffer object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDisplayModeKHR(const VkDisplayModeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkCommandPool(const VkCommandPool object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkObjectTableNVX(const VkObjectTableNVX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkShaderModule(const VkShaderModule object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkAccelerationStructureNV(const VkAccelerationStructureNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkQueryPool(const VkQueryPool object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkValidationCacheEXT(const VkValidationCacheEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineLayout(const VkPipelineLayout object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDisplayKHR(const VkDisplayKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkPerformanceConfigurationINTEL(const VkPerformanceConfigurationINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkIndirectCommandsLayoutNVX(const VkIndirectCommandsLayoutNVX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkImageView(const VkImageView object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDescriptorSetLayout(const VkDescriptorSetLayout object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDeviceMemory(const VkDeviceMemory object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkPhysicalDevice(const VkPhysicalDevice object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkSampler(const VkSampler object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkBufferView(const VkBufferView object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDescriptorSet(const VkDescriptorSet object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkCommandBuffer(const VkCommandBuffer object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkQueue(const VkQueue object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkFence(const VkFence object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineCache(const VkPipelineCache object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDevice(const VkDevice object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkDescriptorUpdateTemplate(const VkDescriptorUpdateTemplate object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkSemaphore(const VkSemaphore object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkEvent(const VkEvent object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_VkBuffer(const VkBuffer object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress()) {
        settings.stream() << object;

        std::unordered_map<uint64_t, std::string>::const_iterator it = ApiDumpInstance::current().object_name_map.find((uint64_t) object);
        if (it != ApiDumpInstance::current().object_name_map.end()) {
            settings.stream() << "</div><div class='val'>[" << it->second << "]";
        }
    } else {
        settings.stream() << "address";
    }
    return settings.stream() << "</div></summary>";
}

//=========================== Enum Implementations ==========================//

std::ostream& dump_html_VkSharingMode(VkSharingMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHARING_MODE_EXCLUSIVE (";
        break;
    case 1:
        settings.stream() << "VK_SHARING_MODE_CONCURRENT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkAttachmentLoadOp(VkAttachmentLoadOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ATTACHMENT_LOAD_OP_LOAD (";
        break;
    case 1:
        settings.stream() << "VK_ATTACHMENT_LOAD_OP_CLEAR (";
        break;
    case 2:
        settings.stream() << "VK_ATTACHMENT_LOAD_OP_DONT_CARE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDescriptorUpdateTemplateType(VkDescriptorUpdateTemplateType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET (";
        break;
    case 1:
        settings.stream() << "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkAttachmentStoreOp(VkAttachmentStoreOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ATTACHMENT_STORE_OP_STORE (";
        break;
    case 1:
        settings.stream() << "VK_ATTACHMENT_STORE_OP_DONT_CARE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDebugReportObjectTypeEXT(VkDebugReportObjectTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT (";
        break;
    case 2:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT (";
        break;
    case 3:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT (";
        break;
    case 4:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT (";
        break;
    case 5:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT (";
        break;
    case 6:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT (";
        break;
    case 7:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT (";
        break;
    case 8:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT (";
        break;
    case 9:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT (";
        break;
    case 10:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT (";
        break;
    case 11:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT (";
        break;
    case 12:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT (";
        break;
    case 13:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT (";
        break;
    case 14:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT (";
        break;
    case 15:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT (";
        break;
    case 16:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT (";
        break;
    case 17:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT (";
        break;
    case 18:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT (";
        break;
    case 19:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT (";
        break;
    case 20:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT (";
        break;
    case 21:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT (";
        break;
    case 22:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT (";
        break;
    case 23:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT (";
        break;
    case 24:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT (";
        break;
    case 25:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT (";
        break;
    case 26:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT (";
        break;
    case 27:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT (";
        break;
    case 28:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT (";
        break;
    case 29:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT (";
        break;
    case 30:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT (";
        break;
    case 31:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT (";
        break;
    case 32:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT (";
        break;
    case 33:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT (";
        break;
    case 1000156000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT (";
        break;
    case 1000085000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT (";
        break;
    case 1000165000:
        settings.stream() << "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkCoarseSampleOrderTypeNV(VkCoarseSampleOrderTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV (";
        break;
    case 1:
        settings.stream() << "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV (";
        break;
    case 2:
        settings.stream() << "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV (";
        break;
    case 3:
        settings.stream() << "VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkShaderFloatControlsIndependenceKHR(VkShaderFloatControlsIndependenceKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY_KHR (";
        break;
    case 1:
        settings.stream() << "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL_KHR (";
        break;
    case 2:
        settings.stream() << "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkTimeDomainEXT(VkTimeDomainEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_TIME_DOMAIN_DEVICE_EXT (";
        break;
    case 1:
        settings.stream() << "VK_TIME_DOMAIN_CLOCK_MONOTONIC_EXT (";
        break;
    case 2:
        settings.stream() << "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_EXT (";
        break;
    case 3:
        settings.stream() << "VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkValidationFeatureEnableEXT(VkValidationFeatureEnableEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT (";
        break;
    case 1:
        settings.stream() << "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT (";
        break;
    case 2:
        settings.stream() << "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkCoverageReductionModeNV(VkCoverageReductionModeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COVERAGE_REDUCTION_MODE_MERGE_NV (";
        break;
    case 1:
        settings.stream() << "VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkValidationFeatureDisableEXT(VkValidationFeatureDisableEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_ALL_EXT (";
        break;
    case 1:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT (";
        break;
    case 2:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT (";
        break;
    case 3:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT (";
        break;
    case 4:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT (";
        break;
    case 5:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT (";
        break;
    case 6:
        settings.stream() << "VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkShaderInfoTypeAMD(VkShaderInfoTypeAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHADER_INFO_TYPE_STATISTICS_AMD (";
        break;
    case 1:
        settings.stream() << "VK_SHADER_INFO_TYPE_BINARY_AMD (";
        break;
    case 2:
        settings.stream() << "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkQueueGlobalPriorityEXT(VkQueueGlobalPriorityEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 128:
        settings.stream() << "VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT (";
        break;
    case 256:
        settings.stream() << "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT (";
        break;
    case 512:
        settings.stream() << "VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT (";
        break;
    case 1024:
        settings.stream() << "VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkGeometryTypeNV(VkGeometryTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_GEOMETRY_TYPE_TRIANGLES_NV (";
        break;
    case 1:
        settings.stream() << "VK_GEOMETRY_TYPE_AABBS_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPipelineBindPoint(VkPipelineBindPoint object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PIPELINE_BIND_POINT_GRAPHICS (";
        break;
    case 1:
        settings.stream() << "VK_PIPELINE_BIND_POINT_COMPUTE (";
        break;
    case 1000165000:
        settings.stream() << "VK_PIPELINE_BIND_POINT_RAY_TRACING_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkSystemAllocationScope(VkSystemAllocationScope object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND (";
        break;
    case 1:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT (";
        break;
    case 2:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_CACHE (";
        break;
    case 3:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE (";
        break;
    case 4:
        settings.stream() << "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkShadingRatePaletteEntryNV(VkShadingRatePaletteEntryNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV (";
        break;
    case 1:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 2:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 3:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 4:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV (";
        break;
    case 5:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV (";
        break;
    case 6:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV (";
        break;
    case 7:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV (";
        break;
    case 8:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV (";
        break;
    case 9:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV (";
        break;
    case 10:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV (";
        break;
    case 11:
        settings.stream() << "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkAccelerationStructureTypeNV(VkAccelerationStructureTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV (";
        break;
    case 1:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkScopeNV(VkScopeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_SCOPE_DEVICE_NV (";
        break;
    case 2:
        settings.stream() << "VK_SCOPE_WORKGROUP_NV (";
        break;
    case 3:
        settings.stream() << "VK_SCOPE_SUBGROUP_NV (";
        break;
    case 5:
        settings.stream() << "VK_SCOPE_QUEUE_FAMILY_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkCompareOp(VkCompareOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COMPARE_OP_NEVER (";
        break;
    case 1:
        settings.stream() << "VK_COMPARE_OP_LESS (";
        break;
    case 2:
        settings.stream() << "VK_COMPARE_OP_EQUAL (";
        break;
    case 3:
        settings.stream() << "VK_COMPARE_OP_LESS_OR_EQUAL (";
        break;
    case 4:
        settings.stream() << "VK_COMPARE_OP_GREATER (";
        break;
    case 5:
        settings.stream() << "VK_COMPARE_OP_NOT_EQUAL (";
        break;
    case 6:
        settings.stream() << "VK_COMPARE_OP_GREATER_OR_EQUAL (";
        break;
    case 7:
        settings.stream() << "VK_COMPARE_OP_ALWAYS (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkViewportCoordinateSwizzleNV(VkViewportCoordinateSwizzleNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV (";
        break;
    case 1:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV (";
        break;
    case 2:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV (";
        break;
    case 3:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV (";
        break;
    case 4:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV (";
        break;
    case 5:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV (";
        break;
    case 6:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV (";
        break;
    case 7:
        settings.stream() << "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkComponentTypeNV(VkComponentTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COMPONENT_TYPE_FLOAT16_NV (";
        break;
    case 1:
        settings.stream() << "VK_COMPONENT_TYPE_FLOAT32_NV (";
        break;
    case 2:
        settings.stream() << "VK_COMPONENT_TYPE_FLOAT64_NV (";
        break;
    case 3:
        settings.stream() << "VK_COMPONENT_TYPE_SINT8_NV (";
        break;
    case 4:
        settings.stream() << "VK_COMPONENT_TYPE_SINT16_NV (";
        break;
    case 5:
        settings.stream() << "VK_COMPONENT_TYPE_SINT32_NV (";
        break;
    case 6:
        settings.stream() << "VK_COMPONENT_TYPE_SINT64_NV (";
        break;
    case 7:
        settings.stream() << "VK_COMPONENT_TYPE_UINT8_NV (";
        break;
    case 8:
        settings.stream() << "VK_COMPONENT_TYPE_UINT16_NV (";
        break;
    case 9:
        settings.stream() << "VK_COMPONENT_TYPE_UINT32_NV (";
        break;
    case 10:
        settings.stream() << "VK_COMPONENT_TYPE_UINT64_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkIndexType(VkIndexType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_INDEX_TYPE_UINT16 (";
        break;
    case 1:
        settings.stream() << "VK_INDEX_TYPE_UINT32 (";
        break;
    case 1000165000:
        settings.stream() << "VK_INDEX_TYPE_NONE_NV (";
        break;
    case 1000265000:
        settings.stream() << "VK_INDEX_TYPE_UINT8_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkRayTracingShaderGroupTypeNV(VkRayTracingShaderGroupTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_NV (";
        break;
    case 1:
        settings.stream() << "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_NV (";
        break;
    case 2:
        settings.stream() << "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkInternalAllocationType(VkInternalAllocationType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkImageLayout(VkImageLayout object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_IMAGE_LAYOUT_UNDEFINED (";
        break;
    case 1:
        settings.stream() << "VK_IMAGE_LAYOUT_GENERAL (";
        break;
    case 2:
        settings.stream() << "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL (";
        break;
    case 3:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL (";
        break;
    case 4:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL (";
        break;
    case 5:
        settings.stream() << "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL (";
        break;
    case 6:
        settings.stream() << "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL (";
        break;
    case 7:
        settings.stream() << "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL (";
        break;
    case 8:
        settings.stream() << "VK_IMAGE_LAYOUT_PREINITIALIZED (";
        break;
    case 1000117000:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL (";
        break;
    case 1000117001:
        settings.stream() << "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL (";
        break;
    case 1000001002:
        settings.stream() << "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR (";
        break;
    case 1000111000:
        settings.stream() << "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR (";
        break;
    case 1000164003:
        settings.stream() << "VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV (";
        break;
    case 1000218000:
        settings.stream() << "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkImageTiling(VkImageTiling object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_IMAGE_TILING_OPTIMAL (";
        break;
    case 1:
        settings.stream() << "VK_IMAGE_TILING_LINEAR (";
        break;
    case 1000158000:
        settings.stream() << "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkVertexInputRate(VkVertexInputRate object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VERTEX_INPUT_RATE_VERTEX (";
        break;
    case 1:
        settings.stream() << "VK_VERTEX_INPUT_RATE_INSTANCE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkStencilOp(VkStencilOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_STENCIL_OP_KEEP (";
        break;
    case 1:
        settings.stream() << "VK_STENCIL_OP_ZERO (";
        break;
    case 2:
        settings.stream() << "VK_STENCIL_OP_REPLACE (";
        break;
    case 3:
        settings.stream() << "VK_STENCIL_OP_INCREMENT_AND_CLAMP (";
        break;
    case 4:
        settings.stream() << "VK_STENCIL_OP_DECREMENT_AND_CLAMP (";
        break;
    case 5:
        settings.stream() << "VK_STENCIL_OP_INVERT (";
        break;
    case 6:
        settings.stream() << "VK_STENCIL_OP_INCREMENT_AND_WRAP (";
        break;
    case 7:
        settings.stream() << "VK_STENCIL_OP_DECREMENT_AND_WRAP (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkRasterizationOrderAMD(VkRasterizationOrderAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_RASTERIZATION_ORDER_STRICT_AMD (";
        break;
    case 1:
        settings.stream() << "VK_RASTERIZATION_ORDER_RELAXED_AMD (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPipelineExecutableStatisticFormatKHR(VkPipelineExecutableStatisticFormatKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR (";
        break;
    case 1:
        settings.stream() << "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR (";
        break;
    case 2:
        settings.stream() << "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR (";
        break;
    case 3:
        settings.stream() << "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkImageType(VkImageType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_IMAGE_TYPE_1D (";
        break;
    case 1:
        settings.stream() << "VK_IMAGE_TYPE_2D (";
        break;
    case 2:
        settings.stream() << "VK_IMAGE_TYPE_3D (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPhysicalDeviceType(VkPhysicalDeviceType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_OTHER (";
        break;
    case 1:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU (";
        break;
    case 2:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU (";
        break;
    case 3:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU (";
        break;
    case 4:
        settings.stream() << "VK_PHYSICAL_DEVICE_TYPE_CPU (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkColorSpaceKHR(VkColorSpaceKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR (";
        break;
    case 1000104001:
        settings.stream() << "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT (";
        break;
    case 1000104002:
        settings.stream() << "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT (";
        break;
    case 1000104003:
        settings.stream() << "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT (";
        break;
    case 1000104004:
        settings.stream() << "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT (";
        break;
    case 1000104005:
        settings.stream() << "VK_COLOR_SPACE_BT709_LINEAR_EXT (";
        break;
    case 1000104006:
        settings.stream() << "VK_COLOR_SPACE_BT709_NONLINEAR_EXT (";
        break;
    case 1000104007:
        settings.stream() << "VK_COLOR_SPACE_BT2020_LINEAR_EXT (";
        break;
    case 1000104008:
        settings.stream() << "VK_COLOR_SPACE_HDR10_ST2084_EXT (";
        break;
    case 1000104009:
        settings.stream() << "VK_COLOR_SPACE_DOLBYVISION_EXT (";
        break;
    case 1000104010:
        settings.stream() << "VK_COLOR_SPACE_HDR10_HLG_EXT (";
        break;
    case 1000104011:
        settings.stream() << "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT (";
        break;
    case 1000104012:
        settings.stream() << "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT (";
        break;
    case 1000104013:
        settings.stream() << "VK_COLOR_SPACE_PASS_THROUGH_EXT (";
        break;
    case 1000104014:
        settings.stream() << "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT (";
        break;
    case 1000213000:
        settings.stream() << "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkLineRasterizationModeEXT(VkLineRasterizationModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_LINE_RASTERIZATION_MODE_DEFAULT_EXT (";
        break;
    case 1:
        settings.stream() << "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_EXT (";
        break;
    case 2:
        settings.stream() << "VK_LINE_RASTERIZATION_MODE_BRESENHAM_EXT (";
        break;
    case 3:
        settings.stream() << "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkFullScreenExclusiveEXT(VkFullScreenExclusiveEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT (";
        break;
    case 1:
        settings.stream() << "VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT (";
        break;
    case 2:
        settings.stream() << "VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT (";
        break;
    case 3:
        settings.stream() << "VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkPrimitiveTopology(VkPrimitiveTopology object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_POINT_LIST (";
        break;
    case 1:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_LINE_LIST (";
        break;
    case 2:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP (";
        break;
    case 3:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST (";
        break;
    case 4:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP (";
        break;
    case 5:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN (";
        break;
    case 6:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY (";
        break;
    case 7:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY (";
        break;
    case 8:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY (";
        break;
    case 9:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY (";
        break;
    case 10:
        settings.stream() << "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPresentModeKHR(VkPresentModeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PRESENT_MODE_IMMEDIATE_KHR (";
        break;
    case 1:
        settings.stream() << "VK_PRESENT_MODE_MAILBOX_KHR (";
        break;
    case 2:
        settings.stream() << "VK_PRESENT_MODE_FIFO_KHR (";
        break;
    case 3:
        settings.stream() << "VK_PRESENT_MODE_FIFO_RELAXED_KHR (";
        break;
    case 1000111000:
        settings.stream() << "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR (";
        break;
    case 1000111001:
        settings.stream() << "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkCopyAccelerationStructureModeNV(VkCopyAccelerationStructureModeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_NV (";
        break;
    case 1:
        settings.stream() << "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkMemoryOverallocationBehaviorAMD(VkMemoryOverallocationBehaviorAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD (";
        break;
    case 1:
        settings.stream() << "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD (";
        break;
    case 2:
        settings.stream() << "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPointClippingBehavior(VkPointClippingBehavior object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES (";
        break;
    case 1:
        settings.stream() << "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkCommandBufferLevel(VkCommandBufferLevel object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COMMAND_BUFFER_LEVEL_PRIMARY (";
        break;
    case 1:
        settings.stream() << "VK_COMMAND_BUFFER_LEVEL_SECONDARY (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkFormat(VkFormat object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FORMAT_UNDEFINED (";
        break;
    case 1:
        settings.stream() << "VK_FORMAT_R4G4_UNORM_PACK8 (";
        break;
    case 2:
        settings.stream() << "VK_FORMAT_R4G4B4A4_UNORM_PACK16 (";
        break;
    case 3:
        settings.stream() << "VK_FORMAT_B4G4R4A4_UNORM_PACK16 (";
        break;
    case 4:
        settings.stream() << "VK_FORMAT_R5G6B5_UNORM_PACK16 (";
        break;
    case 5:
        settings.stream() << "VK_FORMAT_B5G6R5_UNORM_PACK16 (";
        break;
    case 6:
        settings.stream() << "VK_FORMAT_R5G5B5A1_UNORM_PACK16 (";
        break;
    case 7:
        settings.stream() << "VK_FORMAT_B5G5R5A1_UNORM_PACK16 (";
        break;
    case 8:
        settings.stream() << "VK_FORMAT_A1R5G5B5_UNORM_PACK16 (";
        break;
    case 9:
        settings.stream() << "VK_FORMAT_R8_UNORM (";
        break;
    case 10:
        settings.stream() << "VK_FORMAT_R8_SNORM (";
        break;
    case 11:
        settings.stream() << "VK_FORMAT_R8_USCALED (";
        break;
    case 12:
        settings.stream() << "VK_FORMAT_R8_SSCALED (";
        break;
    case 13:
        settings.stream() << "VK_FORMAT_R8_UINT (";
        break;
    case 14:
        settings.stream() << "VK_FORMAT_R8_SINT (";
        break;
    case 15:
        settings.stream() << "VK_FORMAT_R8_SRGB (";
        break;
    case 16:
        settings.stream() << "VK_FORMAT_R8G8_UNORM (";
        break;
    case 17:
        settings.stream() << "VK_FORMAT_R8G8_SNORM (";
        break;
    case 18:
        settings.stream() << "VK_FORMAT_R8G8_USCALED (";
        break;
    case 19:
        settings.stream() << "VK_FORMAT_R8G8_SSCALED (";
        break;
    case 20:
        settings.stream() << "VK_FORMAT_R8G8_UINT (";
        break;
    case 21:
        settings.stream() << "VK_FORMAT_R8G8_SINT (";
        break;
    case 22:
        settings.stream() << "VK_FORMAT_R8G8_SRGB (";
        break;
    case 23:
        settings.stream() << "VK_FORMAT_R8G8B8_UNORM (";
        break;
    case 24:
        settings.stream() << "VK_FORMAT_R8G8B8_SNORM (";
        break;
    case 25:
        settings.stream() << "VK_FORMAT_R8G8B8_USCALED (";
        break;
    case 26:
        settings.stream() << "VK_FORMAT_R8G8B8_SSCALED (";
        break;
    case 27:
        settings.stream() << "VK_FORMAT_R8G8B8_UINT (";
        break;
    case 28:
        settings.stream() << "VK_FORMAT_R8G8B8_SINT (";
        break;
    case 29:
        settings.stream() << "VK_FORMAT_R8G8B8_SRGB (";
        break;
    case 30:
        settings.stream() << "VK_FORMAT_B8G8R8_UNORM (";
        break;
    case 31:
        settings.stream() << "VK_FORMAT_B8G8R8_SNORM (";
        break;
    case 32:
        settings.stream() << "VK_FORMAT_B8G8R8_USCALED (";
        break;
    case 33:
        settings.stream() << "VK_FORMAT_B8G8R8_SSCALED (";
        break;
    case 34:
        settings.stream() << "VK_FORMAT_B8G8R8_UINT (";
        break;
    case 35:
        settings.stream() << "VK_FORMAT_B8G8R8_SINT (";
        break;
    case 36:
        settings.stream() << "VK_FORMAT_B8G8R8_SRGB (";
        break;
    case 37:
        settings.stream() << "VK_FORMAT_R8G8B8A8_UNORM (";
        break;
    case 38:
        settings.stream() << "VK_FORMAT_R8G8B8A8_SNORM (";
        break;
    case 39:
        settings.stream() << "VK_FORMAT_R8G8B8A8_USCALED (";
        break;
    case 40:
        settings.stream() << "VK_FORMAT_R8G8B8A8_SSCALED (";
        break;
    case 41:
        settings.stream() << "VK_FORMAT_R8G8B8A8_UINT (";
        break;
    case 42:
        settings.stream() << "VK_FORMAT_R8G8B8A8_SINT (";
        break;
    case 43:
        settings.stream() << "VK_FORMAT_R8G8B8A8_SRGB (";
        break;
    case 44:
        settings.stream() << "VK_FORMAT_B8G8R8A8_UNORM (";
        break;
    case 45:
        settings.stream() << "VK_FORMAT_B8G8R8A8_SNORM (";
        break;
    case 46:
        settings.stream() << "VK_FORMAT_B8G8R8A8_USCALED (";
        break;
    case 47:
        settings.stream() << "VK_FORMAT_B8G8R8A8_SSCALED (";
        break;
    case 48:
        settings.stream() << "VK_FORMAT_B8G8R8A8_UINT (";
        break;
    case 49:
        settings.stream() << "VK_FORMAT_B8G8R8A8_SINT (";
        break;
    case 50:
        settings.stream() << "VK_FORMAT_B8G8R8A8_SRGB (";
        break;
    case 51:
        settings.stream() << "VK_FORMAT_A8B8G8R8_UNORM_PACK32 (";
        break;
    case 52:
        settings.stream() << "VK_FORMAT_A8B8G8R8_SNORM_PACK32 (";
        break;
    case 53:
        settings.stream() << "VK_FORMAT_A8B8G8R8_USCALED_PACK32 (";
        break;
    case 54:
        settings.stream() << "VK_FORMAT_A8B8G8R8_SSCALED_PACK32 (";
        break;
    case 55:
        settings.stream() << "VK_FORMAT_A8B8G8R8_UINT_PACK32 (";
        break;
    case 56:
        settings.stream() << "VK_FORMAT_A8B8G8R8_SINT_PACK32 (";
        break;
    case 57:
        settings.stream() << "VK_FORMAT_A8B8G8R8_SRGB_PACK32 (";
        break;
    case 58:
        settings.stream() << "VK_FORMAT_A2R10G10B10_UNORM_PACK32 (";
        break;
    case 59:
        settings.stream() << "VK_FORMAT_A2R10G10B10_SNORM_PACK32 (";
        break;
    case 60:
        settings.stream() << "VK_FORMAT_A2R10G10B10_USCALED_PACK32 (";
        break;
    case 61:
        settings.stream() << "VK_FORMAT_A2R10G10B10_SSCALED_PACK32 (";
        break;
    case 62:
        settings.stream() << "VK_FORMAT_A2R10G10B10_UINT_PACK32 (";
        break;
    case 63:
        settings.stream() << "VK_FORMAT_A2R10G10B10_SINT_PACK32 (";
        break;
    case 64:
        settings.stream() << "VK_FORMAT_A2B10G10R10_UNORM_PACK32 (";
        break;
    case 65:
        settings.stream() << "VK_FORMAT_A2B10G10R10_SNORM_PACK32 (";
        break;
    case 66:
        settings.stream() << "VK_FORMAT_A2B10G10R10_USCALED_PACK32 (";
        break;
    case 67:
        settings.stream() << "VK_FORMAT_A2B10G10R10_SSCALED_PACK32 (";
        break;
    case 68:
        settings.stream() << "VK_FORMAT_A2B10G10R10_UINT_PACK32 (";
        break;
    case 69:
        settings.stream() << "VK_FORMAT_A2B10G10R10_SINT_PACK32 (";
        break;
    case 70:
        settings.stream() << "VK_FORMAT_R16_UNORM (";
        break;
    case 71:
        settings.stream() << "VK_FORMAT_R16_SNORM (";
        break;
    case 72:
        settings.stream() << "VK_FORMAT_R16_USCALED (";
        break;
    case 73:
        settings.stream() << "VK_FORMAT_R16_SSCALED (";
        break;
    case 74:
        settings.stream() << "VK_FORMAT_R16_UINT (";
        break;
    case 75:
        settings.stream() << "VK_FORMAT_R16_SINT (";
        break;
    case 76:
        settings.stream() << "VK_FORMAT_R16_SFLOAT (";
        break;
    case 77:
        settings.stream() << "VK_FORMAT_R16G16_UNORM (";
        break;
    case 78:
        settings.stream() << "VK_FORMAT_R16G16_SNORM (";
        break;
    case 79:
        settings.stream() << "VK_FORMAT_R16G16_USCALED (";
        break;
    case 80:
        settings.stream() << "VK_FORMAT_R16G16_SSCALED (";
        break;
    case 81:
        settings.stream() << "VK_FORMAT_R16G16_UINT (";
        break;
    case 82:
        settings.stream() << "VK_FORMAT_R16G16_SINT (";
        break;
    case 83:
        settings.stream() << "VK_FORMAT_R16G16_SFLOAT (";
        break;
    case 84:
        settings.stream() << "VK_FORMAT_R16G16B16_UNORM (";
        break;
    case 85:
        settings.stream() << "VK_FORMAT_R16G16B16_SNORM (";
        break;
    case 86:
        settings.stream() << "VK_FORMAT_R16G16B16_USCALED (";
        break;
    case 87:
        settings.stream() << "VK_FORMAT_R16G16B16_SSCALED (";
        break;
    case 88:
        settings.stream() << "VK_FORMAT_R16G16B16_UINT (";
        break;
    case 89:
        settings.stream() << "VK_FORMAT_R16G16B16_SINT (";
        break;
    case 90:
        settings.stream() << "VK_FORMAT_R16G16B16_SFLOAT (";
        break;
    case 91:
        settings.stream() << "VK_FORMAT_R16G16B16A16_UNORM (";
        break;
    case 92:
        settings.stream() << "VK_FORMAT_R16G16B16A16_SNORM (";
        break;
    case 93:
        settings.stream() << "VK_FORMAT_R16G16B16A16_USCALED (";
        break;
    case 94:
        settings.stream() << "VK_FORMAT_R16G16B16A16_SSCALED (";
        break;
    case 95:
        settings.stream() << "VK_FORMAT_R16G16B16A16_UINT (";
        break;
    case 96:
        settings.stream() << "VK_FORMAT_R16G16B16A16_SINT (";
        break;
    case 97:
        settings.stream() << "VK_FORMAT_R16G16B16A16_SFLOAT (";
        break;
    case 98:
        settings.stream() << "VK_FORMAT_R32_UINT (";
        break;
    case 99:
        settings.stream() << "VK_FORMAT_R32_SINT (";
        break;
    case 100:
        settings.stream() << "VK_FORMAT_R32_SFLOAT (";
        break;
    case 101:
        settings.stream() << "VK_FORMAT_R32G32_UINT (";
        break;
    case 102:
        settings.stream() << "VK_FORMAT_R32G32_SINT (";
        break;
    case 103:
        settings.stream() << "VK_FORMAT_R32G32_SFLOAT (";
        break;
    case 104:
        settings.stream() << "VK_FORMAT_R32G32B32_UINT (";
        break;
    case 105:
        settings.stream() << "VK_FORMAT_R32G32B32_SINT (";
        break;
    case 106:
        settings.stream() << "VK_FORMAT_R32G32B32_SFLOAT (";
        break;
    case 107:
        settings.stream() << "VK_FORMAT_R32G32B32A32_UINT (";
        break;
    case 108:
        settings.stream() << "VK_FORMAT_R32G32B32A32_SINT (";
        break;
    case 109:
        settings.stream() << "VK_FORMAT_R32G32B32A32_SFLOAT (";
        break;
    case 110:
        settings.stream() << "VK_FORMAT_R64_UINT (";
        break;
    case 111:
        settings.stream() << "VK_FORMAT_R64_SINT (";
        break;
    case 112:
        settings.stream() << "VK_FORMAT_R64_SFLOAT (";
        break;
    case 113:
        settings.stream() << "VK_FORMAT_R64G64_UINT (";
        break;
    case 114:
        settings.stream() << "VK_FORMAT_R64G64_SINT (";
        break;
    case 115:
        settings.stream() << "VK_FORMAT_R64G64_SFLOAT (";
        break;
    case 116:
        settings.stream() << "VK_FORMAT_R64G64B64_UINT (";
        break;
    case 117:
        settings.stream() << "VK_FORMAT_R64G64B64_SINT (";
        break;
    case 118:
        settings.stream() << "VK_FORMAT_R64G64B64_SFLOAT (";
        break;
    case 119:
        settings.stream() << "VK_FORMAT_R64G64B64A64_UINT (";
        break;
    case 120:
        settings.stream() << "VK_FORMAT_R64G64B64A64_SINT (";
        break;
    case 121:
        settings.stream() << "VK_FORMAT_R64G64B64A64_SFLOAT (";
        break;
    case 122:
        settings.stream() << "VK_FORMAT_B10G11R11_UFLOAT_PACK32 (";
        break;
    case 123:
        settings.stream() << "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 (";
        break;
    case 124:
        settings.stream() << "VK_FORMAT_D16_UNORM (";
        break;
    case 125:
        settings.stream() << "VK_FORMAT_X8_D24_UNORM_PACK32 (";
        break;
    case 126:
        settings.stream() << "VK_FORMAT_D32_SFLOAT (";
        break;
    case 127:
        settings.stream() << "VK_FORMAT_S8_UINT (";
        break;
    case 128:
        settings.stream() << "VK_FORMAT_D16_UNORM_S8_UINT (";
        break;
    case 129:
        settings.stream() << "VK_FORMAT_D24_UNORM_S8_UINT (";
        break;
    case 130:
        settings.stream() << "VK_FORMAT_D32_SFLOAT_S8_UINT (";
        break;
    case 131:
        settings.stream() << "VK_FORMAT_BC1_RGB_UNORM_BLOCK (";
        break;
    case 132:
        settings.stream() << "VK_FORMAT_BC1_RGB_SRGB_BLOCK (";
        break;
    case 133:
        settings.stream() << "VK_FORMAT_BC1_RGBA_UNORM_BLOCK (";
        break;
    case 134:
        settings.stream() << "VK_FORMAT_BC1_RGBA_SRGB_BLOCK (";
        break;
    case 135:
        settings.stream() << "VK_FORMAT_BC2_UNORM_BLOCK (";
        break;
    case 136:
        settings.stream() << "VK_FORMAT_BC2_SRGB_BLOCK (";
        break;
    case 137:
        settings.stream() << "VK_FORMAT_BC3_UNORM_BLOCK (";
        break;
    case 138:
        settings.stream() << "VK_FORMAT_BC3_SRGB_BLOCK (";
        break;
    case 139:
        settings.stream() << "VK_FORMAT_BC4_UNORM_BLOCK (";
        break;
    case 140:
        settings.stream() << "VK_FORMAT_BC4_SNORM_BLOCK (";
        break;
    case 141:
        settings.stream() << "VK_FORMAT_BC5_UNORM_BLOCK (";
        break;
    case 142:
        settings.stream() << "VK_FORMAT_BC5_SNORM_BLOCK (";
        break;
    case 143:
        settings.stream() << "VK_FORMAT_BC6H_UFLOAT_BLOCK (";
        break;
    case 144:
        settings.stream() << "VK_FORMAT_BC6H_SFLOAT_BLOCK (";
        break;
    case 145:
        settings.stream() << "VK_FORMAT_BC7_UNORM_BLOCK (";
        break;
    case 146:
        settings.stream() << "VK_FORMAT_BC7_SRGB_BLOCK (";
        break;
    case 147:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK (";
        break;
    case 148:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK (";
        break;
    case 149:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK (";
        break;
    case 150:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK (";
        break;
    case 151:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK (";
        break;
    case 152:
        settings.stream() << "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK (";
        break;
    case 153:
        settings.stream() << "VK_FORMAT_EAC_R11_UNORM_BLOCK (";
        break;
    case 154:
        settings.stream() << "VK_FORMAT_EAC_R11_SNORM_BLOCK (";
        break;
    case 155:
        settings.stream() << "VK_FORMAT_EAC_R11G11_UNORM_BLOCK (";
        break;
    case 156:
        settings.stream() << "VK_FORMAT_EAC_R11G11_SNORM_BLOCK (";
        break;
    case 157:
        settings.stream() << "VK_FORMAT_ASTC_4x4_UNORM_BLOCK (";
        break;
    case 158:
        settings.stream() << "VK_FORMAT_ASTC_4x4_SRGB_BLOCK (";
        break;
    case 159:
        settings.stream() << "VK_FORMAT_ASTC_5x4_UNORM_BLOCK (";
        break;
    case 160:
        settings.stream() << "VK_FORMAT_ASTC_5x4_SRGB_BLOCK (";
        break;
    case 161:
        settings.stream() << "VK_FORMAT_ASTC_5x5_UNORM_BLOCK (";
        break;
    case 162:
        settings.stream() << "VK_FORMAT_ASTC_5x5_SRGB_BLOCK (";
        break;
    case 163:
        settings.stream() << "VK_FORMAT_ASTC_6x5_UNORM_BLOCK (";
        break;
    case 164:
        settings.stream() << "VK_FORMAT_ASTC_6x5_SRGB_BLOCK (";
        break;
    case 165:
        settings.stream() << "VK_FORMAT_ASTC_6x6_UNORM_BLOCK (";
        break;
    case 166:
        settings.stream() << "VK_FORMAT_ASTC_6x6_SRGB_BLOCK (";
        break;
    case 167:
        settings.stream() << "VK_FORMAT_ASTC_8x5_UNORM_BLOCK (";
        break;
    case 168:
        settings.stream() << "VK_FORMAT_ASTC_8x5_SRGB_BLOCK (";
        break;
    case 169:
        settings.stream() << "VK_FORMAT_ASTC_8x6_UNORM_BLOCK (";
        break;
    case 170:
        settings.stream() << "VK_FORMAT_ASTC_8x6_SRGB_BLOCK (";
        break;
    case 171:
        settings.stream() << "VK_FORMAT_ASTC_8x8_UNORM_BLOCK (";
        break;
    case 172:
        settings.stream() << "VK_FORMAT_ASTC_8x8_SRGB_BLOCK (";
        break;
    case 173:
        settings.stream() << "VK_FORMAT_ASTC_10x5_UNORM_BLOCK (";
        break;
    case 174:
        settings.stream() << "VK_FORMAT_ASTC_10x5_SRGB_BLOCK (";
        break;
    case 175:
        settings.stream() << "VK_FORMAT_ASTC_10x6_UNORM_BLOCK (";
        break;
    case 176:
        settings.stream() << "VK_FORMAT_ASTC_10x6_SRGB_BLOCK (";
        break;
    case 177:
        settings.stream() << "VK_FORMAT_ASTC_10x8_UNORM_BLOCK (";
        break;
    case 178:
        settings.stream() << "VK_FORMAT_ASTC_10x8_SRGB_BLOCK (";
        break;
    case 179:
        settings.stream() << "VK_FORMAT_ASTC_10x10_UNORM_BLOCK (";
        break;
    case 180:
        settings.stream() << "VK_FORMAT_ASTC_10x10_SRGB_BLOCK (";
        break;
    case 181:
        settings.stream() << "VK_FORMAT_ASTC_12x10_UNORM_BLOCK (";
        break;
    case 182:
        settings.stream() << "VK_FORMAT_ASTC_12x10_SRGB_BLOCK (";
        break;
    case 183:
        settings.stream() << "VK_FORMAT_ASTC_12x12_UNORM_BLOCK (";
        break;
    case 184:
        settings.stream() << "VK_FORMAT_ASTC_12x12_SRGB_BLOCK (";
        break;
    case 1000156000:
        settings.stream() << "VK_FORMAT_G8B8G8R8_422_UNORM (";
        break;
    case 1000156001:
        settings.stream() << "VK_FORMAT_B8G8R8G8_422_UNORM (";
        break;
    case 1000156002:
        settings.stream() << "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM (";
        break;
    case 1000156003:
        settings.stream() << "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM (";
        break;
    case 1000156004:
        settings.stream() << "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM (";
        break;
    case 1000156005:
        settings.stream() << "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM (";
        break;
    case 1000156006:
        settings.stream() << "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM (";
        break;
    case 1000156007:
        settings.stream() << "VK_FORMAT_R10X6_UNORM_PACK16 (";
        break;
    case 1000156008:
        settings.stream() << "VK_FORMAT_R10X6G10X6_UNORM_2PACK16 (";
        break;
    case 1000156009:
        settings.stream() << "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 (";
        break;
    case 1000156010:
        settings.stream() << "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 (";
        break;
    case 1000156011:
        settings.stream() << "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 (";
        break;
    case 1000156012:
        settings.stream() << "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 (";
        break;
    case 1000156013:
        settings.stream() << "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 (";
        break;
    case 1000156014:
        settings.stream() << "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 (";
        break;
    case 1000156015:
        settings.stream() << "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 (";
        break;
    case 1000156016:
        settings.stream() << "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 (";
        break;
    case 1000156017:
        settings.stream() << "VK_FORMAT_R12X4_UNORM_PACK16 (";
        break;
    case 1000156018:
        settings.stream() << "VK_FORMAT_R12X4G12X4_UNORM_2PACK16 (";
        break;
    case 1000156019:
        settings.stream() << "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 (";
        break;
    case 1000156020:
        settings.stream() << "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 (";
        break;
    case 1000156021:
        settings.stream() << "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 (";
        break;
    case 1000156022:
        settings.stream() << "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 (";
        break;
    case 1000156023:
        settings.stream() << "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 (";
        break;
    case 1000156024:
        settings.stream() << "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 (";
        break;
    case 1000156025:
        settings.stream() << "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 (";
        break;
    case 1000156026:
        settings.stream() << "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 (";
        break;
    case 1000156027:
        settings.stream() << "VK_FORMAT_G16B16G16R16_422_UNORM (";
        break;
    case 1000156028:
        settings.stream() << "VK_FORMAT_B16G16R16G16_422_UNORM (";
        break;
    case 1000156029:
        settings.stream() << "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM (";
        break;
    case 1000156030:
        settings.stream() << "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM (";
        break;
    case 1000156031:
        settings.stream() << "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM (";
        break;
    case 1000156032:
        settings.stream() << "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM (";
        break;
    case 1000156033:
        settings.stream() << "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM (";
        break;
    case 1000054000:
        settings.stream() << "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG (";
        break;
    case 1000054001:
        settings.stream() << "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG (";
        break;
    case 1000054002:
        settings.stream() << "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG (";
        break;
    case 1000054003:
        settings.stream() << "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG (";
        break;
    case 1000054004:
        settings.stream() << "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG (";
        break;
    case 1000054005:
        settings.stream() << "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG (";
        break;
    case 1000054006:
        settings.stream() << "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG (";
        break;
    case 1000054007:
        settings.stream() << "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG (";
        break;
    case 1000066000:
        settings.stream() << "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066001:
        settings.stream() << "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066002:
        settings.stream() << "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066003:
        settings.stream() << "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066004:
        settings.stream() << "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066005:
        settings.stream() << "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066006:
        settings.stream() << "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066007:
        settings.stream() << "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066008:
        settings.stream() << "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066009:
        settings.stream() << "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066010:
        settings.stream() << "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066011:
        settings.stream() << "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066012:
        settings.stream() << "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT (";
        break;
    case 1000066013:
        settings.stream() << "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkValidationCheckEXT(VkValidationCheckEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_VALIDATION_CHECK_ALL_EXT (";
        break;
    case 1:
        settings.stream() << "VK_VALIDATION_CHECK_SHADERS_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkObjectType(VkObjectType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_OBJECT_TYPE_UNKNOWN (";
        break;
    case 1:
        settings.stream() << "VK_OBJECT_TYPE_INSTANCE (";
        break;
    case 2:
        settings.stream() << "VK_OBJECT_TYPE_PHYSICAL_DEVICE (";
        break;
    case 3:
        settings.stream() << "VK_OBJECT_TYPE_DEVICE (";
        break;
    case 4:
        settings.stream() << "VK_OBJECT_TYPE_QUEUE (";
        break;
    case 5:
        settings.stream() << "VK_OBJECT_TYPE_SEMAPHORE (";
        break;
    case 6:
        settings.stream() << "VK_OBJECT_TYPE_COMMAND_BUFFER (";
        break;
    case 7:
        settings.stream() << "VK_OBJECT_TYPE_FENCE (";
        break;
    case 8:
        settings.stream() << "VK_OBJECT_TYPE_DEVICE_MEMORY (";
        break;
    case 9:
        settings.stream() << "VK_OBJECT_TYPE_BUFFER (";
        break;
    case 10:
        settings.stream() << "VK_OBJECT_TYPE_IMAGE (";
        break;
    case 11:
        settings.stream() << "VK_OBJECT_TYPE_EVENT (";
        break;
    case 12:
        settings.stream() << "VK_OBJECT_TYPE_QUERY_POOL (";
        break;
    case 13:
        settings.stream() << "VK_OBJECT_TYPE_BUFFER_VIEW (";
        break;
    case 14:
        settings.stream() << "VK_OBJECT_TYPE_IMAGE_VIEW (";
        break;
    case 15:
        settings.stream() << "VK_OBJECT_TYPE_SHADER_MODULE (";
        break;
    case 16:
        settings.stream() << "VK_OBJECT_TYPE_PIPELINE_CACHE (";
        break;
    case 17:
        settings.stream() << "VK_OBJECT_TYPE_PIPELINE_LAYOUT (";
        break;
    case 18:
        settings.stream() << "VK_OBJECT_TYPE_RENDER_PASS (";
        break;
    case 19:
        settings.stream() << "VK_OBJECT_TYPE_PIPELINE (";
        break;
    case 20:
        settings.stream() << "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT (";
        break;
    case 21:
        settings.stream() << "VK_OBJECT_TYPE_SAMPLER (";
        break;
    case 22:
        settings.stream() << "VK_OBJECT_TYPE_DESCRIPTOR_POOL (";
        break;
    case 23:
        settings.stream() << "VK_OBJECT_TYPE_DESCRIPTOR_SET (";
        break;
    case 24:
        settings.stream() << "VK_OBJECT_TYPE_FRAMEBUFFER (";
        break;
    case 25:
        settings.stream() << "VK_OBJECT_TYPE_COMMAND_POOL (";
        break;
    case 1000156000:
        settings.stream() << "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION (";
        break;
    case 1000085000:
        settings.stream() << "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE (";
        break;
    case 1000000000:
        settings.stream() << "VK_OBJECT_TYPE_SURFACE_KHR (";
        break;
    case 1000001000:
        settings.stream() << "VK_OBJECT_TYPE_SWAPCHAIN_KHR (";
        break;
    case 1000002000:
        settings.stream() << "VK_OBJECT_TYPE_DISPLAY_KHR (";
        break;
    case 1000002001:
        settings.stream() << "VK_OBJECT_TYPE_DISPLAY_MODE_KHR (";
        break;
    case 1000011000:
        settings.stream() << "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT (";
        break;
    case 1000086000:
        settings.stream() << "VK_OBJECT_TYPE_OBJECT_TABLE_NVX (";
        break;
    case 1000086001:
        settings.stream() << "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX (";
        break;
    case 1000128000:
        settings.stream() << "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT (";
        break;
    case 1000160000:
        settings.stream() << "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT (";
        break;
    case 1000165000:
        settings.stream() << "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV (";
        break;
    case 1000210000:
        settings.stream() << "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDisplayPowerStateEXT(VkDisplayPowerStateEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DISPLAY_POWER_STATE_OFF_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DISPLAY_POWER_STATE_SUSPEND_EXT (";
        break;
    case 2:
        settings.stream() << "VK_DISPLAY_POWER_STATE_ON_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkLogicOp(VkLogicOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_LOGIC_OP_CLEAR (";
        break;
    case 1:
        settings.stream() << "VK_LOGIC_OP_AND (";
        break;
    case 2:
        settings.stream() << "VK_LOGIC_OP_AND_REVERSE (";
        break;
    case 3:
        settings.stream() << "VK_LOGIC_OP_COPY (";
        break;
    case 4:
        settings.stream() << "VK_LOGIC_OP_AND_INVERTED (";
        break;
    case 5:
        settings.stream() << "VK_LOGIC_OP_NO_OP (";
        break;
    case 6:
        settings.stream() << "VK_LOGIC_OP_XOR (";
        break;
    case 7:
        settings.stream() << "VK_LOGIC_OP_OR (";
        break;
    case 8:
        settings.stream() << "VK_LOGIC_OP_NOR (";
        break;
    case 9:
        settings.stream() << "VK_LOGIC_OP_EQUIVALENT (";
        break;
    case 10:
        settings.stream() << "VK_LOGIC_OP_INVERT (";
        break;
    case 11:
        settings.stream() << "VK_LOGIC_OP_OR_REVERSE (";
        break;
    case 12:
        settings.stream() << "VK_LOGIC_OP_COPY_INVERTED (";
        break;
    case 13:
        settings.stream() << "VK_LOGIC_OP_OR_INVERTED (";
        break;
    case 14:
        settings.stream() << "VK_LOGIC_OP_NAND (";
        break;
    case 15:
        settings.stream() << "VK_LOGIC_OP_SET (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkAccelerationStructureMemoryRequirementsTypeNV(VkAccelerationStructureMemoryRequirementsTypeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV (";
        break;
    case 1:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV (";
        break;
    case 2:
        settings.stream() << "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPipelineCacheHeaderVersion(VkPipelineCacheHeaderVersion object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_PIPELINE_CACHE_HEADER_VERSION_ONE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDisplayEventTypeEXT(VkDisplayEventTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkFilter(VkFilter object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FILTER_NEAREST (";
        break;
    case 1:
        settings.stream() << "VK_FILTER_LINEAR (";
        break;
    case 1000015000:
        settings.stream() << "VK_FILTER_CUBIC_IMG (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkSamplerMipmapMode(VkSamplerMipmapMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_MIPMAP_MODE_NEAREST (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_MIPMAP_MODE_LINEAR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkResult(VkResult object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SUCCESS (";
        break;
    case 1:
        settings.stream() << "VK_NOT_READY (";
        break;
    case 2:
        settings.stream() << "VK_TIMEOUT (";
        break;
    case 3:
        settings.stream() << "VK_EVENT_SET (";
        break;
    case 4:
        settings.stream() << "VK_EVENT_RESET (";
        break;
    case 5:
        settings.stream() << "VK_INCOMPLETE (";
        break;
    case -1:
        settings.stream() << "VK_ERROR_OUT_OF_HOST_MEMORY (";
        break;
    case -2:
        settings.stream() << "VK_ERROR_OUT_OF_DEVICE_MEMORY (";
        break;
    case -3:
        settings.stream() << "VK_ERROR_INITIALIZATION_FAILED (";
        break;
    case -4:
        settings.stream() << "VK_ERROR_DEVICE_LOST (";
        break;
    case -5:
        settings.stream() << "VK_ERROR_MEMORY_MAP_FAILED (";
        break;
    case -6:
        settings.stream() << "VK_ERROR_LAYER_NOT_PRESENT (";
        break;
    case -7:
        settings.stream() << "VK_ERROR_EXTENSION_NOT_PRESENT (";
        break;
    case -8:
        settings.stream() << "VK_ERROR_FEATURE_NOT_PRESENT (";
        break;
    case -9:
        settings.stream() << "VK_ERROR_INCOMPATIBLE_DRIVER (";
        break;
    case -10:
        settings.stream() << "VK_ERROR_TOO_MANY_OBJECTS (";
        break;
    case -11:
        settings.stream() << "VK_ERROR_FORMAT_NOT_SUPPORTED (";
        break;
    case -12:
        settings.stream() << "VK_ERROR_FRAGMENTED_POOL (";
        break;
    case -1000069000:
        settings.stream() << "VK_ERROR_OUT_OF_POOL_MEMORY (";
        break;
    case -1000072003:
        settings.stream() << "VK_ERROR_INVALID_EXTERNAL_HANDLE (";
        break;
    case -1000000000:
        settings.stream() << "VK_ERROR_SURFACE_LOST_KHR (";
        break;
    case -1000000001:
        settings.stream() << "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR (";
        break;
    case 1000001003:
        settings.stream() << "VK_SUBOPTIMAL_KHR (";
        break;
    case -1000001004:
        settings.stream() << "VK_ERROR_OUT_OF_DATE_KHR (";
        break;
    case -1000003001:
        settings.stream() << "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR (";
        break;
    case -1000011001:
        settings.stream() << "VK_ERROR_VALIDATION_FAILED_EXT (";
        break;
    case -1000012000:
        settings.stream() << "VK_ERROR_INVALID_SHADER_NV (";
        break;
    case -1000158000:
        settings.stream() << "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT (";
        break;
    case -1000161000:
        settings.stream() << "VK_ERROR_FRAGMENTATION_EXT (";
        break;
    case -1000174001:
        settings.stream() << "VK_ERROR_NOT_PERMITTED_EXT (";
        break;
    case -1000244000:
        settings.stream() << "VK_ERROR_INVALID_DEVICE_ADDRESS_EXT (";
        break;
    case -1000255000:
        settings.stream() << "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkTessellationDomainOrigin(VkTessellationDomainOrigin object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT (";
        break;
    case 1:
        settings.stream() << "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkSamplerYcbcrRange(VkSamplerYcbcrRange object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_YCBCR_RANGE_ITU_FULL (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkSamplerAddressMode(VkSamplerAddressMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_REPEAT (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT (";
        break;
    case 2:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE (";
        break;
    case 3:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER (";
        break;
    case 4:
        settings.stream() << "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkSamplerYcbcrModelConversion(VkSamplerYcbcrModelConversion object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY (";
        break;
    case 2:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 (";
        break;
    case 3:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 (";
        break;
    case 4:
        settings.stream() << "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkSamplerReductionModeEXT(VkSamplerReductionModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT (";
        break;
    case 1:
        settings.stream() << "VK_SAMPLER_REDUCTION_MODE_MIN_EXT (";
        break;
    case 2:
        settings.stream() << "VK_SAMPLER_REDUCTION_MODE_MAX_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkBorderColor(VkBorderColor object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK (";
        break;
    case 1:
        settings.stream() << "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK (";
        break;
    case 2:
        settings.stream() << "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK (";
        break;
    case 3:
        settings.stream() << "VK_BORDER_COLOR_INT_OPAQUE_BLACK (";
        break;
    case 4:
        settings.stream() << "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE (";
        break;
    case 5:
        settings.stream() << "VK_BORDER_COLOR_INT_OPAQUE_WHITE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkChromaLocation(VkChromaLocation object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_CHROMA_LOCATION_COSITED_EVEN (";
        break;
    case 1:
        settings.stream() << "VK_CHROMA_LOCATION_MIDPOINT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkBlendFactor(VkBlendFactor object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BLEND_FACTOR_ZERO (";
        break;
    case 1:
        settings.stream() << "VK_BLEND_FACTOR_ONE (";
        break;
    case 2:
        settings.stream() << "VK_BLEND_FACTOR_SRC_COLOR (";
        break;
    case 3:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR (";
        break;
    case 4:
        settings.stream() << "VK_BLEND_FACTOR_DST_COLOR (";
        break;
    case 5:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR (";
        break;
    case 6:
        settings.stream() << "VK_BLEND_FACTOR_SRC_ALPHA (";
        break;
    case 7:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA (";
        break;
    case 8:
        settings.stream() << "VK_BLEND_FACTOR_DST_ALPHA (";
        break;
    case 9:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA (";
        break;
    case 10:
        settings.stream() << "VK_BLEND_FACTOR_CONSTANT_COLOR (";
        break;
    case 11:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR (";
        break;
    case 12:
        settings.stream() << "VK_BLEND_FACTOR_CONSTANT_ALPHA (";
        break;
    case 13:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA (";
        break;
    case 14:
        settings.stream() << "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE (";
        break;
    case 15:
        settings.stream() << "VK_BLEND_FACTOR_SRC1_COLOR (";
        break;
    case 16:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR (";
        break;
    case 17:
        settings.stream() << "VK_BLEND_FACTOR_SRC1_ALPHA (";
        break;
    case 18:
        settings.stream() << "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkBlendOp(VkBlendOp object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BLEND_OP_ADD (";
        break;
    case 1:
        settings.stream() << "VK_BLEND_OP_SUBTRACT (";
        break;
    case 2:
        settings.stream() << "VK_BLEND_OP_REVERSE_SUBTRACT (";
        break;
    case 3:
        settings.stream() << "VK_BLEND_OP_MIN (";
        break;
    case 4:
        settings.stream() << "VK_BLEND_OP_MAX (";
        break;
    case 1000148000:
        settings.stream() << "VK_BLEND_OP_ZERO_EXT (";
        break;
    case 1000148001:
        settings.stream() << "VK_BLEND_OP_SRC_EXT (";
        break;
    case 1000148002:
        settings.stream() << "VK_BLEND_OP_DST_EXT (";
        break;
    case 1000148003:
        settings.stream() << "VK_BLEND_OP_SRC_OVER_EXT (";
        break;
    case 1000148004:
        settings.stream() << "VK_BLEND_OP_DST_OVER_EXT (";
        break;
    case 1000148005:
        settings.stream() << "VK_BLEND_OP_SRC_IN_EXT (";
        break;
    case 1000148006:
        settings.stream() << "VK_BLEND_OP_DST_IN_EXT (";
        break;
    case 1000148007:
        settings.stream() << "VK_BLEND_OP_SRC_OUT_EXT (";
        break;
    case 1000148008:
        settings.stream() << "VK_BLEND_OP_DST_OUT_EXT (";
        break;
    case 1000148009:
        settings.stream() << "VK_BLEND_OP_SRC_ATOP_EXT (";
        break;
    case 1000148010:
        settings.stream() << "VK_BLEND_OP_DST_ATOP_EXT (";
        break;
    case 1000148011:
        settings.stream() << "VK_BLEND_OP_XOR_EXT (";
        break;
    case 1000148012:
        settings.stream() << "VK_BLEND_OP_MULTIPLY_EXT (";
        break;
    case 1000148013:
        settings.stream() << "VK_BLEND_OP_SCREEN_EXT (";
        break;
    case 1000148014:
        settings.stream() << "VK_BLEND_OP_OVERLAY_EXT (";
        break;
    case 1000148015:
        settings.stream() << "VK_BLEND_OP_DARKEN_EXT (";
        break;
    case 1000148016:
        settings.stream() << "VK_BLEND_OP_LIGHTEN_EXT (";
        break;
    case 1000148017:
        settings.stream() << "VK_BLEND_OP_COLORDODGE_EXT (";
        break;
    case 1000148018:
        settings.stream() << "VK_BLEND_OP_COLORBURN_EXT (";
        break;
    case 1000148019:
        settings.stream() << "VK_BLEND_OP_HARDLIGHT_EXT (";
        break;
    case 1000148020:
        settings.stream() << "VK_BLEND_OP_SOFTLIGHT_EXT (";
        break;
    case 1000148021:
        settings.stream() << "VK_BLEND_OP_DIFFERENCE_EXT (";
        break;
    case 1000148022:
        settings.stream() << "VK_BLEND_OP_EXCLUSION_EXT (";
        break;
    case 1000148023:
        settings.stream() << "VK_BLEND_OP_INVERT_EXT (";
        break;
    case 1000148024:
        settings.stream() << "VK_BLEND_OP_INVERT_RGB_EXT (";
        break;
    case 1000148025:
        settings.stream() << "VK_BLEND_OP_LINEARDODGE_EXT (";
        break;
    case 1000148026:
        settings.stream() << "VK_BLEND_OP_LINEARBURN_EXT (";
        break;
    case 1000148027:
        settings.stream() << "VK_BLEND_OP_VIVIDLIGHT_EXT (";
        break;
    case 1000148028:
        settings.stream() << "VK_BLEND_OP_LINEARLIGHT_EXT (";
        break;
    case 1000148029:
        settings.stream() << "VK_BLEND_OP_PINLIGHT_EXT (";
        break;
    case 1000148030:
        settings.stream() << "VK_BLEND_OP_HARDMIX_EXT (";
        break;
    case 1000148031:
        settings.stream() << "VK_BLEND_OP_HSL_HUE_EXT (";
        break;
    case 1000148032:
        settings.stream() << "VK_BLEND_OP_HSL_SATURATION_EXT (";
        break;
    case 1000148033:
        settings.stream() << "VK_BLEND_OP_HSL_COLOR_EXT (";
        break;
    case 1000148034:
        settings.stream() << "VK_BLEND_OP_HSL_LUMINOSITY_EXT (";
        break;
    case 1000148035:
        settings.stream() << "VK_BLEND_OP_PLUS_EXT (";
        break;
    case 1000148036:
        settings.stream() << "VK_BLEND_OP_PLUS_CLAMPED_EXT (";
        break;
    case 1000148037:
        settings.stream() << "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT (";
        break;
    case 1000148038:
        settings.stream() << "VK_BLEND_OP_PLUS_DARKER_EXT (";
        break;
    case 1000148039:
        settings.stream() << "VK_BLEND_OP_MINUS_EXT (";
        break;
    case 1000148040:
        settings.stream() << "VK_BLEND_OP_MINUS_CLAMPED_EXT (";
        break;
    case 1000148041:
        settings.stream() << "VK_BLEND_OP_CONTRAST_EXT (";
        break;
    case 1000148042:
        settings.stream() << "VK_BLEND_OP_INVERT_OVG_EXT (";
        break;
    case 1000148043:
        settings.stream() << "VK_BLEND_OP_RED_EXT (";
        break;
    case 1000148044:
        settings.stream() << "VK_BLEND_OP_GREEN_EXT (";
        break;
    case 1000148045:
        settings.stream() << "VK_BLEND_OP_BLUE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDeviceEventTypeEXT(VkDeviceEventTypeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkImageViewType(VkImageViewType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_1D (";
        break;
    case 1:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_2D (";
        break;
    case 2:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_3D (";
        break;
    case 3:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_CUBE (";
        break;
    case 4:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_1D_ARRAY (";
        break;
    case 5:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_2D_ARRAY (";
        break;
    case 6:
        settings.stream() << "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkBlendOverlapEXT(VkBlendOverlapEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_BLEND_OVERLAP_UNCORRELATED_EXT (";
        break;
    case 1:
        settings.stream() << "VK_BLEND_OVERLAP_DISJOINT_EXT (";
        break;
    case 2:
        settings.stream() << "VK_BLEND_OVERLAP_CONJOINT_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkIndirectCommandsTokenTypeNVX(VkIndirectCommandsTokenTypeNVX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX (";
        break;
    case 1:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX (";
        break;
    case 2:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX (";
        break;
    case 3:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX (";
        break;
    case 4:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX (";
        break;
    case 5:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX (";
        break;
    case 6:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX (";
        break;
    case 7:
        settings.stream() << "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkObjectEntryTypeNVX(VkObjectEntryTypeNVX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX (";
        break;
    case 1:
        settings.stream() << "VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX (";
        break;
    case 2:
        settings.stream() << "VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX (";
        break;
    case 3:
        settings.stream() << "VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX (";
        break;
    case 4:
        settings.stream() << "VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDiscardRectangleModeEXT(VkDiscardRectangleModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT (";
        break;
    case 1:
        settings.stream() << "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDriverIdKHR(VkDriverIdKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_DRIVER_ID_AMD_PROPRIETARY_KHR (";
        break;
    case 2:
        settings.stream() << "VK_DRIVER_ID_AMD_OPEN_SOURCE_KHR (";
        break;
    case 3:
        settings.stream() << "VK_DRIVER_ID_MESA_RADV_KHR (";
        break;
    case 4:
        settings.stream() << "VK_DRIVER_ID_NVIDIA_PROPRIETARY_KHR (";
        break;
    case 5:
        settings.stream() << "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS_KHR (";
        break;
    case 6:
        settings.stream() << "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA_KHR (";
        break;
    case 7:
        settings.stream() << "VK_DRIVER_ID_IMAGINATION_PROPRIETARY_KHR (";
        break;
    case 8:
        settings.stream() << "VK_DRIVER_ID_QUALCOMM_PROPRIETARY_KHR (";
        break;
    case 9:
        settings.stream() << "VK_DRIVER_ID_ARM_PROPRIETARY_KHR (";
        break;
    case 10:
        settings.stream() << "VK_DRIVER_ID_GOOGLE_SWIFTSHADER_KHR (";
        break;
    case 11:
        settings.stream() << "VK_DRIVER_ID_GGP_PROPRIETARY_KHR (";
        break;
    case 12:
        settings.stream() << "VK_DRIVER_ID_BROADCOM_PROPRIETARY_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkComponentSwizzle(VkComponentSwizzle object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COMPONENT_SWIZZLE_IDENTITY (";
        break;
    case 1:
        settings.stream() << "VK_COMPONENT_SWIZZLE_ZERO (";
        break;
    case 2:
        settings.stream() << "VK_COMPONENT_SWIZZLE_ONE (";
        break;
    case 3:
        settings.stream() << "VK_COMPONENT_SWIZZLE_R (";
        break;
    case 4:
        settings.stream() << "VK_COMPONENT_SWIZZLE_G (";
        break;
    case 5:
        settings.stream() << "VK_COMPONENT_SWIZZLE_B (";
        break;
    case 6:
        settings.stream() << "VK_COMPONENT_SWIZZLE_A (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkCoverageModulationModeNV(VkCoverageModulationModeNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_COVERAGE_MODULATION_MODE_NONE_NV (";
        break;
    case 1:
        settings.stream() << "VK_COVERAGE_MODULATION_MODE_RGB_NV (";
        break;
    case 2:
        settings.stream() << "VK_COVERAGE_MODULATION_MODE_ALPHA_NV (";
        break;
    case 3:
        settings.stream() << "VK_COVERAGE_MODULATION_MODE_RGBA_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkStructureType(VkStructureType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_STRUCTURE_TYPE_APPLICATION_INFO (";
        break;
    case 1:
        settings.stream() << "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO (";
        break;
    case 2:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO (";
        break;
    case 3:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO (";
        break;
    case 4:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBMIT_INFO (";
        break;
    case 5:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO (";
        break;
    case 6:
        settings.stream() << "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE (";
        break;
    case 7:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO (";
        break;
    case 8:
        settings.stream() << "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO (";
        break;
    case 9:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO (";
        break;
    case 10:
        settings.stream() << "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO (";
        break;
    case 11:
        settings.stream() << "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO (";
        break;
    case 12:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO (";
        break;
    case 13:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO (";
        break;
    case 14:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO (";
        break;
    case 15:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO (";
        break;
    case 16:
        settings.stream() << "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO (";
        break;
    case 17:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO (";
        break;
    case 18:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO (";
        break;
    case 19:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO (";
        break;
    case 20:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO (";
        break;
    case 21:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO (";
        break;
    case 22:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO (";
        break;
    case 23:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO (";
        break;
    case 24:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO (";
        break;
    case 25:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO (";
        break;
    case 26:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO (";
        break;
    case 27:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO (";
        break;
    case 28:
        settings.stream() << "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO (";
        break;
    case 29:
        settings.stream() << "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO (";
        break;
    case 30:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO (";
        break;
    case 31:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO (";
        break;
    case 32:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO (";
        break;
    case 33:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO (";
        break;
    case 34:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO (";
        break;
    case 35:
        settings.stream() << "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET (";
        break;
    case 36:
        settings.stream() << "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET (";
        break;
    case 37:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO (";
        break;
    case 38:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO (";
        break;
    case 39:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO (";
        break;
    case 40:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO (";
        break;
    case 41:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO (";
        break;
    case 42:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO (";
        break;
    case 43:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO (";
        break;
    case 44:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER (";
        break;
    case 45:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER (";
        break;
    case 46:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_BARRIER (";
        break;
    case 47:
        settings.stream() << "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO (";
        break;
    case 48:
        settings.stream() << "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO (";
        break;
    case 1000094000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES (";
        break;
    case 1000157000:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO (";
        break;
    case 1000157001:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO (";
        break;
    case 1000083000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES (";
        break;
    case 1000127000:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS (";
        break;
    case 1000127001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO (";
        break;
    case 1000060000:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO (";
        break;
    case 1000060003:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO (";
        break;
    case 1000060004:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO (";
        break;
    case 1000060005:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO (";
        break;
    case 1000060006:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO (";
        break;
    case 1000060013:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO (";
        break;
    case 1000060014:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO (";
        break;
    case 1000070000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES (";
        break;
    case 1000070001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO (";
        break;
    case 1000146000:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 (";
        break;
    case 1000146001:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 (";
        break;
    case 1000146002:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 (";
        break;
    case 1000146003:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 (";
        break;
    case 1000146004:
        settings.stream() << "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 (";
        break;
    case 1000059000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 (";
        break;
    case 1000059001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 (";
        break;
    case 1000059002:
        settings.stream() << "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 (";
        break;
    case 1000059003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 (";
        break;
    case 1000059004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 (";
        break;
    case 1000059005:
        settings.stream() << "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 (";
        break;
    case 1000059006:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 (";
        break;
    case 1000059007:
        settings.stream() << "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 (";
        break;
    case 1000059008:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 (";
        break;
    case 1000117000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES (";
        break;
    case 1000117001:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO (";
        break;
    case 1000117002:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO (";
        break;
    case 1000117003:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO (";
        break;
    case 1000053000:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO (";
        break;
    case 1000053001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES (";
        break;
    case 1000053002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES (";
        break;
    case 1000120000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES (";
        break;
    case 1000145000:
        settings.stream() << "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO (";
        break;
    case 1000145001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES (";
        break;
    case 1000145002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES (";
        break;
    case 1000145003:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 (";
        break;
    case 1000156000:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO (";
        break;
    case 1000156001:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO (";
        break;
    case 1000156002:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO (";
        break;
    case 1000156003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO (";
        break;
    case 1000156004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES (";
        break;
    case 1000156005:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES (";
        break;
    case 1000085000:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO (";
        break;
    case 1000071000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO (";
        break;
    case 1000071001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES (";
        break;
    case 1000071002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO (";
        break;
    case 1000071003:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES (";
        break;
    case 1000071004:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES (";
        break;
    case 1000072000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO (";
        break;
    case 1000072001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO (";
        break;
    case 1000072002:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO (";
        break;
    case 1000112000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO (";
        break;
    case 1000112001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES (";
        break;
    case 1000113000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO (";
        break;
    case 1000077000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO (";
        break;
    case 1000076000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO (";
        break;
    case 1000076001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES (";
        break;
    case 1000168000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES (";
        break;
    case 1000168001:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT (";
        break;
    case 1000063000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES (";
        break;
    case 1000001000:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR (";
        break;
    case 1000001001:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR (";
        break;
    case 1000060007:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR (";
        break;
    case 1000060008:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR (";
        break;
    case 1000060009:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR (";
        break;
    case 1000060010:
        settings.stream() << "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR (";
        break;
    case 1000060011:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR (";
        break;
    case 1000060012:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR (";
        break;
    case 1000002000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR (";
        break;
    case 1000002001:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000003000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR (";
        break;
    case 1000004000:
        settings.stream() << "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000005000:
        settings.stream() << "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000006000:
        settings.stream() << "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000008000:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000009000:
        settings.stream() << "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR (";
        break;
    case 1000010000:
        settings.stream() << "VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID (";
        break;
    case 1000010001:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_IMAGE_CREATE_INFO_ANDROID (";
        break;
    case 1000010002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENTATION_PROPERTIES_ANDROID (";
        break;
    case 1000011000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT (";
        break;
    case 1000018000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD (";
        break;
    case 1000022000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT (";
        break;
    case 1000022001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT (";
        break;
    case 1000022002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT (";
        break;
    case 1000026000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV (";
        break;
    case 1000026001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV (";
        break;
    case 1000026002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV (";
        break;
    case 1000028000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT (";
        break;
    case 1000028001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT (";
        break;
    case 1000028002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT (";
        break;
    case 1000030000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX (";
        break;
    case 1000041000:
        settings.stream() << "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD (";
        break;
    case 1000049000:
        settings.stream() << "VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP (";
        break;
    case 1000050000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV (";
        break;
    case 1000056000:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV (";
        break;
    case 1000056001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV (";
        break;
    case 1000057000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV (";
        break;
    case 1000057001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV (";
        break;
    case 1000058000:
        settings.stream() << "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV (";
        break;
    case 1000061000:
        settings.stream() << "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT (";
        break;
    case 1000062000:
        settings.stream() << "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN (";
        break;
    case 1000066000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES_EXT (";
        break;
    case 1000067000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT (";
        break;
    case 1000067001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT (";
        break;
    case 1000073000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000073001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000073002:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR (";
        break;
    case 1000073003:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000074000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR (";
        break;
    case 1000074001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR (";
        break;
    case 1000074002:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR (";
        break;
    case 1000075000:
        settings.stream() << "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR (";
        break;
    case 1000078000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000078001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000078002:
        settings.stream() << "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR (";
        break;
    case 1000078003:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000079000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR (";
        break;
    case 1000079001:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR (";
        break;
    case 1000080000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR (";
        break;
    case 1000081000:
        settings.stream() << "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT (";
        break;
    case 1000081001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT (";
        break;
    case 1000081002:
        settings.stream() << "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT (";
        break;
    case 1000082000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES_KHR (";
        break;
    case 1000084000:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR (";
        break;
    case 1000086000:
        settings.stream() << "VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX (";
        break;
    case 1000086001:
        settings.stream() << "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX (";
        break;
    case 1000086002:
        settings.stream() << "VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX (";
        break;
    case 1000086003:
        settings.stream() << "VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX (";
        break;
    case 1000086004:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX (";
        break;
    case 1000086005:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX (";
        break;
    case 1000087000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV (";
        break;
    case 1000090000:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT (";
        break;
    case 1000091000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT (";
        break;
    case 1000091001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT (";
        break;
    case 1000091002:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT (";
        break;
    case 1000091003:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT (";
        break;
    case 1000092000:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE (";
        break;
    case 1000097000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX (";
        break;
    case 1000098000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV (";
        break;
    case 1000099000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT (";
        break;
    case 1000099001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT (";
        break;
    case 1000101000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT (";
        break;
    case 1000101001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT (";
        break;
    case 1000102000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT (";
        break;
    case 1000102001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT (";
        break;
    case 1000105000:
        settings.stream() << "VK_STRUCTURE_TYPE_HDR_METADATA_EXT (";
        break;
    case 1000108000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES_KHR (";
        break;
    case 1000108001:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO_KHR (";
        break;
    case 1000108002:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO_KHR (";
        break;
    case 1000108003:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO_KHR (";
        break;
    case 1000109000:
        settings.stream() << "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR (";
        break;
    case 1000109001:
        settings.stream() << "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR (";
        break;
    case 1000109002:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR (";
        break;
    case 1000109003:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR (";
        break;
    case 1000109004:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR (";
        break;
    case 1000109005:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR (";
        break;
    case 1000109006:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR (";
        break;
    case 1000111000:
        settings.stream() << "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR (";
        break;
    case 1000114000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000114001:
        settings.stream() << "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000114002:
        settings.stream() << "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR (";
        break;
    case 1000115000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR (";
        break;
    case 1000115001:
        settings.stream() << "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR (";
        break;
    case 1000119000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR (";
        break;
    case 1000119001:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR (";
        break;
    case 1000119002:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR (";
        break;
    case 1000121000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR (";
        break;
    case 1000121001:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR (";
        break;
    case 1000121002:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR (";
        break;
    case 1000121003:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR (";
        break;
    case 1000121004:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR (";
        break;
    case 1000122000:
        settings.stream() << "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK (";
        break;
    case 1000123000:
        settings.stream() << "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK (";
        break;
    case 1000128000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT (";
        break;
    case 1000128001:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT (";
        break;
    case 1000128002:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT (";
        break;
    case 1000128003:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT (";
        break;
    case 1000128004:
        settings.stream() << "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT (";
        break;
    case 1000129000:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID (";
        break;
    case 1000129001:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID (";
        break;
    case 1000129002:
        settings.stream() << "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID (";
        break;
    case 1000129003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID (";
        break;
    case 1000129004:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID (";
        break;
    case 1000129005:
        settings.stream() << "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID (";
        break;
    case 1000130000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT (";
        break;
    case 1000130001:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT (";
        break;
    case 1000138000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES_EXT (";
        break;
    case 1000138001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES_EXT (";
        break;
    case 1000138002:
        settings.stream() << "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK_EXT (";
        break;
    case 1000138003:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO_EXT (";
        break;
    case 1000143000:
        settings.stream() << "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT (";
        break;
    case 1000143001:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT (";
        break;
    case 1000143002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT (";
        break;
    case 1000143003:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT (";
        break;
    case 1000143004:
        settings.stream() << "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT (";
        break;
    case 1000147000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR (";
        break;
    case 1000148000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT (";
        break;
    case 1000148001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT (";
        break;
    case 1000148002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT (";
        break;
    case 1000149000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV (";
        break;
    case 1000152000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV (";
        break;
    case 1000154000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV (";
        break;
    case 1000154001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV (";
        break;
    case 1000158000:
        settings.stream() << "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT (";
        break;
    case 1000158001:
        settings.stream() << "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT (";
        break;
    case 1000158002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT (";
        break;
    case 1000158003:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT (";
        break;
    case 1000158004:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT (";
        break;
    case 1000158005:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT (";
        break;
    case 1000160000:
        settings.stream() << "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT (";
        break;
    case 1000160001:
        settings.stream() << "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT (";
        break;
    case 1000161000:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT (";
        break;
    case 1000161001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT (";
        break;
    case 1000161002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT (";
        break;
    case 1000161003:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT (";
        break;
    case 1000161004:
        settings.stream() << "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT (";
        break;
    case 1000164000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV (";
        break;
    case 1000164001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV (";
        break;
    case 1000164002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV (";
        break;
    case 1000164005:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV (";
        break;
    case 1000165000:
        settings.stream() << "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV (";
        break;
    case 1000165001:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV (";
        break;
    case 1000165003:
        settings.stream() << "VK_STRUCTURE_TYPE_GEOMETRY_NV (";
        break;
    case 1000165004:
        settings.stream() << "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV (";
        break;
    case 1000165005:
        settings.stream() << "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV (";
        break;
    case 1000165006:
        settings.stream() << "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV (";
        break;
    case 1000165007:
        settings.stream() << "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV (";
        break;
    case 1000165008:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV (";
        break;
    case 1000165009:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV (";
        break;
    case 1000165011:
        settings.stream() << "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV (";
        break;
    case 1000165012:
        settings.stream() << "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV (";
        break;
    case 1000166000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV (";
        break;
    case 1000166001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV (";
        break;
    case 1000170000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT (";
        break;
    case 1000170001:
        settings.stream() << "VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT (";
        break;
    case 1000174000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT (";
        break;
    case 1000175000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES_KHR (";
        break;
    case 1000177000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR (";
        break;
    case 1000178000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT (";
        break;
    case 1000178001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT (";
        break;
    case 1000178002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT (";
        break;
    case 1000180000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES_KHR (";
        break;
    case 1000181000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR (";
        break;
    case 1000183000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD (";
        break;
    case 1000184000:
        settings.stream() << "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_EXT (";
        break;
    case 1000185000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD (";
        break;
    case 1000189000:
        settings.stream() << "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD (";
        break;
    case 1000190000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT (";
        break;
    case 1000190001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT (";
        break;
    case 1000190002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_EXT (";
        break;
    case 1000191000:
        settings.stream() << "VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP (";
        break;
    case 1000192000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO_EXT (";
        break;
    case 1000196000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES_KHR (";
        break;
    case 1000197000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES_KHR (";
        break;
    case 1000199000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES_KHR (";
        break;
    case 1000199001:
        settings.stream() << "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE_KHR (";
        break;
    case 1000201000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV (";
        break;
    case 1000202000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV (";
        break;
    case 1000202001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV (";
        break;
    case 1000203000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_NV (";
        break;
    case 1000204000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV (";
        break;
    case 1000205000:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV (";
        break;
    case 1000205002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV (";
        break;
    case 1000206000:
        settings.stream() << "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV (";
        break;
    case 1000206001:
        settings.stream() << "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV (";
        break;
    case 1000207000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES_KHR (";
        break;
    case 1000207001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES_KHR (";
        break;
    case 1000207002:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO_KHR (";
        break;
    case 1000207003:
        settings.stream() << "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO_KHR (";
        break;
    case 1000207004:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO_KHR (";
        break;
    case 1000207005:
        settings.stream() << "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO_KHR (";
        break;
    case 1000209000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL (";
        break;
    case 1000210000:
        settings.stream() << "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO_INTEL (";
        break;
    case 1000210001:
        settings.stream() << "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL (";
        break;
    case 1000210002:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL (";
        break;
    case 1000210003:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL (";
        break;
    case 1000210004:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL (";
        break;
    case 1000210005:
        settings.stream() << "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL (";
        break;
    case 1000211000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES_KHR (";
        break;
    case 1000212000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT (";
        break;
    case 1000213000:
        settings.stream() << "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD (";
        break;
    case 1000213001:
        settings.stream() << "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD (";
        break;
    case 1000214000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA (";
        break;
    case 1000217000:
        settings.stream() << "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT (";
        break;
    case 1000218000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT (";
        break;
    case 1000218001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT (";
        break;
    case 1000218002:
        settings.stream() << "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT (";
        break;
    case 1000221000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES_EXT (";
        break;
    case 1000225000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES_EXT (";
        break;
    case 1000225001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO_EXT (";
        break;
    case 1000225002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES_EXT (";
        break;
    case 1000227000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD (";
        break;
    case 1000229000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD (";
        break;
    case 1000237000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT (";
        break;
    case 1000238000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT (";
        break;
    case 1000238001:
        settings.stream() << "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT (";
        break;
    case 1000239000:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR (";
        break;
    case 1000240000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV (";
        break;
    case 1000244000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT (";
        break;
    case 1000244001:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO_EXT (";
        break;
    case 1000244002:
        settings.stream() << "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT (";
        break;
    case 1000246000:
        settings.stream() << "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO_EXT (";
        break;
    case 1000247000:
        settings.stream() << "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT (";
        break;
    case 1000249000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV (";
        break;
    case 1000249001:
        settings.stream() << "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV (";
        break;
    case 1000249002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV (";
        break;
    case 1000250000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV (";
        break;
    case 1000250001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV (";
        break;
    case 1000250002:
        settings.stream() << "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV (";
        break;
    case 1000251000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT (";
        break;
    case 1000252000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT (";
        break;
    case 1000253000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES_KHR (";
        break;
    case 1000255000:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT (";
        break;
    case 1000255002:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT (";
        break;
    case 1000255001:
        settings.stream() << "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT (";
        break;
    case 1000256000:
        settings.stream() << "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT (";
        break;
    case 1000259000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_EXT (";
        break;
    case 1000259001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_EXT (";
        break;
    case 1000259002:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_EXT (";
        break;
    case 1000261000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES_EXT (";
        break;
    case 1000265000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_EXT (";
        break;
    case 1000269000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR (";
        break;
    case 1000269001:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR (";
        break;
    case 1000269002:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR (";
        break;
    case 1000269003:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR (";
        break;
    case 1000269004:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR (";
        break;
    case 1000269005:
        settings.stream() << "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR (";
        break;
    case 1000276000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES_EXT (";
        break;
    case 1000281000:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT (";
        break;
    case 1000281001:
        settings.stream() << "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkSubpassContents(VkSubpassContents object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SUBPASS_CONTENTS_INLINE (";
        break;
    case 1:
        settings.stream() << "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDynamicState(VkDynamicState object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT (";
        break;
    case 1:
        settings.stream() << "VK_DYNAMIC_STATE_SCISSOR (";
        break;
    case 2:
        settings.stream() << "VK_DYNAMIC_STATE_LINE_WIDTH (";
        break;
    case 3:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_BIAS (";
        break;
    case 4:
        settings.stream() << "VK_DYNAMIC_STATE_BLEND_CONSTANTS (";
        break;
    case 5:
        settings.stream() << "VK_DYNAMIC_STATE_DEPTH_BOUNDS (";
        break;
    case 6:
        settings.stream() << "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK (";
        break;
    case 7:
        settings.stream() << "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK (";
        break;
    case 8:
        settings.stream() << "VK_DYNAMIC_STATE_STENCIL_REFERENCE (";
        break;
    case 1000087000:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV (";
        break;
    case 1000099000:
        settings.stream() << "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT (";
        break;
    case 1000143000:
        settings.stream() << "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT (";
        break;
    case 1000164004:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV (";
        break;
    case 1000164006:
        settings.stream() << "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV (";
        break;
    case 1000205001:
        settings.stream() << "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV (";
        break;
    case 1000259000:
        settings.stream() << "VK_DYNAMIC_STATE_LINE_STIPPLE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPolygonMode(VkPolygonMode object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_POLYGON_MODE_FILL (";
        break;
    case 1:
        settings.stream() << "VK_POLYGON_MODE_LINE (";
        break;
    case 2:
        settings.stream() << "VK_POLYGON_MODE_POINT (";
        break;
    case 1000153000:
        settings.stream() << "VK_POLYGON_MODE_FILL_RECTANGLE_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkVendorId(VkVendorId object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0x10001:
        settings.stream() << "VK_VENDOR_ID_VIV (";
        break;
    case 0x10002:
        settings.stream() << "VK_VENDOR_ID_VSI (";
        break;
    case 0x10003:
        settings.stream() << "VK_VENDOR_ID_KAZAN (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkConservativeRasterizationModeEXT(VkConservativeRasterizationModeEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT (";
        break;
    case 1:
        settings.stream() << "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT (";
        break;
    case 2:
        settings.stream() << "VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkQueryType(VkQueryType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_QUERY_TYPE_OCCLUSION (";
        break;
    case 1:
        settings.stream() << "VK_QUERY_TYPE_PIPELINE_STATISTICS (";
        break;
    case 2:
        settings.stream() << "VK_QUERY_TYPE_TIMESTAMP (";
        break;
    case 1000023008:
        settings.stream() << "VK_QUERY_TYPE_RESERVED_8 (";
        break;
    case 1000024004:
        settings.stream() << "VK_QUERY_TYPE_RESERVED_4 (";
        break;
    case 1000028004:
        settings.stream() << "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT (";
        break;
    case 1000165000:
        settings.stream() << "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV (";
        break;
    case 1000210000:
        settings.stream() << "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPerformanceConfigurationTypeINTEL(VkPerformanceConfigurationTypeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkSemaphoreTypeKHR(VkSemaphoreTypeKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_SEMAPHORE_TYPE_BINARY_KHR (";
        break;
    case 1:
        settings.stream() << "VK_SEMAPHORE_TYPE_TIMELINE_KHR (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPerformanceParameterTypeINTEL(VkPerformanceParameterTypeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPerformanceOverrideTypeINTEL(VkPerformanceOverrideTypeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkQueryPoolSamplingModeINTEL(VkQueryPoolSamplingModeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkValidationCacheHeaderVersionEXT(VkValidationCacheHeaderVersionEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 1:
        settings.stream() << "VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkFrontFace(VkFrontFace object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_FRONT_FACE_COUNTER_CLOCKWISE (";
        break;
    case 1:
        settings.stream() << "VK_FRONT_FACE_CLOCKWISE (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkDescriptorType(VkDescriptorType object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_DESCRIPTOR_TYPE_SAMPLER (";
        break;
    case 1:
        settings.stream() << "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER (";
        break;
    case 2:
        settings.stream() << "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE (";
        break;
    case 3:
        settings.stream() << "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE (";
        break;
    case 4:
        settings.stream() << "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER (";
        break;
    case 5:
        settings.stream() << "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER (";
        break;
    case 6:
        settings.stream() << "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER (";
        break;
    case 7:
        settings.stream() << "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER (";
        break;
    case 8:
        settings.stream() << "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC (";
        break;
    case 9:
        settings.stream() << "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC (";
        break;
    case 10:
        settings.stream() << "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT (";
        break;
    case 1000138000:
        settings.stream() << "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT (";
        break;
    case 1000165000:
        settings.stream() << "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}
std::ostream& dump_html_VkPerformanceValueTypeINTEL(VkPerformanceValueTypeINTEL object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    switch((int64_t) object)
    {
    case 0:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL (";
        break;
    case 1:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL (";
        break;
    case 2:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL (";
        break;
    case 3:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL (";
        break;
    case 4:
        settings.stream() << "VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL (";
        break;
    default:
        settings.stream() << "UNKNOWN (";
    }
    return settings.stream() << object << ")</div></summary>";
}

//========================= Bitmask Implementations =========================//

std::ostream& dump_html_VkDeviceQueueCreateFlagBits(VkDeviceQueueCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSparseImageFormatFlagBits(VkSparseImageFormatFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkPipelineShaderStageCreateFlagBits(VkPipelineShaderStageCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_SHADER_STAGE_CREATE_RESERVED_2_BIT_NV", settings.stream(), is_first);
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkAttachmentDescriptionFlagBits(VkAttachmentDescriptionFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkPeerMemoryFeatureFlagBits(VkPeerMemoryFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_PEER_MEMORY_FEATURE_COPY_DST_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkPipelineCompilerControlFlagBitsAMD(VkPipelineCompilerControlFlagBitsAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSamplerCreateFlagBits(VkSamplerCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkFramebufferCreateFlagBits(VkFramebufferCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkBuildAccelerationStructureFlagBitsNV(VkBuildAccelerationStructureFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_NV", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkFenceImportFlagBits(VkFenceImportFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_FENCE_IMPORT_TEMPORARY_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkExternalMemoryHandleTypeFlagBits(VkExternalMemoryHandleTypeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDeviceGroupPresentModeFlagBitsKHR(VkDeviceGroupPresentModeFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkObjectEntryUsageFlagBitsNVX(VkObjectEntryUsageFlagBitsNVX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkFormatFeatureFlagBits(VkFormatFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_BLIT_SRC_BIT", settings.stream(), is_first);
            if(object & 2048)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_BLIT_DST_BIT", settings.stream(), is_first);
            if(object & 4096)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT", settings.stream(), is_first);
            if(object & 16384)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_TRANSFER_SRC_BIT", settings.stream(), is_first);
            if(object & 32768)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_TRANSFER_DST_BIT", settings.stream(), is_first);
            if(object & 131072)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT", settings.stream(), is_first);
            if(object & 262144)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT", settings.stream(), is_first);
            if(object & 524288)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT", settings.stream(), is_first);
            if(object & 1048576)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT", settings.stream(), is_first);
            if(object & 2097152)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT", settings.stream(), is_first);
            if(object & 4194304)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_DISJOINT_BIT", settings.stream(), is_first);
            if(object & 8388608)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT", settings.stream(), is_first);
            if(object & 8192)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG", settings.stream(), is_first);
            if(object & 134217728)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_RESERVED_27_BIT_KHR", settings.stream(), is_first);
            if(object & 268435456)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_RESERVED_28_BIT_KHR", settings.stream(), is_first);
            if(object & 33554432)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_RESERVED_25_BIT_KHR", settings.stream(), is_first);
            if(object & 67108864)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_RESERVED_26_BIT_KHR", settings.stream(), is_first);
            if(object & 65536)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT", settings.stream(), is_first);
            if(object & 16777216)
                is_first = dump_html_bitmaskOption("VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkShaderModuleCreateFlagBits(VkShaderModuleCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SHADER_MODULE_CREATE_RESERVED_0_BIT_NV", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkShaderStageFlagBits(VkShaderStageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_VERTEX_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_GEOMETRY_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_FRAGMENT_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_COMPUTE_BIT", settings.stream(), is_first);
            if(object == 0x0000001F)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_ALL_GRAPHICS", settings.stream(), is_first);
            if(object == 0x7FFFFFFF)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_ALL", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_RAYGEN_BIT_NV", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_ANY_HIT_BIT_NV", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_CLOSEST_HIT_BIT_NV", settings.stream(), is_first);
            if(object & 2048)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_MISS_BIT_NV", settings.stream(), is_first);
            if(object & 4096)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_INTERSECTION_BIT_NV", settings.stream(), is_first);
            if(object & 8192)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_CALLABLE_BIT_NV", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_TASK_BIT_NV", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_SHADER_STAGE_MESH_BIT_NV", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDependencyFlagBits(VkDependencyFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DEPENDENCY_BY_REGION_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_DEPENDENCY_DEVICE_GROUP_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_DEPENDENCY_VIEW_LOCAL_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkCommandPoolCreateFlagBits(VkCommandPoolCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_COMMAND_POOL_CREATE_TRANSIENT_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_COMMAND_POOL_CREATE_PROTECTED_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkCommandBufferResetFlagBits(VkCommandBufferResetFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSwapchainCreateFlagBitsKHR(VkSwapchainCreateFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR", settings.stream(), is_first);
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkColorComponentFlagBits(VkColorComponentFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_COLOR_COMPONENT_R_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_COLOR_COMPONENT_G_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_COLOR_COMPONENT_B_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_COLOR_COMPONENT_A_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkAccessFlagBits(VkAccessFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_ACCESS_INDIRECT_COMMAND_READ_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_ACCESS_INDEX_READ_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_ACCESS_UNIFORM_READ_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_ACCESS_INPUT_ATTACHMENT_READ_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_ACCESS_SHADER_READ_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_ACCESS_SHADER_WRITE_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_ACCESS_COLOR_ATTACHMENT_READ_BIT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT", settings.stream(), is_first);
            if(object & 2048)
                is_first = dump_html_bitmaskOption("VK_ACCESS_TRANSFER_READ_BIT", settings.stream(), is_first);
            if(object & 4096)
                is_first = dump_html_bitmaskOption("VK_ACCESS_TRANSFER_WRITE_BIT", settings.stream(), is_first);
            if(object & 8192)
                is_first = dump_html_bitmaskOption("VK_ACCESS_HOST_READ_BIT", settings.stream(), is_first);
            if(object & 16384)
                is_first = dump_html_bitmaskOption("VK_ACCESS_HOST_WRITE_BIT", settings.stream(), is_first);
            if(object & 32768)
                is_first = dump_html_bitmaskOption("VK_ACCESS_MEMORY_READ_BIT", settings.stream(), is_first);
            if(object & 65536)
                is_first = dump_html_bitmaskOption("VK_ACCESS_MEMORY_WRITE_BIT", settings.stream(), is_first);
            if(object & 1073741824)
                is_first = dump_html_bitmaskOption("VK_ACCESS_RESERVED_30_BIT_KHR", settings.stream(), is_first);
            if(object & 2147483648)
                is_first = dump_html_bitmaskOption("VK_ACCESS_RESERVED_31_BIT_KHR", settings.stream(), is_first);
            if(object & 268435456)
                is_first = dump_html_bitmaskOption("VK_ACCESS_RESERVED_28_BIT_KHR", settings.stream(), is_first);
            if(object & 536870912)
                is_first = dump_html_bitmaskOption("VK_ACCESS_RESERVED_29_BIT_KHR", settings.stream(), is_first);
            if(object & 33554432)
                is_first = dump_html_bitmaskOption("VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT", settings.stream(), is_first);
            if(object & 67108864)
                is_first = dump_html_bitmaskOption("VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT", settings.stream(), is_first);
            if(object & 134217728)
                is_first = dump_html_bitmaskOption("VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT", settings.stream(), is_first);
            if(object & 1048576)
                is_first = dump_html_bitmaskOption("VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT", settings.stream(), is_first);
            if(object & 131072)
                is_first = dump_html_bitmaskOption("VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX", settings.stream(), is_first);
            if(object & 262144)
                is_first = dump_html_bitmaskOption("VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX", settings.stream(), is_first);
            if(object & 524288)
                is_first = dump_html_bitmaskOption("VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT", settings.stream(), is_first);
            if(object & 8388608)
                is_first = dump_html_bitmaskOption("VK_ACCESS_SHADING_RATE_IMAGE_READ_BIT_NV", settings.stream(), is_first);
            if(object & 2097152)
                is_first = dump_html_bitmaskOption("VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_NV", settings.stream(), is_first);
            if(object & 4194304)
                is_first = dump_html_bitmaskOption("VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_NV", settings.stream(), is_first);
            if(object & 16777216)
                is_first = dump_html_bitmaskOption("VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkExternalFenceHandleTypeFlagBits(VkExternalFenceHandleTypeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSemaphoreImportFlagBits(VkSemaphoreImportFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SEMAPHORE_IMPORT_TEMPORARY_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkBufferCreateFlagBits(VkBufferCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_BUFFER_CREATE_SPARSE_BINDING_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_BUFFER_CREATE_SPARSE_ALIASED_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_BUFFER_CREATE_PROTECTED_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkImageUsageFlagBits(VkImageUsageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_TRANSFER_SRC_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_TRANSFER_DST_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_SAMPLED_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_STORAGE_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT", settings.stream(), is_first);
            if(object & 8192)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_RESERVED_13_BIT_KHR", settings.stream(), is_first);
            if(object & 16384)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_RESERVED_14_BIT_KHR", settings.stream(), is_first);
            if(object & 32768)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_RESERVED_15_BIT_KHR", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_RESERVED_10_BIT_KHR", settings.stream(), is_first);
            if(object & 2048)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_RESERVED_11_BIT_KHR", settings.stream(), is_first);
            if(object & 4096)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_RESERVED_12_BIT_KHR", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSurfaceTransformFlagBitsKHR(VkSurfaceTransformFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkShaderCorePropertiesFlagBitsAMD(VkShaderCorePropertiesFlagBitsAMD object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkExternalMemoryHandleTypeFlagBitsNV(VkExternalMemoryHandleTypeFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkConditionalRenderingFlagBitsEXT(VkConditionalRenderingFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkMemoryHeapFlagBits(VkMemoryHeapFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_MEMORY_HEAP_DEVICE_LOCAL_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_MEMORY_HEAP_MULTI_INSTANCE_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkGeometryFlagBitsNV(VkGeometryFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_GEOMETRY_OPAQUE_BIT_NV", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_NV", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkIndirectCommandsLayoutUsageFlagBitsNVX(VkIndirectCommandsLayoutUsageFlagBitsNVX object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSampleCountFlagBits(VkSampleCountFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SAMPLE_COUNT_1_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_SAMPLE_COUNT_2_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_SAMPLE_COUNT_4_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_SAMPLE_COUNT_8_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_SAMPLE_COUNT_16_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_SAMPLE_COUNT_32_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_SAMPLE_COUNT_64_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkFenceCreateFlagBits(VkFenceCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_FENCE_CREATE_SIGNALED_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkStencilFaceFlagBits(VkStencilFaceFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_STENCIL_FACE_FRONT_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_STENCIL_FACE_BACK_BIT", settings.stream(), is_first);
            if(object == 0x00000003)
                is_first = dump_html_bitmaskOption("VK_STENCIL_FACE_FRONT_AND_BACK", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkCommandBufferUsageFlagBits(VkCommandBufferUsageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkExternalSemaphoreHandleTypeFlagBits(VkExternalSemaphoreHandleTypeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkQueueFlagBits(VkQueueFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_QUEUE_GRAPHICS_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_QUEUE_COMPUTE_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_QUEUE_TRANSFER_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_QUEUE_SPARSE_BINDING_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_QUEUE_PROTECTED_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_QUEUE_RESERVED_6_BIT_KHR", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_QUEUE_RESERVED_5_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkCompositeAlphaFlagBitsKHR(VkCompositeAlphaFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDebugUtilsMessageSeverityFlagBitsEXT(VkDebugUtilsMessageSeverityFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT", settings.stream(), is_first);
            if(object & 4096)
                is_first = dump_html_bitmaskOption("VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkBufferUsageFlagBits(VkBufferUsageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_TRANSFER_SRC_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_TRANSFER_DST_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_STORAGE_BUFFER_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_INDEX_BUFFER_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_VERTEX_BUFFER_BIT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT", settings.stream(), is_first);
            if(object & 32768)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_RESERVED_15_BIT_KHR", settings.stream(), is_first);
            if(object & 65536)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_RESERVED_16_BIT_KHR", settings.stream(), is_first);
            if(object & 8192)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_RESERVED_13_BIT_KHR", settings.stream(), is_first);
            if(object & 16384)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_RESERVED_14_BIT_KHR", settings.stream(), is_first);
            if(object & 2048)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT", settings.stream(), is_first);
            if(object & 4096)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_RAY_TRACING_BIT_NV", settings.stream(), is_first);
            if(object & 131072)
                is_first = dump_html_bitmaskOption("VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkResolveModeFlagBitsKHR(VkResolveModeFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object == 0)
                is_first = dump_html_bitmaskOption("VK_RESOLVE_MODE_NONE_KHR", settings.stream(), is_first);
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_RESOLVE_MODE_SAMPLE_ZERO_BIT_KHR", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_RESOLVE_MODE_AVERAGE_BIT_KHR", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_RESOLVE_MODE_MIN_BIT_KHR", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_RESOLVE_MODE_MAX_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkExternalFenceFeatureFlagBits(VkExternalFenceFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkImageViewCreateFlagBits(VkImageViewCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkExternalMemoryFeatureFlagBits(VkExternalMemoryFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDebugReportFlagBitsEXT(VkDebugReportFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DEBUG_REPORT_INFORMATION_BIT_EXT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_DEBUG_REPORT_WARNING_BIT_EXT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_DEBUG_REPORT_ERROR_BIT_EXT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_DEBUG_REPORT_DEBUG_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDisplayPlaneAlphaFlagBitsKHR(VkDisplayPlaneAlphaFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkCommandPoolResetFlagBits(VkCommandPoolResetFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkExternalMemoryFeatureFlagBitsNV(VkExternalMemoryFeatureFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDescriptorSetLayoutCreateFlagBits(VkDescriptorSetLayoutCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkImageAspectFlagBits(VkImageAspectFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_COLOR_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_DEPTH_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_STENCIL_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_METADATA_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_PLANE_0_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_PLANE_1_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_PLANE_2_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkCullModeFlagBits(VkCullModeFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object == 0)
                is_first = dump_html_bitmaskOption("VK_CULL_MODE_NONE", settings.stream(), is_first);
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_CULL_MODE_FRONT_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_CULL_MODE_BACK_BIT", settings.stream(), is_first);
            if(object == 0x00000003)
                is_first = dump_html_bitmaskOption("VK_CULL_MODE_FRONT_AND_BACK", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSubpassDescriptionFlagBits(VkSubpassDescriptionFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_SUBPASS_DESCRIPTION_RESERVED_2_BIT_QCOM", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_SUBPASS_DESCRIPTION_RESERVED_3_BIT_QCOM", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkQueryControlFlagBits(VkQueryControlFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_QUERY_CONTROL_PRECISE_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkExternalSemaphoreFeatureFlagBits(VkExternalSemaphoreFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkQueryPipelineStatisticFlagBits(VkQueryPipelineStatisticFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkPipelineCreateFlagBits(VkPipelineCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATE_DERIVATIVE_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATE_DISPATCH_BASE", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDescriptorPoolCreateFlagBits(VkDescriptorPoolCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkRenderPassCreateFlagBits(VkRenderPassCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_RENDER_PASS_CREATE_RESERVED_0_BIT_KHR", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_RENDER_PASS_RESERVED_BIT_1_QCOM", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkMemoryAllocateFlagBits(VkMemoryAllocateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDescriptorBindingFlagBitsEXT(VkDescriptorBindingFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkGeometryInstanceFlagBitsNV(VkGeometryInstanceFlagBitsNV object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_GEOMETRY_INSTANCE_TRIANGLE_CULL_DISABLE_BIT_NV", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_GEOMETRY_INSTANCE_TRIANGLE_FRONT_COUNTERCLOCKWISE_BIT_NV", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_NV", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_NV", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSubgroupFeatureFlagBits(VkSubgroupFeatureFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_BASIC_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_VOTE_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_ARITHMETIC_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_BALLOT_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_SHUFFLE_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_CLUSTERED_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_QUAD_BIT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSemaphoreWaitFlagBitsKHR(VkSemaphoreWaitFlagBitsKHR object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SEMAPHORE_WAIT_ANY_BIT_KHR", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkQueryResultFlagBits(VkQueryResultFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_QUERY_RESULT_64_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_QUERY_RESULT_WAIT_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_QUERY_RESULT_WITH_AVAILABILITY_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_QUERY_RESULT_PARTIAL_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkPipelineCreationFeedbackFlagBitsEXT(VkPipelineCreationFeedbackFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT_EXT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT_EXT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSparseMemoryBindFlagBits(VkSparseMemoryBindFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SPARSE_MEMORY_BIND_METADATA_BIT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkDebugUtilsMessageTypeFlagBitsEXT(VkDebugUtilsMessageTypeFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkSurfaceCounterFlagBitsEXT(VkSurfaceCounterFlagBitsEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_SURFACE_COUNTER_VBLANK_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkImageCreateFlagBits(VkImageCreateFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_SPARSE_BINDING_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_SPARSE_ALIASED_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_ALIAS_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_EXTENDED_USAGE_BIT", settings.stream(), is_first);
            if(object & 2048)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_PROTECTED_BIT", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_DISJOINT_BIT", settings.stream(), is_first);
            if(object & 8192)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV", settings.stream(), is_first);
            if(object & 4096)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT", settings.stream(), is_first);
            if(object & 16384)
                is_first = dump_html_bitmaskOption("VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkPipelineStageFlagBits(VkPipelineStageFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_VERTEX_INPUT_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_VERTEX_SHADER_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT", settings.stream(), is_first);
            if(object & 256)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT", settings.stream(), is_first);
            if(object & 512)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT", settings.stream(), is_first);
            if(object & 1024)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT", settings.stream(), is_first);
            if(object & 2048)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT", settings.stream(), is_first);
            if(object & 4096)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_TRANSFER_BIT", settings.stream(), is_first);
            if(object & 8192)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT", settings.stream(), is_first);
            if(object & 16384)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_HOST_BIT", settings.stream(), is_first);
            if(object & 32768)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT", settings.stream(), is_first);
            if(object & 65536)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_ALL_COMMANDS_BIT", settings.stream(), is_first);
            if(object & 134217728)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_RESERVED_27_BIT_KHR", settings.stream(), is_first);
            if(object & 67108864)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_RESERVED_26_BIT_KHR", settings.stream(), is_first);
            if(object & 16777216)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT", settings.stream(), is_first);
            if(object & 262144)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT", settings.stream(), is_first);
            if(object & 131072)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX", settings.stream(), is_first);
            if(object & 4194304)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_SHADING_RATE_IMAGE_BIT_NV", settings.stream(), is_first);
            if(object & 2097152)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_NV", settings.stream(), is_first);
            if(object & 33554432)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_NV", settings.stream(), is_first);
            if(object & 524288)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_TASK_SHADER_BIT_NV", settings.stream(), is_first);
            if(object & 1048576)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_MESH_SHADER_BIT_NV", settings.stream(), is_first);
            if(object & 8388608)
                is_first = dump_html_bitmaskOption("VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}
std::ostream& dump_html_VkMemoryPropertyFlagBits(VkMemoryPropertyFlagBits object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    bool is_first = true;
    settings.stream() << object;
            if(object & 1)
                is_first = dump_html_bitmaskOption("VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT", settings.stream(), is_first);
            if(object & 2)
                is_first = dump_html_bitmaskOption("VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT", settings.stream(), is_first);
            if(object & 4)
                is_first = dump_html_bitmaskOption("VK_MEMORY_PROPERTY_HOST_COHERENT_BIT", settings.stream(), is_first);
            if(object & 8)
                is_first = dump_html_bitmaskOption("VK_MEMORY_PROPERTY_HOST_CACHED_BIT", settings.stream(), is_first);
            if(object & 16)
                is_first = dump_html_bitmaskOption("VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT", settings.stream(), is_first);
            if(object & 32)
                is_first = dump_html_bitmaskOption("VK_MEMORY_PROPERTY_PROTECTED_BIT", settings.stream(), is_first);
            if(object & 64)
                is_first = dump_html_bitmaskOption("VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD", settings.stream(), is_first);
            if(object & 128)
                is_first = dump_html_bitmaskOption("VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD", settings.stream(), is_first);
    if(!is_first)
        settings.stream() << ")";
    return settings.stream() << "</div></summary>";
}

//=========================== Flag Implementations ==========================//

inline std::ostream& dump_html_VkPipelineShaderStageCreateFlags(VkPipelineShaderStageCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkPipelineShaderStageCreateFlagBits((VkPipelineShaderStageCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkAttachmentDescriptionFlags(VkAttachmentDescriptionFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkAttachmentDescriptionFlagBits((VkAttachmentDescriptionFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkFormatFeatureFlags(VkFormatFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkFormatFeatureFlagBits((VkFormatFeatureFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkShaderModuleCreateFlags(VkShaderModuleCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkShaderModuleCreateFlagBits((VkShaderModuleCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkDependencyFlags(VkDependencyFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDependencyFlagBits((VkDependencyFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkMemoryHeapFlags(VkMemoryHeapFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkMemoryHeapFlagBits((VkMemoryHeapFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSubpassDescriptionFlags(VkSubpassDescriptionFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSubpassDescriptionFlagBits((VkSubpassDescriptionFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSurfaceTransformFlagsKHR(VkSurfaceTransformFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSurfaceTransformFlagBitsKHR((VkSurfaceTransformFlagBitsKHR) object, settings, indents);
}
inline std::ostream& dump_html_VkStencilFaceFlags(VkStencilFaceFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkStencilFaceFlagBits((VkStencilFaceFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkPipelineCompilerControlFlagsAMD(VkPipelineCompilerControlFlagsAMD object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkPipelineCompilerControlFlagBitsAMD((VkPipelineCompilerControlFlagBitsAMD) object, settings, indents);
}
inline std::ostream& dump_html_VkCommandBufferUsageFlags(VkCommandBufferUsageFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkCommandBufferUsageFlagBits((VkCommandBufferUsageFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkGeometryFlagsNV(VkGeometryFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkGeometryFlagBitsNV((VkGeometryFlagBitsNV) object, settings, indents);
}
inline std::ostream& dump_html_VkSwapchainCreateFlagsKHR(VkSwapchainCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSwapchainCreateFlagBitsKHR((VkSwapchainCreateFlagBitsKHR) object, settings, indents);
}
inline std::ostream& dump_html_VkSampleCountFlags(VkSampleCountFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSampleCountFlagBits((VkSampleCountFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkDisplayPlaneAlphaFlagsKHR(VkDisplayPlaneAlphaFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDisplayPlaneAlphaFlagBitsKHR((VkDisplayPlaneAlphaFlagBitsKHR) object, settings, indents);
}
inline std::ostream& dump_html_VkQueryResultFlags(VkQueryResultFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkQueryResultFlagBits((VkQueryResultFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkImageAspectFlags(VkImageAspectFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkImageAspectFlagBits((VkImageAspectFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkCompositeAlphaFlagsKHR(VkCompositeAlphaFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkCompositeAlphaFlagBitsKHR((VkCompositeAlphaFlagBitsKHR) object, settings, indents);
}
inline std::ostream& dump_html_VkQueryControlFlags(VkQueryControlFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkQueryControlFlagBits((VkQueryControlFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkDescriptorBindingFlagsEXT(VkDescriptorBindingFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDescriptorBindingFlagBitsEXT((VkDescriptorBindingFlagBitsEXT) object, settings, indents);
}
inline std::ostream& dump_html_VkGeometryInstanceFlagsNV(VkGeometryInstanceFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkGeometryInstanceFlagBitsNV((VkGeometryInstanceFlagBitsNV) object, settings, indents);
}
inline std::ostream& dump_html_VkDeviceQueueCreateFlags(VkDeviceQueueCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDeviceQueueCreateFlagBits((VkDeviceQueueCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkPipelineStageFlags(VkPipelineStageFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkPipelineStageFlagBits((VkPipelineStageFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSparseImageFormatFlags(VkSparseImageFormatFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSparseImageFormatFlagBits((VkSparseImageFormatFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkAccessFlags(VkAccessFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkAccessFlagBits((VkAccessFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkBuildAccelerationStructureFlagsNV(VkBuildAccelerationStructureFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkBuildAccelerationStructureFlagBitsNV((VkBuildAccelerationStructureFlagBitsNV) object, settings, indents);
}
inline std::ostream& dump_html_VkCommandPoolCreateFlags(VkCommandPoolCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkCommandPoolCreateFlagBits((VkCommandPoolCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkExternalMemoryHandleTypeFlags(VkExternalMemoryHandleTypeFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkExternalMemoryHandleTypeFlagBits((VkExternalMemoryHandleTypeFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkShaderCorePropertiesFlagsAMD(VkShaderCorePropertiesFlagsAMD object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkShaderCorePropertiesFlagBitsAMD((VkShaderCorePropertiesFlagBitsAMD) object, settings, indents);
}
inline std::ostream& dump_html_VkCommandBufferResetFlags(VkCommandBufferResetFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkCommandBufferResetFlagBits((VkCommandBufferResetFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkQueueFlags(VkQueueFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkQueueFlagBits((VkQueueFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkBufferCreateFlags(VkBufferCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkBufferCreateFlagBits((VkBufferCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkExternalFenceHandleTypeFlags(VkExternalFenceHandleTypeFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkExternalFenceHandleTypeFlagBits((VkExternalFenceHandleTypeFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkDeviceGroupPresentModeFlagsKHR(VkDeviceGroupPresentModeFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDeviceGroupPresentModeFlagBitsKHR((VkDeviceGroupPresentModeFlagBitsKHR) object, settings, indents);
}
inline std::ostream& dump_html_VkImageUsageFlags(VkImageUsageFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkImageUsageFlagBits((VkImageUsageFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkBufferUsageFlags(VkBufferUsageFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkBufferUsageFlagBits((VkBufferUsageFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkShaderStageFlags(VkShaderStageFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkShaderStageFlagBits((VkShaderStageFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkExternalFenceFeatureFlags(VkExternalFenceFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkExternalFenceFeatureFlagBits((VkExternalFenceFeatureFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkExternalMemoryFeatureFlags(VkExternalMemoryFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkExternalMemoryFeatureFlagBits((VkExternalMemoryFeatureFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkDebugReportFlagsEXT(VkDebugReportFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDebugReportFlagBitsEXT((VkDebugReportFlagBitsEXT) object, settings, indents);
}
inline std::ostream& dump_html_VkPipelineCreateFlags(VkPipelineCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkPipelineCreateFlagBits((VkPipelineCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkMemoryPropertyFlags(VkMemoryPropertyFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkMemoryPropertyFlagBits((VkMemoryPropertyFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkCommandPoolResetFlags(VkCommandPoolResetFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkCommandPoolResetFlagBits((VkCommandPoolResetFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSparseMemoryBindFlags(VkSparseMemoryBindFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSparseMemoryBindFlagBits((VkSparseMemoryBindFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkImageCreateFlags(VkImageCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkImageCreateFlagBits((VkImageCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSurfaceCounterFlagsEXT(VkSurfaceCounterFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSurfaceCounterFlagBitsEXT((VkSurfaceCounterFlagBitsEXT) object, settings, indents);
}
inline std::ostream& dump_html_VkQueryPipelineStatisticFlags(VkQueryPipelineStatisticFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkQueryPipelineStatisticFlagBits((VkQueryPipelineStatisticFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSamplerCreateFlags(VkSamplerCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSamplerCreateFlagBits((VkSamplerCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkFenceImportFlags(VkFenceImportFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkFenceImportFlagBits((VkFenceImportFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSemaphoreImportFlags(VkSemaphoreImportFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSemaphoreImportFlagBits((VkSemaphoreImportFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkExternalSemaphoreHandleTypeFlags(VkExternalSemaphoreHandleTypeFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkExternalSemaphoreHandleTypeFlagBits((VkExternalSemaphoreHandleTypeFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkExternalMemoryHandleTypeFlagsNV(VkExternalMemoryHandleTypeFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkExternalMemoryHandleTypeFlagBitsNV((VkExternalMemoryHandleTypeFlagBitsNV) object, settings, indents);
}
inline std::ostream& dump_html_VkIndirectCommandsLayoutUsageFlagsNVX(VkIndirectCommandsLayoutUsageFlagsNVX object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkIndirectCommandsLayoutUsageFlagBitsNVX((VkIndirectCommandsLayoutUsageFlagBitsNVX) object, settings, indents);
}
inline std::ostream& dump_html_VkExternalMemoryFeatureFlagsNV(VkExternalMemoryFeatureFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkExternalMemoryFeatureFlagBitsNV((VkExternalMemoryFeatureFlagBitsNV) object, settings, indents);
}
inline std::ostream& dump_html_VkColorComponentFlags(VkColorComponentFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkColorComponentFlagBits((VkColorComponentFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkConditionalRenderingFlagsEXT(VkConditionalRenderingFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkConditionalRenderingFlagBitsEXT((VkConditionalRenderingFlagBitsEXT) object, settings, indents);
}
inline std::ostream& dump_html_VkObjectEntryUsageFlagsNVX(VkObjectEntryUsageFlagsNVX object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkObjectEntryUsageFlagBitsNVX((VkObjectEntryUsageFlagBitsNVX) object, settings, indents);
}
inline std::ostream& dump_html_VkImageViewCreateFlags(VkImageViewCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkImageViewCreateFlagBits((VkImageViewCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkExternalSemaphoreFeatureFlags(VkExternalSemaphoreFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkExternalSemaphoreFeatureFlagBits((VkExternalSemaphoreFeatureFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSemaphoreWaitFlagsKHR(VkSemaphoreWaitFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSemaphoreWaitFlagBitsKHR((VkSemaphoreWaitFlagBitsKHR) object, settings, indents);
}
inline std::ostream& dump_html_VkResolveModeFlagsKHR(VkResolveModeFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkResolveModeFlagBitsKHR((VkResolveModeFlagBitsKHR) object, settings, indents);
}
inline std::ostream& dump_html_VkDescriptorPoolCreateFlags(VkDescriptorPoolCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDescriptorPoolCreateFlagBits((VkDescriptorPoolCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkPipelineCreationFeedbackFlagsEXT(VkPipelineCreationFeedbackFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkPipelineCreationFeedbackFlagBitsEXT((VkPipelineCreationFeedbackFlagBitsEXT) object, settings, indents);
}
inline std::ostream& dump_html_VkFramebufferCreateFlags(VkFramebufferCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkFramebufferCreateFlagBits((VkFramebufferCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkFenceCreateFlags(VkFenceCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkFenceCreateFlagBits((VkFenceCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkPeerMemoryFeatureFlags(VkPeerMemoryFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkPeerMemoryFeatureFlagBits((VkPeerMemoryFeatureFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkMemoryAllocateFlags(VkMemoryAllocateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkMemoryAllocateFlagBits((VkMemoryAllocateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkDebugUtilsMessageSeverityFlagsEXT(VkDebugUtilsMessageSeverityFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDebugUtilsMessageSeverityFlagBitsEXT((VkDebugUtilsMessageSeverityFlagBitsEXT) object, settings, indents);
}
inline std::ostream& dump_html_VkCullModeFlags(VkCullModeFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkCullModeFlagBits((VkCullModeFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkSubgroupFeatureFlags(VkSubgroupFeatureFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkSubgroupFeatureFlagBits((VkSubgroupFeatureFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkDescriptorSetLayoutCreateFlags(VkDescriptorSetLayoutCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDescriptorSetLayoutCreateFlagBits((VkDescriptorSetLayoutCreateFlagBits) object, settings, indents);
}
inline std::ostream& dump_html_VkDebugUtilsMessageTypeFlagsEXT(VkDebugUtilsMessageTypeFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkDebugUtilsMessageTypeFlagBitsEXT((VkDebugUtilsMessageTypeFlagBitsEXT) object, settings, indents);
}
inline std::ostream& dump_html_VkRenderPassCreateFlags(VkRenderPassCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return dump_html_VkRenderPassCreateFlagBits((VkRenderPassCreateFlagBits) object, settings, indents);
}


inline std::ostream& dump_html_VkInstanceCreateFlags(VkInstanceCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkDescriptorUpdateTemplateCreateFlags(VkDescriptorUpdateTemplateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineRasterizationStateStreamCreateFlagsEXT(VkPipelineRasterizationStateStreamCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineRasterizationDepthClipStateCreateFlagsEXT(VkPipelineRasterizationDepthClipStateCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkHeadlessSurfaceCreateFlagsEXT(VkHeadlessSurfaceCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineCoverageReductionStateCreateFlagsNV(VkPipelineCoverageReductionStateCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineCacheCreateFlags(VkPipelineCacheCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineMultisampleStateCreateFlags(VkPipelineMultisampleStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkBufferViewCreateFlags(VkBufferViewCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkDeviceCreateFlags(VkDeviceCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineDepthStencilStateCreateFlags(VkPipelineDepthStencilStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkMemoryMapFlags(VkMemoryMapFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineViewportSwizzleStateCreateFlagsNV(VkPipelineViewportSwizzleStateCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
inline std::ostream& dump_html_VkXlibSurfaceCreateFlagsKHR(VkXlibSurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
inline std::ostream& dump_html_VkPipelineVertexInputStateCreateFlags(VkPipelineVertexInputStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineLayoutCreateFlags(VkPipelineLayoutCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
inline std::ostream& dump_html_VkIOSSurfaceCreateFlagsMVK(VkIOSSurfaceCreateFlagsMVK object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_IOS_MVK
inline std::ostream& dump_html_VkCommandPoolTrimFlags(VkCommandPoolTrimFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkDisplayModeCreateFlagsKHR(VkDisplayModeCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_GGP)
inline std::ostream& dump_html_VkStreamDescriptorSurfaceCreateFlagsGGP(VkStreamDescriptorSurfaceCreateFlagsGGP object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_GGP
inline std::ostream& dump_html_VkPipelineInputAssemblyStateCreateFlags(VkPipelineInputAssemblyStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
inline std::ostream& dump_html_VkWin32SurfaceCreateFlagsKHR(VkWin32SurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_MACOS_MVK)
inline std::ostream& dump_html_VkMacOSSurfaceCreateFlagsMVK(VkMacOSSurfaceCreateFlagsMVK object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_MACOS_MVK
#if defined(VK_USE_PLATFORM_XCB_KHR)
inline std::ostream& dump_html_VkXcbSurfaceCreateFlagsKHR(VkXcbSurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
inline std::ostream& dump_html_VkDisplaySurfaceCreateFlagsKHR(VkDisplaySurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineColorBlendStateCreateFlags(VkPipelineColorBlendStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_VI_NN)
inline std::ostream& dump_html_VkViSurfaceCreateFlagsNN(VkViSurfaceCreateFlagsNN object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_VI_NN
inline std::ostream& dump_html_VkSemaphoreCreateFlags(VkSemaphoreCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineTessellationStateCreateFlags(VkPipelineTessellationStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineCoverageToColorStateCreateFlagsNV(VkPipelineCoverageToColorStateCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineViewportStateCreateFlags(VkPipelineViewportStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkEventCreateFlags(VkEventCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineDiscardRectangleStateCreateFlagsEXT(VkPipelineDiscardRectangleStateCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
inline std::ostream& dump_html_VkImagePipeSurfaceCreateFlagsFUCHSIA(VkImagePipeSurfaceCreateFlagsFUCHSIA object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
inline std::ostream& dump_html_VkWaylandSurfaceCreateFlagsKHR(VkWaylandSurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
inline std::ostream& dump_html_VkDebugUtilsMessengerCallbackDataFlagsEXT(VkDebugUtilsMessengerCallbackDataFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineCoverageModulationStateCreateFlagsNV(VkPipelineCoverageModulationStateCreateFlagsNV object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
inline std::ostream& dump_html_VkAndroidSurfaceCreateFlagsKHR(VkAndroidSurfaceCreateFlagsKHR object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
inline std::ostream& dump_html_VkPipelineDynamicStateCreateFlags(VkPipelineDynamicStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkDescriptorPoolResetFlags(VkDescriptorPoolResetFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
inline std::ostream& dump_html_VkMetalSurfaceCreateFlagsEXT(VkMetalSurfaceCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
inline std::ostream& dump_html_VkPipelineRasterizationStateCreateFlags(VkPipelineRasterizationStateCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkQueryPoolCreateFlags(VkQueryPoolCreateFlags object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkDebugUtilsMessengerCreateFlagsEXT(VkDebugUtilsMessengerCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkValidationCacheCreateFlagsEXT(VkValidationCacheCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}
inline std::ostream& dump_html_VkPipelineRasterizationConservativeStateCreateFlagsEXT(VkPipelineRasterizationConservativeStateCreateFlagsEXT object, const ApiDumpSettings& settings, int indents)
{
    return settings.stream() << "<div class='val'>"
                             << object << "</div></summary>";
}

//======================= Func Pointer Implementations ======================//

inline std::ostream& dump_html_PFN_vkVoidFunction(PFN_vkVoidFunction object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_PFN_vkDebugReportCallbackEXT(PFN_vkDebugReportCallbackEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_PFN_vkDebugUtilsMessengerCallbackEXT(PFN_vkDebugUtilsMessengerCallbackEXT object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_PFN_vkInternalAllocationNotification(PFN_vkInternalAllocationNotification object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_PFN_vkAllocationFunction(PFN_vkAllocationFunction object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_PFN_vkReallocationFunction(PFN_vkReallocationFunction object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_PFN_vkInternalFreeNotification(PFN_vkInternalFreeNotification object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    return settings.stream() << "</div></summary>";
}
inline std::ostream& dump_html_PFN_vkFreeFunction(PFN_vkFreeFunction object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << object;
    else
        settings.stream() << "address";
    return settings.stream() << "</div></summary>";
}

//========================== Struct Implementations =========================//

std::ostream& dump_html_VkMemoryRequirements(const VkMemoryRequirements& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.alignment, settings, "VkDeviceSize", "alignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceQueueGlobalPriorityCreateInfoEXT(const VkDeviceQueueGlobalPriorityCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueueGlobalPriorityEXT>(object.globalPriority, settings, "VkQueueGlobalPriorityEXT", "globalPriority", indents + 1, dump_html_VkQueueGlobalPriorityEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPresentTimeGOOGLE(const VkPresentTimeGOOGLE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.presentID, settings, "uint32_t", "presentID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.desiredPresentTime, settings, "uint64_t", "desiredPresentTime", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkRenderPassFragmentDensityMapCreateInfoEXT(const VkRenderPassFragmentDensityMapCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAttachmentReference>(object.fragmentDensityMapAttachment, settings, "VkAttachmentReference", "fragmentDensityMapAttachment", indents + 1, dump_html_VkAttachmentReference);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceCoverageReductionModeFeaturesNV(const VkPhysicalDeviceCoverageReductionModeFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.coverageReductionMode, settings, "VkBool32", "coverageReductionMode", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPerformanceValueINTEL(const VkPerformanceValueINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkPerformanceValueTypeINTEL>(object.type, settings, "VkPerformanceValueTypeINTEL", "type", indents + 1, dump_html_VkPerformanceValueTypeINTEL);
    dump_html_value<const VkPerformanceValueDataINTEL>(object.data, settings, "VkPerformanceValueDataINTEL", "data", indents + 1, dump_html_VkPerformanceValueDataINTEL);
    return settings.stream();
}
std::ostream& dump_html_VkImageStencilUsageCreateInfoEXT(const VkImageStencilUsageCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageUsageFlags>(object.stencilUsage, settings, "VkImageUsageFlags", "stencilUsage", indents + 1, dump_html_VkImageUsageFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPresentInfoKHR(const VkPresentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreCount, settings, "uint32_t", "waitSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pWaitSemaphores, object.waitSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pWaitSemaphores", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSwapchainKHR>(object.pSwapchains, object.swapchainCount, settings, "const VkSwapchainKHR*", "const VkSwapchainKHR", "pSwapchains", indents + 1, dump_html_VkSwapchainKHR);
    dump_html_array<const uint32_t>(object.pImageIndices, object.swapchainCount, settings, "const uint32_t*", "const uint32_t", "pImageIndices", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkResult>(object.pResults, object.swapchainCount, settings, "VkResult*", "VkResult", "pResults", indents + 1, dump_html_VkResult);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderClockFeaturesKHR(const VkPhysicalDeviceShaderClockFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderSubgroupClock, settings, "VkBool32", "shaderSubgroupClock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDeviceClock, settings, "VkBool32", "shaderDeviceClock", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkValidationFeaturesEXT(const VkValidationFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.enabledValidationFeatureCount, settings, "uint32_t", "enabledValidationFeatureCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkValidationFeatureEnableEXT>(object.pEnabledValidationFeatures, object.enabledValidationFeatureCount, settings, "const VkValidationFeatureEnableEXT*", "const VkValidationFeatureEnableEXT", "pEnabledValidationFeatures", indents + 1, dump_html_VkValidationFeatureEnableEXT);
    dump_html_value<const uint32_t>(object.disabledValidationFeatureCount, settings, "uint32_t", "disabledValidationFeatureCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkValidationFeatureDisableEXT>(object.pDisabledValidationFeatures, object.disabledValidationFeatureCount, settings, "const VkValidationFeatureDisableEXT*", "const VkValidationFeatureDisableEXT", "pDisabledValidationFeatures", indents + 1, dump_html_VkValidationFeatureDisableEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPresentTimesInfoGOOGLE(const VkPresentTimesInfoGOOGLE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPresentTimeGOOGLE>(object.pTimes, object.swapchainCount, settings, "const VkPresentTimeGOOGLE*", "const VkPresentTimeGOOGLE", "pTimes", indents + 1, dump_html_VkPresentTimeGOOGLE);
    return settings.stream();
}
std::ostream& dump_html_VkFilterCubicImageViewImageFormatPropertiesEXT(const VkFilterCubicImageViewImageFormatPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.filterCubic, settings, "VkBool32", "filterCubic", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.filterCubicMinmax, settings, "VkBool32", "filterCubicMinmax", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkInitializePerformanceApiInfoINTEL(const VkInitializePerformanceApiInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkLayerProperties(const VkLayerProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const char*>(object.layerName, settings, "char[VK_MAX_EXTENSION_NAME_SIZE]", "layerName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.specVersion, settings, "uint32_t", "specVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.implementationVersion, settings, "uint32_t", "implementationVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    return settings.stream();
}
std::ostream& dump_html_VkFramebufferMixedSamplesCombinationNV(const VkFramebufferMixedSamplesCombinationNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCoverageReductionModeNV>(object.coverageReductionMode, settings, "VkCoverageReductionModeNV", "coverageReductionMode", indents + 1, dump_html_VkCoverageReductionModeNV);
    dump_html_value<const VkSampleCountFlagBits>(object.rasterizationSamples, settings, "VkSampleCountFlagBits", "rasterizationSamples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkSampleCountFlags>(object.depthStencilSamples, settings, "VkSampleCountFlags", "depthStencilSamples", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.colorSamples, settings, "VkSampleCountFlags", "colorSamples", indents + 1, dump_html_VkSampleCountFlags);
    return settings.stream();
}
std::ostream& dump_html_VkImageFormatProperties(const VkImageFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkExtent3D>(object.maxExtent, settings, "VkExtent3D", "maxExtent", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const uint32_t>(object.maxMipLevels, settings, "uint32_t", "maxMipLevels", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxArrayLayers, settings, "uint32_t", "maxArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlags>(object.sampleCounts, settings, "VkSampleCountFlags", "sampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkDeviceSize>(object.maxResourceSize, settings, "VkDeviceSize", "maxResourceSize", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSurfaceInfo2KHR(const VkPhysicalDeviceSurfaceInfo2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceKHR>(object.surface, settings, "VkSurfaceKHR", "surface", indents + 1, dump_html_VkSurfaceKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineCompilerControlCreateInfoAMD(const VkPipelineCompilerControlCreateInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCompilerControlFlagsAMD>(object.compilerControlFlags, settings, "VkPipelineCompilerControlFlagsAMD", "compilerControlFlags", indents + 1, dump_html_VkPipelineCompilerControlFlagsAMD);
    return settings.stream();
}
std::ostream& dump_html_VkExtent3D(const VkExtent3D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.depth, settings, "uint32_t", "depth", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR(const VkPhysicalDeviceShaderSubgroupExtendedTypesFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderSubgroupExtendedTypes, settings, "VkBool32", "shaderSubgroupExtendedTypes", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceScalarBlockLayoutFeaturesEXT(const VkPhysicalDeviceScalarBlockLayoutFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.scalarBlockLayout, settings, "VkBool32", "scalarBlockLayout", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkImageSwapchainCreateInfoKHR(const VkImageSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainKHR>(object.swapchain, settings, "VkSwapchainKHR", "swapchain", indents + 1, dump_html_VkSwapchainKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineCoverageReductionStateCreateInfoNV(const VkPipelineCoverageReductionStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCoverageReductionStateCreateFlagsNV>(object.flags, settings, "VkPipelineCoverageReductionStateCreateFlagsNV", "flags", indents + 1, dump_html_VkPipelineCoverageReductionStateCreateFlagsNV);
    dump_html_value<const VkCoverageReductionModeNV>(object.coverageReductionMode, settings, "VkCoverageReductionModeNV", "coverageReductionMode", indents + 1, dump_html_VkCoverageReductionModeNV);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSubgroupSizeControlPropertiesEXT(const VkPhysicalDeviceSubgroupSizeControlPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.minSubgroupSize, settings, "uint32_t", "minSubgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSubgroupSize, settings, "uint32_t", "maxSubgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxComputeWorkgroupSubgroups, settings, "uint32_t", "maxComputeWorkgroupSubgroups", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkShaderStageFlags>(object.requiredSubgroupSizeStages, settings, "VkShaderStageFlags", "requiredSubgroupSizeStages", indents + 1, dump_html_VkShaderStageFlags);
    return settings.stream();
}
std::ostream& dump_html_VkCooperativeMatrixPropertiesNV(const VkCooperativeMatrixPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.MSize, settings, "uint32_t", "MSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.NSize, settings, "uint32_t", "NSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.KSize, settings, "uint32_t", "KSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkComponentTypeNV>(object.AType, settings, "VkComponentTypeNV", "AType", indents + 1, dump_html_VkComponentTypeNV);
    dump_html_value<const VkComponentTypeNV>(object.BType, settings, "VkComponentTypeNV", "BType", indents + 1, dump_html_VkComponentTypeNV);
    dump_html_value<const VkComponentTypeNV>(object.CType, settings, "VkComponentTypeNV", "CType", indents + 1, dump_html_VkComponentTypeNV);
    dump_html_value<const VkComponentTypeNV>(object.DType, settings, "VkComponentTypeNV", "DType", indents + 1, dump_html_VkComponentTypeNV);
    dump_html_value<const VkScopeNV>(object.scope, settings, "VkScopeNV", "scope", indents + 1, dump_html_VkScopeNV);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryAllocateInfo(const VkMemoryAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.allocationSize, settings, "VkDeviceSize", "allocationSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.memoryTypeIndex, settings, "uint32_t", "memoryTypeIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceCoherentMemoryFeaturesAMD(const VkPhysicalDeviceCoherentMemoryFeaturesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.deviceCoherentMemory, settings, "VkBool32", "deviceCoherentMemory", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSparseImageMemoryRequirements(const VkSparseImageMemoryRequirements& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkSparseImageFormatProperties>(object.formatProperties, settings, "VkSparseImageFormatProperties", "formatProperties", indents + 1, dump_html_VkSparseImageFormatProperties);
    dump_html_value<const uint32_t>(object.imageMipTailFirstLod, settings, "uint32_t", "imageMipTailFirstLod", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.imageMipTailSize, settings, "VkDeviceSize", "imageMipTailSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.imageMipTailOffset, settings, "VkDeviceSize", "imageMipTailOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.imageMipTailStride, settings, "VkDeviceSize", "imageMipTailStride", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkQueryPoolCreateInfoINTEL(const VkQueryPoolCreateInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueryPoolSamplingModeINTEL>(object.performanceCountersSampling, settings, "VkQueryPoolSamplingModeINTEL", "performanceCountersSampling", indents + 1, dump_html_VkQueryPoolSamplingModeINTEL);
    return settings.stream();
}
std::ostream& dump_html_VkSparseImageFormatProperties(const VkSparseImageFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const VkExtent3D>(object.imageGranularity, settings, "VkExtent3D", "imageGranularity", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const VkSparseImageFormatFlags>(object.flags, settings, "VkSparseImageFormatFlags", "flags", indents + 1, dump_html_VkSparseImageFormatFlags);
    return settings.stream();
}
std::ostream& dump_html_VkAcquireNextImageInfoKHR(const VkAcquireNextImageInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainKHR>(object.swapchain, settings, "VkSwapchainKHR", "swapchain", indents + 1, dump_html_VkSwapchainKHR);
    dump_html_value<const uint64_t>(object.timeout, settings, "uint64_t", "timeout", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.perViewPositionAllComponents, settings, "VkBool32", "perViewPositionAllComponents", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkCalibratedTimestampInfoEXT(const VkCalibratedTimestampInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkTimeDomainEXT>(object.timeDomain, settings, "VkTimeDomainEXT", "timeDomain", indents + 1, dump_html_VkTimeDomainEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceMemoryPriorityFeaturesEXT(const VkPhysicalDeviceMemoryPriorityFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.memoryPriority, settings, "VkBool32", "memoryPriority", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineRasterizationStateStreamCreateInfoEXT(const VkPipelineRasterizationStateStreamCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRasterizationStateStreamCreateFlagsEXT>(object.flags, settings, "VkPipelineRasterizationStateStreamCreateFlagsEXT", "flags", indents + 1, dump_html_VkPipelineRasterizationStateStreamCreateFlagsEXT);
    dump_html_value<const uint32_t>(object.rasterizationStream, settings, "uint32_t", "rasterizationStream", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPerformanceMarkerInfoINTEL(const VkPerformanceMarkerInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.marker, settings, "uint64_t", "marker", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSubgroupSizeControlFeaturesEXT(const VkPhysicalDeviceSubgroupSizeControlFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.subgroupSizeControl, settings, "VkBool32", "subgroupSizeControl", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.computeFullSubgroups, settings, "VkBool32", "computeFullSubgroups", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentShaderSampleInterlock, settings, "VkBool32", "fragmentShaderSampleInterlock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShaderPixelInterlock, settings, "VkBool32", "fragmentShaderPixelInterlock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentShaderShadingRateInterlock, settings, "VkBool32", "fragmentShaderShadingRateInterlock", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSurfaceCapabilities2KHR(const VkSurfaceCapabilities2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceCapabilitiesKHR>(object.surfaceCapabilities, settings, "VkSurfaceCapabilitiesKHR", "surfaceCapabilities", indents + 1, dump_html_VkSurfaceCapabilitiesKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineViewportSwizzleStateCreateInfoNV(const VkPipelineViewportSwizzleStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineViewportSwizzleStateCreateFlagsNV>(object.flags, settings, "VkPipelineViewportSwizzleStateCreateFlagsNV", "flags", indents + 1, dump_html_VkPipelineViewportSwizzleStateCreateFlagsNV);
    dump_html_value<const uint32_t>(object.viewportCount, settings, "uint32_t", "viewportCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkViewportSwizzleNV>(object.pViewportSwizzles, object.viewportCount, settings, "const VkViewportSwizzleNV*", "const VkViewportSwizzleNV", "pViewportSwizzles", indents + 1, dump_html_VkViewportSwizzleNV);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDevice8BitStorageFeaturesKHR(const VkPhysicalDevice8BitStorageFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.storageBuffer8BitAccess, settings, "VkBool32", "storageBuffer8BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.uniformAndStorageBuffer8BitAccess, settings, "VkBool32", "uniformAndStorageBuffer8BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storagePushConstant8, settings, "VkBool32", "storagePushConstant8", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSurfaceFormat2KHR(const VkSurfaceFormat2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceFormatKHR>(object.surfaceFormat, settings, "VkSurfaceFormatKHR", "surfaceFormat", indents + 1, dump_html_VkSurfaceFormatKHR);
    return settings.stream();
}
std::ostream& dump_html_VkBindImageMemorySwapchainInfoKHR(const VkBindImageMemorySwapchainInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainKHR>(object.swapchain, settings, "VkSwapchainKHR", "swapchain", indents + 1, dump_html_VkSwapchainKHR);
    dump_html_value<const uint32_t>(object.imageIndex, settings, "uint32_t", "imageIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderCorePropertiesAMD(const VkPhysicalDeviceShaderCorePropertiesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.shaderEngineCount, settings, "uint32_t", "shaderEngineCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderArraysPerEngineCount, settings, "uint32_t", "shaderArraysPerEngineCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.computeUnitsPerShaderArray, settings, "uint32_t", "computeUnitsPerShaderArray", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.simdPerComputeUnit, settings, "uint32_t", "simdPerComputeUnit", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.wavefrontsPerSimd, settings, "uint32_t", "wavefrontsPerSimd", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.wavefrontSize, settings, "uint32_t", "wavefrontSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sgprsPerSimd, settings, "uint32_t", "sgprsPerSimd", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minSgprAllocation, settings, "uint32_t", "minSgprAllocation", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSgprAllocation, settings, "uint32_t", "maxSgprAllocation", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sgprAllocationGranularity, settings, "uint32_t", "sgprAllocationGranularity", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vgprsPerSimd, settings, "uint32_t", "vgprsPerSimd", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minVgprAllocation, settings, "uint32_t", "minVgprAllocation", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVgprAllocation, settings, "uint32_t", "maxVgprAllocation", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vgprAllocationGranularity, settings, "uint32_t", "vgprAllocationGranularity", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceMemoryBudgetPropertiesEXT(const VkPhysicalDeviceMemoryBudgetPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const VkDeviceSize>(object.heapBudget, 16, settings, "VkDeviceSize[VK_MAX_MEMORY_HEAPS]", "VkDeviceSize", "heapBudget", indents + 1, dump_html_VkDeviceSize);
    dump_html_array<const VkDeviceSize>(object.heapUsage, 16, settings, "VkDeviceSize[VK_MAX_MEMORY_HEAPS]", "VkDeviceSize", "heapUsage", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.ycbcrImageArrays, settings, "VkBool32", "ycbcrImageArrays", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPerformanceStreamMarkerInfoINTEL(const VkPerformanceStreamMarkerInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.marker, settings, "uint32_t", "marker", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT(const VkPipelineShaderStageRequiredSubgroupSizeCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.requiredSubgroupSize, settings, "uint32_t", "requiredSubgroupSize", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkViewportSwizzleNV(const VkViewportSwizzleNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkViewportCoordinateSwizzleNV>(object.x, settings, "VkViewportCoordinateSwizzleNV", "x", indents + 1, dump_html_VkViewportCoordinateSwizzleNV);
    dump_html_value<const VkViewportCoordinateSwizzleNV>(object.y, settings, "VkViewportCoordinateSwizzleNV", "y", indents + 1, dump_html_VkViewportCoordinateSwizzleNV);
    dump_html_value<const VkViewportCoordinateSwizzleNV>(object.z, settings, "VkViewportCoordinateSwi", "z", indents + 1, dump_html_VkViewportCoordinateSwizzleNV);
    dump_html_value<const VkViewportCoordinateSwizzleNV>(object.w, settings, "VkVie", "w", indents + 1, dump_html_VkViewportCoordinateSwizzleNV);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryHostPointerPropertiesEXT(const VkMemoryHostPointerPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkSubmitInfo(const VkSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreCount, settings, "uint32_t", "waitSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pWaitSemaphores, object.waitSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pWaitSemaphores", indents + 1, dump_html_VkSemaphore);
    dump_html_array<const VkPipelineStageFlags>(object.pWaitDstStageMask, object.waitSemaphoreCount, settings, "const VkPipelineStageFlags*", "const VkPipelineStageFlags", "pWaitDstStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const uint32_t>(object.commandBufferCount, settings, "uint32_t", "commandBufferCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkCommandBuffer>(object.pCommandBuffers, object.commandBufferCount, settings, "const VkCommandBuffer*", "const VkCommandBuffer", "pCommandBuffers", indents + 1, dump_html_VkCommandBuffer);
    dump_html_value<const uint32_t>(object.signalSemaphoreCount, settings, "uint32_t", "signalSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pSignalSemaphores, object.signalSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pSignalSemaphores", indents + 1, dump_html_VkSemaphore);
    return settings.stream();
}
std::ostream& dump_html_VkPerformanceOverrideInfoINTEL(const VkPerformanceOverrideInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPerformanceOverrideTypeINTEL>(object.type, settings, "VkPerformanceOverrideTypeINTEL", "type", indents + 1, dump_html_VkPerformanceOverrideTypeINTEL);
    dump_html_value<const VkBool32>(object.enable, settings, "VkBool32", "enable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint64_t>(object.parameter, settings, "uint64_t", "parameter", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceProperties(const VkPhysicalDeviceProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.apiVersion, settings, "uint32_t", "apiVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.driverVersion, settings, "uint32_t", "driverVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.vendorID, settings, "uint32_t", "vendorID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.deviceID, settings, "uint32_t", "deviceID", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPhysicalDeviceType>(object.deviceType, settings, "VkPhysicalDeviceType", "deviceType", indents + 1, dump_html_VkPhysicalDeviceType);
    dump_html_value<const char*>(object.deviceName, settings, "char[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE]", "deviceName", indents + 1, dump_html_cstring);
    dump_html_array<const uint8_t>(object.pipelineCacheUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "pipelineCacheUUID", indents + 1, dump_html_uint8_t);
    dump_html_value<const VkPhysicalDeviceLimits>(object.limits, settings, "VkPhysicalDeviceLimits", "limits", indents + 1, dump_html_VkPhysicalDeviceLimits);
    dump_html_value<const VkPhysicalDeviceSparseProperties>(object.sparseProperties, settings, "VkPhysicalDeviceSparseProperties", "sparseProperties", indents + 1, dump_html_VkPhysicalDeviceSparseProperties);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryPriorityAllocateInfoEXT(const VkMemoryPriorityAllocateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const float>(object.priority, settings, "float", "priority", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkPerformanceConfigurationAcquireInfoINTEL(const VkPerformanceConfigurationAcquireInfoINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPerformanceConfigurationTypeINTEL>(object.type, settings, "VkPerformanceConfigurationTypeINTEL", "type", indents + 1, dump_html_VkPerformanceConfigurationTypeINTEL);
    return settings.stream();
}
std::ostream& dump_html_VkDebugMarkerObjectNameInfoEXT(const VkDebugMarkerObjectNameInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugReportObjectTypeEXT>(object.objectType, settings, "VkDebugReportObjectTypeEXT", "objectType", indents + 1, dump_html_VkDebugReportObjectTypeEXT);
    dump_html_value<const uint64_t>(object.object, settings, "uint64_t", "object", indents + 1, dump_html_uint64_t);
    dump_html_value<const char*>(object.pObjectName, settings, "const char*", "pObjectName", indents + 1, dump_html_cstring);
    return settings.stream();
}
std::ostream& dump_html_VkImportMemoryHostPointerInfoEXT(const VkImportMemoryHostPointerInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    dump_html_value<const void*>(object.pHostPointer, settings, "void*", "pHostPointer", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkSurfaceProtectedCapabilitiesKHR(const VkSurfaceProtectedCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.supportsProtected, settings, "VkBool32", "supportsProtected", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(const VkPhysicalDeviceExternalMemoryHostPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.minImportedHostPointerAlignment, settings, "VkDeviceSize", "minImportedHostPointerAlignment", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayProperties2KHR(const VkDisplayProperties2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayPropertiesKHR>(object.displayProperties, settings, "VkDisplayPropertiesKHR", "displayProperties", indents + 1, dump_html_VkDisplayPropertiesKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderCoreProperties2AMD(const VkPhysicalDeviceShaderCoreProperties2AMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderCorePropertiesFlagsAMD>(object.shaderCoreFeatures, settings, "VkShaderCorePropertiesFlagsAMD", "shaderCoreFeatures", indents + 1, dump_html_VkShaderCorePropertiesFlagsAMD);
    dump_html_value<const uint32_t>(object.activeComputeUnitCount, settings, "uint32_t", "activeComputeUnitCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceCooperativeMatrixPropertiesNV(const VkPhysicalDeviceCooperativeMatrixPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.cooperativeMatrixSupportedStages, settings, "VkShaderStageFlags", "cooperativeMatrixSupportedStages", indents + 1, dump_html_VkShaderStageFlags);
    return settings.stream();
}
std::ostream& dump_html_VkMappedMemoryRange(const VkMappedMemoryRange& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR(const VkPhysicalDeviceUniformBufferStandardLayoutFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.uniformBufferStandardLayout, settings, "VkBool32", "uniformBufferStandardLayout", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceLimits(const VkPhysicalDeviceLimits& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.maxImageDimension1D, settings, "uint32_t", "maxImageDimension1D", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageDimension2D, settings, "uint32_t", "maxImageDimension2D", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageDimension3D, settings, "uint32_t", "maxImageDimension3D", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageDimensionCube, settings, "uint32_t", "maxImageDimensionCube", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageArrayLayers, settings, "uint32_t", "maxImageArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTexelBufferElements, settings, "uint32_t", "maxTexelBufferElements", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxUniformBufferRange, settings, "uint32_t", "maxUniformBufferRange", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStorageBufferRange, settings, "uint32_t", "maxStorageBufferRange", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPushConstantsSize, settings, "uint32_t", "maxPushConstantsSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMemoryAllocationCount, settings, "uint32_t", "maxMemoryAllocationCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSamplerAllocationCount, settings, "uint32_t", "maxSamplerAllocationCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.bufferImageGranularity, settings, "VkDeviceSize", "bufferImageGranularity", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.sparseAddressSpaceSize, settings, "VkDeviceSize", "sparseAddressSpaceSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.maxBoundDescriptorSets, settings, "uint32_t", "maxBoundDescriptorSets", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorSamplers, settings, "uint32_t", "maxPerStageDescriptorSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUniformBuffers, settings, "uint32_t", "maxPerStageDescriptorUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorStorageBuffers, settings, "uint32_t", "maxPerStageDescriptorStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorSampledImages, settings, "uint32_t", "maxPerStageDescriptorSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorStorageImages, settings, "uint32_t", "maxPerStageDescriptorStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorInputAttachments, settings, "uint32_t", "maxPerStageDescriptorInputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageResources, settings, "uint32_t", "maxPerStageResources", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetSamplers, settings, "uint32_t", "maxDescriptorSetSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUniformBuffers, settings, "uint32_t", "maxDescriptorSetUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUniformBuffersDynamic, settings, "uint32_t", "maxDescriptorSetUniformBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetStorageBuffers, settings, "uint32_t", "maxDescriptorSetStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetStorageBuffersDynamic, settings, "uint32_t", "maxDescriptorSetStorageBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetSampledImages, settings, "uint32_t", "maxDescriptorSetSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetStorageImages, settings, "uint32_t", "maxDescriptorSetStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetInputAttachments, settings, "uint32_t", "maxDescriptorSetInputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexInputAttributes, settings, "uint32_t", "maxVertexInputAttributes", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexInputBindings, settings, "uint32_t", "maxVertexInputBindings", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexInputAttributeOffset, settings, "uint32_t", "maxVertexInputAttributeOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexInputBindingStride, settings, "uint32_t", "maxVertexInputBindingStride", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxVertexOutputComponents, settings, "uint32_t", "maxVertexOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationGenerationLevel, settings, "uint32_t", "maxTessellationGenerationLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationPatchSize, settings, "uint32_t", "maxTessellationPatchSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationControlPerVertexInputComponents, settings, "uint32_t", "maxTessellationControlPerVertexInputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationControlPerVertexOutputComponents, settings, "uint32_t", "maxTessellationControlPerVertexOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationControlPerPatchOutputComponents, settings, "uint32_t", "maxTessellationControlPerPatchOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationControlTotalOutputComponents, settings, "uint32_t", "maxTessellationControlTotalOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationEvaluationInputComponents, settings, "uint32_t", "maxTessellationEvaluationInputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTessellationEvaluationOutputComponents, settings, "uint32_t", "maxTessellationEvaluationOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryShaderInvocations, settings, "uint32_t", "maxGeometryShaderInvocations", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryInputComponents, settings, "uint32_t", "maxGeometryInputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryOutputComponents, settings, "uint32_t", "maxGeometryOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryOutputVertices, settings, "uint32_t", "maxGeometryOutputVertices", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxGeometryTotalOutputComponents, settings, "uint32_t", "maxGeometryTotalOutputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentInputComponents, settings, "uint32_t", "maxFragmentInputComponents", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentOutputAttachments, settings, "uint32_t", "maxFragmentOutputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentDualSrcAttachments, settings, "uint32_t", "maxFragmentDualSrcAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFragmentCombinedOutputResources, settings, "uint32_t", "maxFragmentCombinedOutputResources", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxComputeSharedMemorySize, settings, "uint32_t", "maxComputeSharedMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxComputeWorkGroupCount, 3, settings, "uint32_t[3]", "uint32_t", "maxComputeWorkGroupCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxComputeWorkGroupInvocations, settings, "uint32_t", "maxComputeWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxComputeWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxComputeWorkGroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.subPixelPrecisionBits, settings, "uint32_t", "subPixelPrecisionBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.subTexelPrecisionBits, settings, "uint32_t", "subTexelPrecisionBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.mipmapPrecisionBits, settings, "uint32_t", "mipmapPrecisionBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDrawIndexedIndexValue, settings, "uint32_t", "maxDrawIndexedIndexValue", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDrawIndirectCount, settings, "uint32_t", "maxDrawIndirectCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const float>(object.maxSamplerLodBias, settings, "float", "maxSamplerLodBias", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxSamplerAnisotropy, settings, "float", "maxSamplerAnisotropy", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.maxViewports, settings, "uint32_t", "maxViewports", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxViewportDimensions, 2, settings, "uint32_t[2]", "uint32_t", "maxViewportDimensions", indents + 1, dump_html_uint32_t);
    dump_html_array<const float>(object.viewportBoundsRange, 2, settings, "float[2]", "float", "viewportBoundsRange", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.viewportSubPixelBits, settings, "uint32_t", "viewportSubPixelBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.minMemoryMapAlignment, settings, "size_t", "minMemoryMapAlignment", indents + 1, dump_html_size_t);
    dump_html_value<const VkDeviceSize>(object.minTexelBufferOffsetAlignment, settings, "VkDeviceSize", "minTexelBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.minUniformBufferOffsetAlignment, settings, "VkDeviceSize", "minUniformBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.minStorageBufferOffsetAlignment, settings, "VkDeviceSize", "minStorageBufferOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const int32_t>(object.minTexelOffset, settings, "int32_t", "minTexelOffset", indents + 1, dump_html_int32_t);
    dump_html_value<const uint32_t>(object.maxTexelOffset, settings, "uint32_t", "maxTexelOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const int32_t>(object.minTexelGatherOffset, settings, "int32_t", "minTexelGatherOffset", indents + 1, dump_html_int32_t);
    dump_html_value<const uint32_t>(object.maxTexelGatherOffset, settings, "uint32_t", "maxTexelGatherOffset", indents + 1, dump_html_uint32_t);
    dump_html_value<const float>(object.minInterpolationOffset, settings, "float", "minInterpolationOffset", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxInterpolationOffset, settings, "float", "maxInterpolationOffset", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.subPixelInterpolationOffsetBits, settings, "uint32_t", "subPixelInterpolationOffsetBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFramebufferWidth, settings, "uint32_t", "maxFramebufferWidth", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFramebufferHeight, settings, "uint32_t", "maxFramebufferHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxFramebufferLayers, settings, "uint32_t", "maxFramebufferLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlags>(object.framebufferColorSampleCounts, settings, "VkSampleCountFlags", "framebufferColorSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.framebufferDepthSampleCounts, settings, "VkSampleCountFlags", "framebufferDepthSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.framebufferStencilSampleCounts, settings, "VkSampleCountFlags", "framebufferStencilSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.framebufferNoAttachmentsSampleCounts, settings, "VkSampleCountFlags", "framebufferNoAttachmentsSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const uint32_t>(object.maxColorAttachments, settings, "uint32_t", "maxColorAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlags>(object.sampledImageColorSampleCounts, settings, "VkSampleCountFlags", "sampledImageColorSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.sampledImageIntegerSampleCounts, settings, "VkSampleCountFlags", "sampledImageIntegerSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.sampledImageDepthSampleCounts, settings, "VkSampleCountFlags", "sampledImageDepthSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.sampledImageStencilSampleCounts, settings, "VkSampleCountFlags", "sampledImageStencilSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkSampleCountFlags>(object.storageImageSampleCounts, settings, "VkSampleCountFlags", "storageImageSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const uint32_t>(object.maxSampleMaskWords, settings, "uint32_t", "maxSampleMaskWords", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.timestampComputeAndGraphics, settings, "VkBool32", "timestampComputeAndGraphics", indents + 1, dump_html_VkBool32);
    dump_html_value<const float>(object.timestampPeriod, settings, "float", "timestampPeriod", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.maxClipDistances, settings, "uint32_t", "maxClipDistances", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxCullDistances, settings, "uint32_t", "maxCullDistances", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxCombinedClipAndCullDistances, settings, "uint32_t", "maxCombinedClipAndCullDistances", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.discreteQueuePriorities, settings, "uint32_t", "discreteQueuePriorities", indents + 1, dump_html_uint32_t);
    dump_html_array<const float>(object.pointSizeRange, 2, settings, "float[2]", "float", "pointSizeRange", indents + 1, dump_html_float);
    dump_html_array<const float>(object.lineWidthRange, 2, settings, "float[2]", "float", "lineWidthRange", indents + 1, dump_html_float);
    dump_html_value<const float>(object.pointSizeGranularity, settings, "float", "pointSizeGranularity", indents + 1, dump_html_float);
    dump_html_value<const float>(object.lineWidthGranularity, settings, "float", "lineWidthGranularity", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.strictLines, settings, "VkBool32", "strictLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.standardSampleLocations, settings, "VkBool32", "standardSampleLocations", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceSize>(object.optimalBufferCopyOffsetAlignment, settings, "VkDeviceSize", "optimalBufferCopyOffsetAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.optimalBufferCopyRowPitchAlignment, settings, "VkDeviceSize", "optimalBufferCopyRowPitchAlignment", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.nonCoherentAtomSize, settings, "VkDeviceSize", "nonCoherentAtomSize", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayPlaneProperties2KHR(const VkDisplayPlaneProperties2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayPlanePropertiesKHR>(object.displayPlaneProperties, settings, "VkDisplayPlanePropertiesKHR", "displayPlaneProperties", indents + 1, dump_html_VkDisplayPlanePropertiesKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dedicatedAllocationImageAliasing, settings, "VkBool32", "dedicatedAllocationImageAliasing", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkQueueFamilyProperties(const VkQueueFamilyProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkQueueFlags>(object.queueFlags, settings, "VkQueueFlags", "queueFlags", indents + 1, dump_html_VkQueueFlags);
    dump_html_value<const uint32_t>(object.queueCount, settings, "uint32_t", "queueCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.timestampValidBits, settings, "uint32_t", "timestampValidBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent3D>(object.minImageTransferGranularity, settings, "VkExtent3D", "minImageTransferGranularity", indents + 1, dump_html_VkExtent3D);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayPropertiesKHR(const VkDisplayPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDisplayKHR>(object.display, settings, "VkDisplayKHR", "display", indents + 1, dump_html_VkDisplayKHR);
    dump_html_value<const char*>(object.displayName, settings, "const char*", "displayName", indents + 1, dump_html_cstring);
    dump_html_value<const VkExtent2D>(object.physicalDimensions, settings, "VkExtent2D", "physicalDimensions", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.physicalResolution, settings, "VkExtent2D", "physicalResolution", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkSurfaceTransformFlagsKHR>(object.supportedTransforms, settings, "VkSurfaceTransformFlagsKHR", "supportedTransforms", indents + 1, dump_html_VkSurfaceTransformFlagsKHR);
    dump_html_value<const VkBool32>(object.planeReorderPossible, settings, "VkBool32", "planeReorderPossible", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.persistentContent, settings, "VkBool32", "persistentContent", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSparseProperties(const VkPhysicalDeviceSparseProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBool32>(object.residencyStandard2DBlockShape, settings, "VkBool32", "residencyStandard2DBlockShape", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.residencyStandard2DMultisampleBlockShape, settings, "VkBool32", "residencyStandard2DMultisampleBlockShape", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.residencyStandard3DBlockShape, settings, "VkBool32", "residencyStandard3DBlockShape", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.residencyAlignedMipSize, settings, "VkBool32", "residencyAlignedMipSize", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.residencyNonResidentStrict, settings, "VkBool32", "residencyNonResidentStrict", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGroupPresentInfoKHR(const VkDeviceGroupPresentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDeviceMasks, object.swapchainCount, settings, "const uint32_t*", "const uint32_t", "pDeviceMasks", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceGroupPresentModeFlagBitsKHR>(object.mode, settings, "VkDeviceGroupPresentModeFlagBitsKHR", "mode", indents + 1, dump_html_VkDeviceGroupPresentModeFlagBitsKHR);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGroupPresentCapabilitiesKHR(const VkDeviceGroupPresentCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint32_t>(object.presentMask, 32, settings, "uint32_t[VK_MAX_DEVICE_GROUP_SIZE]", "uint32_t", "presentMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceGroupPresentModeFlagsKHR>(object.modes, settings, "VkDeviceGroupPresentModeFlagsKHR", "modes", indents + 1, dump_html_VkDeviceGroupPresentModeFlagsKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.bufferDeviceAddress, settings, "VkBool32", "bufferDeviceAddress", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddressCaptureReplay, settings, "VkBool32", "bufferDeviceAddressCaptureReplay", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bufferDeviceAddressMultiDevice, settings, "VkBool32", "bufferDeviceAddressMultiDevice", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDebugMarkerObjectTagInfoEXT(const VkDebugMarkerObjectTagInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugReportObjectTypeEXT>(object.objectType, settings, "VkDebugReportObjectTypeEXT", "objectType", indents + 1, dump_html_VkDebugReportObjectTypeEXT);
    dump_html_value<const uint64_t>(object.object, settings, "uint64_t", "object", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.tagName, settings, "uint64_t", "tagName", indents + 1, dump_html_uint64_t);
    dump_html_value<const size_t>(object.tagSize, settings, "size_t", "tagSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pTag, settings, "const void*", "pTag", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkDisplaySurfaceCreateInfoKHR(const VkDisplaySurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplaySurfaceCreateFlagsKHR>(object.flags, settings, "VkDisplaySurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkDisplaySurfaceCreateFlagsKHR);
    dump_html_value<const VkDisplayModeKHR>(object.displayMode, settings, "VkDisplayModeKHR", "displayMode", indents + 1, dump_html_VkDisplayModeKHR);
    dump_html_value<const uint32_t>(object.planeIndex, settings, "uint32_t", "planeIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.planeStackIndex, settings, "uint32_t", "planeStackIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.transform, settings, "VkSurfaceTransformFlagBitsKHR", "transform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const float>(object.globalAlpha, settings, "float", "globalAlpha", indents + 1, dump_html_float);
    dump_html_value<const VkDisplayPlaneAlphaFlagBitsKHR>(object.alphaMode, settings, "VkDisplayPlaneAlphaFlagBitsKHR", "alphaMode", indents + 1, dump_html_VkDisplayPlaneAlphaFlagBitsKHR);
    dump_html_value<const VkExtent2D>(object.imageExtent, settings, "VkExtent2D", "imageExtent", indents + 1, dump_html_VkExtent2D);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkSurfaceFullScreenExclusiveInfoEXT(const VkSurfaceFullScreenExclusiveInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFullScreenExclusiveEXT>(object.fullScreenExclusive, settings, "VkFullScreenExclusiveEXT", "fullScreenExclusive", indents + 1, dump_html_VkFullScreenExclusiveEXT);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkSparseMemoryBind(const VkSparseMemoryBind& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.resourceOffset, settings, "VkDeviceSize", "resourceOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkSparseMemoryBindFlags>(object.flags, settings, "VkSparseMemoryBindFlags", "flags", indents + 1, dump_html_VkSparseMemoryBindFlags);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkSurfaceCapabilitiesFullScreenExclusiveEXT(const VkSurfaceCapabilitiesFullScreenExclusiveEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fullScreenExclusiveSupported, settings, "VkBool32", "fullScreenExclusiveSupported", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkBufferDeviceAddressInfoEXT(const VkBufferDeviceAddressInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    return settings.stream();
}
std::ostream& dump_html_VkDebugMarkerMarkerInfoEXT(const VkDebugMarkerMarkerInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.pMarkerName, settings, "const char*", "pMarkerName", indents + 1, dump_html_cstring);
    dump_html_array<const float>(object.color, 4, settings, "float[4]", "float", "color", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineRasterizationStateRasterizationOrderAMD(const VkPipelineRasterizationStateRasterizationOrderAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRasterizationOrderAMD>(object.rasterizationOrder, settings, "VkRasterizationOrderAMD", "rasterizationOrder", indents + 1, dump_html_VkRasterizationOrderAMD);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGroupSwapchainCreateInfoKHR(const VkDeviceGroupSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceGroupPresentModeFlagsKHR>(object.modes, settings, "VkDeviceGroupPresentModeFlagsKHR", "modes", indents + 1, dump_html_VkDeviceGroupPresentModeFlagsKHR);
    return settings.stream();
}
std::ostream& dump_html_VkSparseBufferMemoryBindInfo(const VkSparseBufferMemoryBindInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const uint32_t>(object.bindCount, settings, "uint32_t", "bindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseMemoryBind>(object.pBinds, object.bindCount, settings, "const VkSparseMemoryBind*", "const VkSparseMemoryBind", "pBinds", indents + 1, dump_html_VkSparseMemoryBind);
    return settings.stream();
}
std::ostream& dump_html_VkBindSparseInfo(const VkBindSparseInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreCount, settings, "uint32_t", "waitSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pWaitSemaphores, object.waitSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pWaitSemaphores", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const uint32_t>(object.bufferBindCount, settings, "uint32_t", "bufferBindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseBufferMemoryBindInfo>(object.pBufferBinds, object.bufferBindCount, settings, "const VkSparseBufferMemoryBindInfo*", "const VkSparseBufferMemoryBindInfo", "pBufferBinds", indents + 1, dump_html_VkSparseBufferMemoryBindInfo);
    dump_html_value<const uint32_t>(object.imageOpaqueBindCount, settings, "uint32_t", "imageOpaqueBindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseImageOpaqueMemoryBindInfo>(object.pImageOpaqueBinds, object.imageOpaqueBindCount, settings, "const VkSparseImageOpaqueMemoryBindInfo*", "const VkSparseImageOpaqueMemoryBindInfo", "pImageOpaqueBinds", indents + 1, dump_html_VkSparseImageOpaqueMemoryBindInfo);
    dump_html_value<const uint32_t>(object.imageBindCount, settings, "uint32_t", "imageBindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseImageMemoryBindInfo>(object.pImageBinds, object.imageBindCount, settings, "const VkSparseImageMemoryBindInfo*", "const VkSparseImageMemoryBindInfo", "pImageBinds", indents + 1, dump_html_VkSparseImageMemoryBindInfo);
    dump_html_value<const uint32_t>(object.signalSemaphoreCount, settings, "uint32_t", "signalSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pSignalSemaphores, object.signalSemaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pSignalSemaphores", indents + 1, dump_html_VkSemaphore);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceCooperativeMatrixFeaturesNV(const VkPhysicalDeviceCooperativeMatrixFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.cooperativeMatrix, settings, "VkBool32", "cooperativeMatrix", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.cooperativeMatrixRobustBufferAccess, settings, "VkBool32", "cooperativeMatrixRobustBufferAccess", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayPlanePropertiesKHR(const VkDisplayPlanePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDisplayKHR>(object.currentDisplay, settings, "VkDisplayKHR", "currentDisplay", indents + 1, dump_html_VkDisplayKHR);
    dump_html_value<const uint32_t>(object.currentStackIndex, settings, "uint32_t", "currentStackIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderAtomicInt64FeaturesKHR(const VkPhysicalDeviceShaderAtomicInt64FeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderBufferInt64Atomics, settings, "VkBool32", "shaderBufferInt64Atomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSharedInt64Atomics, settings, "VkBool32", "shaderSharedInt64Atomics", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayModeCreateInfoKHR(const VkDisplayModeCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayModeCreateFlagsKHR>(object.flags, settings, "VkDisplayModeCreateFlagsKHR", "flags", indents + 1, dump_html_VkDisplayModeCreateFlagsKHR);
    dump_html_value<const VkDisplayModeParametersKHR>(object.parameters, settings, "VkDisplayModeParametersKHR", "parameters", indents + 1, dump_html_VkDisplayModeParametersKHR);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayModeProperties2KHR(const VkDisplayModeProperties2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayModePropertiesKHR>(object.displayModeProperties, settings, "VkDisplayModePropertiesKHR", "displayModeProperties", indents + 1, dump_html_VkDisplayModePropertiesKHR);
    return settings.stream();
}
std::ostream& dump_html_VkSparseImageOpaqueMemoryBindInfo(const VkSparseImageOpaqueMemoryBindInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const uint32_t>(object.bindCount, settings, "uint32_t", "bindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseMemoryBind>(object.pBinds, object.bindCount, settings, "const VkSparseMemoryBind*", "const VkSparseMemoryBind", "pBinds", indents + 1, dump_html_VkSparseMemoryBind);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryType(const VkMemoryType& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkMemoryPropertyFlags>(object.propertyFlags, settings, "VkMemoryPropertyFlags", "propertyFlags", indents + 1, dump_html_VkMemoryPropertyFlags);
    dump_html_value<const uint32_t>(object.heapIndex, settings, "uint32_t", "heapIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceMemoryOverallocationCreateInfoAMD(const VkDeviceMemoryOverallocationCreateInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryOverallocationBehaviorAMD>(object.overallocationBehavior, settings, "VkMemoryOverallocationBehaviorAMD", "overallocationBehavior", indents + 1, dump_html_VkMemoryOverallocationBehaviorAMD);
    return settings.stream();
}
std::ostream& dump_html_VkBufferDeviceAddressCreateInfoEXT(const VkBufferDeviceAddressCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceAddress>(object.deviceAddress, settings, "VkDeviceAddress", "deviceAddress", indents + 1, dump_html_VkDeviceAddress);
    return settings.stream();
}
std::ostream& dump_html_VkBufferMemoryRequirementsInfo2(const VkBufferMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    return settings.stream();
}
std::ostream& dump_html_VkSurfaceCapabilities2EXT(const VkSurfaceCapabilities2EXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.minImageCount, settings, "uint32_t", "minImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageCount, settings, "uint32_t", "maxImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent2D>(object.currentExtent, settings, "VkExtent2D", "currentExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.minImageExtent, settings, "VkExtent2D", "minImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxImageExtent, settings, "VkExtent2D", "maxImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.maxImageArrayLayers, settings, "uint32_t", "maxImageArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSurfaceTransformFlagsKHR>(object.supportedTransforms, settings, "VkSurfaceTransformFlagsKHR", "supportedTransforms", indents + 1, dump_html_VkSurfaceTransformFlagsKHR);
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.currentTransform, settings, "VkSurfaceTransformFlagBitsKHR", "currentTransform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const VkCompositeAlphaFlagsKHR>(object.supportedCompositeAlpha, settings, "VkCompositeAlphaFlagsKHR", "supportedCompositeAlpha", indents + 1, dump_html_VkCompositeAlphaFlagsKHR);
    dump_html_value<const VkImageUsageFlags>(object.supportedUsageFlags, settings, "VkImageUsageFlags", "supportedUsageFlags", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkSurfaceCounterFlagsEXT>(object.supportedSurfaceCounters, settings, "VkSurfaceCounterFlagsEXT", "supportedSurfaceCounters", indents + 1, dump_html_VkSurfaceCounterFlagsEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDevicePushDescriptorPropertiesKHR(const VkPhysicalDevicePushDescriptorPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxPushDescriptors, settings, "uint32_t", "maxPushDescriptors", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorBufferInfo(const VkDescriptorBufferInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.range, settings, "VkDeviceSize", "range", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkImageMemoryRequirementsInfo2(const VkImageMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorImageInfo(const VkDescriptorImageInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkSampler>(object.sampler, settings, "VkSampler", "sampler", indents + 1, dump_html_VkSampler);
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkImageLayout>(object.imageLayout, settings, "VkImageLayout", "imageLayout", indents + 1, dump_html_VkImageLayout);
    return settings.stream();
}
std::ostream& dump_html_VkSampleLocationsInfoEXT(const VkSampleLocationsInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSampleCountFlagBits>(object.sampleLocationsPerPixel, settings, "VkSampleCountFlagBits", "sampleLocationsPerPixel", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkExtent2D>(object.sampleLocationGridSize, settings, "VkExtent2D", "sampleLocationGridSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.sampleLocationsCount, settings, "uint32_t", "sampleLocationsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSampleLocationEXT>(object.pSampleLocations, object.sampleLocationsCount, settings, "const VkSampleLocationEXT*", "const VkSampleLocationEXT", "pSampleLocations", indents + 1, dump_html_VkSampleLocationEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceVulkanMemoryModelFeaturesKHR(const VkPhysicalDeviceVulkanMemoryModelFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.vulkanMemoryModel, settings, "VkBool32", "vulkanMemoryModel", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vulkanMemoryModelDeviceScope, settings, "VkBool32", "vulkanMemoryModelDeviceScope", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vulkanMemoryModelAvailabilityVisibilityChains, settings, "VkBool32", "vulkanMemoryModelAvailabilityVisibilityChains", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineColorBlendAttachmentState(const VkPipelineColorBlendAttachmentState& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBool32>(object.blendEnable, settings, "VkBool32", "blendEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBlendFactor>(object.srcColorBlendFactor, settings, "VkBlendFactor", "srcColorBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendFactor>(object.dstColorBlendFactor, settings, "VkBlendFactor", "dstColorBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendOp>(object.colorBlendOp, settings, "VkBlendOp", "colorBlendOp", indents + 1, dump_html_VkBlendOp);
    dump_html_value<const VkBlendFactor>(object.srcAlphaBlendFactor, settings, "VkBlendFactor", "srcAlphaBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendFactor>(object.dstAlphaBlendFactor, settings, "VkBlendFactor", "dstAlphaBlendFactor", indents + 1, dump_html_VkBlendFactor);
    dump_html_value<const VkBlendOp>(object.alphaBlendOp, settings, "VkBlendOp", "alphaBlendOp", indents + 1, dump_html_VkBlendOp);
    dump_html_value<const VkColorComponentFlags>(object.colorWriteMask, settings, "VkColorComponentFlags", "colorWriteMask", indents + 1, dump_html_VkColorComponentFlags);
    return settings.stream();
}
std::ostream& dump_html_VkWriteDescriptorSet(const VkWriteDescriptorSet& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorSet>(object.dstSet, settings, "VkDescriptorSet", "dstSet", indents + 1, dump_html_VkDescriptorSet);
    dump_html_value<const uint32_t>(object.dstBinding, settings, "uint32_t", "dstBinding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstArrayElement, settings, "uint32_t", "dstArrayElement", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDescriptorType>(object.descriptorType, settings, "VkDescriptorType", "descriptorType", indents + 1, dump_html_VkDescriptorType);
    if((object.descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE) || (object.descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE) || (object.descriptorType == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT))
    dump_html_array<const VkDescriptorImageInfo>(object.pImageInfo, object.descriptorCount, settings, "const VkDescriptorImageInfo*", "const VkDescriptorImageInfo", "pImageInfo", indents + 1, dump_html_VkDescriptorImageInfo);
    else
        dump_html_special("UNUSED", settings, "const VkDescriptorImageInfo*", "pImageInfo", indents + 1);
    if((object.descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC) || (object.descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC))
    dump_html_array<const VkDescriptorBufferInfo>(object.pBufferInfo, object.descriptorCount, settings, "const VkDescriptorBufferInfo*", "const VkDescriptorBufferInfo", "pBufferInfo", indents + 1, dump_html_VkDescriptorBufferInfo);
    else
        dump_html_special("UNUSED", settings, "const VkDescriptorBufferInfo*", "pBufferInfo", indents + 1);
    if((object.descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER))
    dump_html_array<const VkBufferView>(object.pTexelBufferView, object.descriptorCount, settings, "const VkBufferView*", "const VkBufferView", "pTexelBufferView", indents + 1, dump_html_VkBufferView);
    else
        dump_html_special("UNUSED", settings, "const VkBufferView*", "pTexelBufferView", indents + 1);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkWin32SurfaceCreateInfoKHR(const VkWin32SurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkWin32SurfaceCreateFlagsKHR>(object.flags, settings, "VkWin32SurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkWin32SurfaceCreateFlagsKHR);
    dump_html_value<const HINSTANCE>(object.hinstance, settings, "HINSTANCE", "hinstance", indents + 1, dump_html_HINSTANCE);
    dump_html_value<const HWND>(object.hwnd, settings, "HWND", "hwnd", indents + 1, dump_html_HWND);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkAttachmentSampleLocationsEXT(const VkAttachmentSampleLocationsEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.attachmentIndex, settings, "uint32_t", "attachmentIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleLocationsInfoEXT>(object.sampleLocationsInfo, settings, "VkSampleLocationsInfoEXT", "sampleLocationsInfo", indents + 1, dump_html_VkSampleLocationsInfoEXT);
    return settings.stream();
}
std::ostream& dump_html_VkImageSparseMemoryRequirementsInfo2(const VkImageSparseMemoryRequirementsInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDevicePCIBusInfoPropertiesEXT(const VkPhysicalDevicePCIBusInfoPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.pciDomain, settings, "uint32_t", "pciDomain", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pciBus, settings, "uint32_t", "pciBus", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pciDevice, settings, "uint32_t", "pciDevice", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pciFunction, settings, "uint32_t", "pciFunction", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV(const VkPhysicalDeviceFragmentShaderBarycentricFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentShaderBarycentric, settings, "VkBool32", "fragmentShaderBarycentric", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkCopyDescriptorSet(const VkCopyDescriptorSet& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorSet>(object.srcSet, settings, "VkDescriptorSet", "srcSet", indents + 1, dump_html_VkDescriptorSet);
    dump_html_value<const uint32_t>(object.srcBinding, settings, "uint32_t", "srcBinding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.srcArrayElement, settings, "uint32_t", "srcArrayElement", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDescriptorSet>(object.dstSet, settings, "VkDescriptorSet", "dstSet", indents + 1, dump_html_VkDescriptorSet);
    dump_html_value<const uint32_t>(object.dstBinding, settings, "uint32_t", "dstBinding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstArrayElement, settings, "uint32_t", "dstArrayElement", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkSubpassSampleLocationsEXT(const VkSubpassSampleLocationsEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.subpassIndex, settings, "uint32_t", "subpassIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleLocationsInfoEXT>(object.sampleLocationsInfo, settings, "VkSampleLocationsInfoEXT", "sampleLocationsInfo", indents + 1, dump_html_VkSampleLocationsInfoEXT);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryRequirements2(const VkMemoryRequirements2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryRequirements>(object.memoryRequirements, settings, "VkMemoryRequirements", "memoryRequirements", indents + 1, dump_html_VkMemoryRequirements);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderImageFootprintFeaturesNV(const VkPhysicalDeviceShaderImageFootprintFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.imageFootprint, settings, "VkBool32", "imageFootprint", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSparseImageMemoryRequirements2(const VkSparseImageMemoryRequirements2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSparseImageMemoryRequirements>(object.memoryRequirements, settings, "VkSparseImageMemoryRequirements", "memoryRequirements", indents + 1, dump_html_VkSparseImageMemoryRequirements);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceDiscardRectanglePropertiesEXT(const VkPhysicalDeviceDiscardRectanglePropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxDiscardRectangles, settings, "uint32_t", "maxDiscardRectangles", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayNativeHdrSurfaceCapabilitiesAMD(const VkDisplayNativeHdrSurfaceCapabilitiesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.localDimmingSupport, settings, "VkBool32", "localDimmingSupport", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkRenderPassSampleLocationsBeginInfoEXT(const VkRenderPassSampleLocationsBeginInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachmentInitialSampleLocationsCount, settings, "uint32_t", "attachmentInitialSampleLocationsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentSampleLocationsEXT>(object.pAttachmentInitialSampleLocations, object.attachmentInitialSampleLocationsCount, settings, "const VkAttachmentSampleLocationsEXT*", "const VkAttachmentSampleLocationsEXT", "pAttachmentInitialSampleLocations", indents + 1, dump_html_VkAttachmentSampleLocationsEXT);
    dump_html_value<const uint32_t>(object.postSubpassSampleLocationsCount, settings, "uint32_t", "postSubpassSampleLocationsCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassSampleLocationsEXT>(object.pPostSubpassSampleLocations, object.postSubpassSampleLocationsCount, settings, "const VkSubpassSampleLocationsEXT*", "const VkSubpassSampleLocationsEXT", "pPostSubpassSampleLocations", indents + 1, dump_html_VkSubpassSampleLocationsEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineDiscardRectangleStateCreateInfoEXT(const VkPipelineDiscardRectangleStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineDiscardRectangleStateCreateFlagsEXT>(object.flags, settings, "VkPipelineDiscardRectangleStateCreateFlagsEXT", "flags", indents + 1, dump_html_VkPipelineDiscardRectangleStateCreateFlagsEXT);
    dump_html_value<const VkDiscardRectangleModeEXT>(object.discardRectangleMode, settings, "VkDiscardRectangleModeEXT", "discardRectangleMode", indents + 1, dump_html_VkDiscardRectangleModeEXT);
    dump_html_value<const uint32_t>(object.discardRectangleCount, settings, "uint32_t", "discardRectangleCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pDiscardRectangles, object.discardRectangleCount, settings, "const VkRect2D*", "const VkRect2D", "pDiscardRectangles", indents + 1, dump_html_VkRect2D);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSampleLocationsPropertiesEXT(const VkPhysicalDeviceSampleLocationsPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSampleCountFlags>(object.sampleLocationSampleCounts, settings, "VkSampleCountFlags", "sampleLocationSampleCounts", indents + 1, dump_html_VkSampleCountFlags);
    dump_html_value<const VkExtent2D>(object.maxSampleLocationGridSize, settings, "VkExtent2D", "maxSampleLocationGridSize", indents + 1, dump_html_VkExtent2D);
    dump_html_array<const float>(object.sampleLocationCoordinateRange, 2, settings, "float[2]", "float", "sampleLocationCoordinateRange", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.sampleLocationSubPixelBits, settings, "uint32_t", "sampleLocationSubPixelBits", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.variableSampleLocations, settings, "VkBool32", "variableSampleLocations", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceExclusiveScissorFeaturesNV(const VkPhysicalDeviceExclusiveScissorFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.exclusiveScissor, settings, "VkBool32", "exclusiveScissor", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkConditionalRenderingBeginInfoEXT(const VkConditionalRenderingBeginInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkConditionalRenderingFlagsEXT>(object.flags, settings, "VkConditionalRenderingFlagsEXT", "flags", indents + 1, dump_html_VkConditionalRenderingFlagsEXT);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayPowerInfoEXT(const VkDisplayPowerInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayPowerStateEXT>(object.powerState, settings, "VkDisplayPowerStateEXT", "powerState", indents + 1, dump_html_VkDisplayPowerStateEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.representativeFragmentTest, settings, "VkBool32", "representativeFragmentTest", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkCommandBufferInheritanceConditionalRenderingInfoEXT(const VkCommandBufferInheritanceConditionalRenderingInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.conditionalRenderingEnable, settings, "VkBool32", "conditionalRenderingEnable", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceEventInfoEXT(const VkDeviceEventInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceEventTypeEXT>(object.deviceEvent, settings, "VkDeviceEventTypeEXT", "deviceEvent", indents + 1, dump_html_VkDeviceEventTypeEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineSampleLocationsStateCreateInfoEXT(const VkPipelineSampleLocationsStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.sampleLocationsEnable, settings, "VkBool32", "sampleLocationsEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkSampleLocationsInfoEXT>(object.sampleLocationsInfo, settings, "VkSampleLocationsInfoEXT", "sampleLocationsInfo", indents + 1, dump_html_VkSampleLocationsInfoEXT);
    return settings.stream();
}
std::ostream& dump_html_VkSwapchainDisplayNativeHdrCreateInfoAMD(const VkSwapchainDisplayNativeHdrCreateInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.localDimmingEnable, settings, "VkBool32", "localDimmingEnable", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineViewportExclusiveScissorStateCreateInfoNV(const VkPipelineViewportExclusiveScissorStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.exclusiveScissorCount, settings, "uint32_t", "exclusiveScissorCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pExclusiveScissors, object.exclusiveScissorCount, settings, "const VkRect2D*", "const VkRect2D", "pExclusiveScissors", indents + 1, dump_html_VkRect2D);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceConditionalRenderingFeaturesEXT(const VkPhysicalDeviceConditionalRenderingFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.conditionalRendering, settings, "VkBool32", "conditionalRendering", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.inheritedConditionalRendering, settings, "VkBool32", "inheritedConditionalRendering", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayEventInfoEXT(const VkDisplayEventInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayEventTypeEXT>(object.displayEvent, settings, "VkDisplayEventTypeEXT", "displayEvent", indents + 1, dump_html_VkDisplayEventTypeEXT);
    return settings.stream();
}
std::ostream& dump_html_VkMultisamplePropertiesEXT(const VkMultisamplePropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.maxSampleLocationGridSize, settings, "VkExtent2D", "maxSampleLocationGridSize", indents + 1, dump_html_VkExtent2D);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceFeatures2(const VkPhysicalDeviceFeatures2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPhysicalDeviceFeatures>(object.features, settings, "VkPhysicalDeviceFeatures", "features", indents + 1, dump_html_VkPhysicalDeviceFeatures);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
std::ostream& dump_html_VkImagePipeSurfaceCreateInfoFUCHSIA(const VkImagePipeSurfaceCreateInfoFUCHSIA& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImagePipeSurfaceCreateFlagsFUCHSIA>(object.flags, settings, "VkImagePipeSurfaceCreateFlagsFUCHSIA", "flags", indents + 1, dump_html_VkImagePipeSurfaceCreateFlagsFUCHSIA);
    dump_html_value<const zx_handle_t>(object.imagePipeHandle, settings, "zx_handle_t", "imagePipeHandle", indents + 1, dump_html_zx_handle_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_FUCHSIA
std::ostream& dump_html_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(const VkPhysicalDeviceConservativeRasterizationPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const float>(object.primitiveOverestimationSize, settings, "float", "primitiveOverestimationSize", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxExtraPrimitiveOverestimationSize, settings, "float", "maxExtraPrimitiveOverestimationSize", indents + 1, dump_html_float);
    dump_html_value<const float>(object.extraPrimitiveOverestimationSizeGranularity, settings, "float", "extraPrimitiveOverestimationSizeGranularity", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.primitiveUnderestimation, settings, "VkBool32", "primitiveUnderestimation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.conservativePointAndLineRasterization, settings, "VkBool32", "conservativePointAndLineRasterization", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.degenerateTrianglesRasterized, settings, "VkBool32", "degenerateTrianglesRasterized", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.degenerateLinesRasterized, settings, "VkBool32", "degenerateLinesRasterized", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fullyCoveredFragmentShaderInputVariable, settings, "VkBool32", "fullyCoveredFragmentShaderInputVariable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.conservativeRasterizationPostDepthCoverage, settings, "VkBool32", "conservativeRasterizationPostDepthCoverage", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkImageViewHandleInfoNVX(const VkImageViewHandleInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageView>(object.imageView, settings, "VkImageView", "imageView", indents + 1, dump_html_VkImageView);
    dump_html_value<const VkDescriptorType>(object.descriptorType, settings, "VkDescriptorType", "descriptorType", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const VkSampler>(object.sampler, settings, "VkSampler", "sampler", indents + 1, dump_html_VkSampler);
    return settings.stream();
}
std::ostream& dump_html_VkFramebufferCreateInfo(const VkFramebufferCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFramebufferCreateFlags>(object.flags, settings, "VkFramebufferCreateFlags", "flags", indents + 1, dump_html_VkFramebufferCreateFlags);
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageView>(object.pAttachments, object.attachmentCount, settings, "const VkImageView*", "const VkImageView", "pAttachments", indents + 1, dump_html_VkImageView);
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layers, settings, "uint32_t", "layers", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkSwapchainCounterCreateInfoEXT(const VkSwapchainCounterCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSurfaceCounterFlagsEXT>(object.surfaceCounters, settings, "VkSurfaceCounterFlagsEXT", "surfaceCounters", indents + 1, dump_html_VkSurfaceCounterFlagsEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineRasterizationConservativeStateCreateInfoEXT(const VkPipelineRasterizationConservativeStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRasterizationConservativeStateCreateFlagsEXT>(object.flags, settings, "VkPipelineRasterizationConservativeStateCreateFlagsEXT", "flags", indents + 1, dump_html_VkPipelineRasterizationConservativeStateCreateFlagsEXT);
    dump_html_value<const VkConservativeRasterizationModeEXT>(object.conservativeRasterizationMode, settings, "VkConservativeRasterizationModeEXT", "conservativeRasterizationMode", indents + 1, dump_html_VkConservativeRasterizationModeEXT);
    dump_html_value<const float>(object.extraPrimitiveOverestimationSize, settings, "float", "extraPrimitiveOverestimationSize", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(const VkPipelineRepresentativeFragmentTestStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.representativeFragmentTestEnable, settings, "VkBool32", "representativeFragmentTestEnable", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkQueueFamilyCheckpointPropertiesNV(const VkQueueFamilyCheckpointPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlags>(object.checkpointExecutionStageMask, settings, "VkPipelineStageFlags", "checkpointExecutionStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceProperties2(const VkPhysicalDeviceProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPhysicalDeviceProperties>(object.properties, settings, "VkPhysicalDeviceProperties", "properties", indents + 1, dump_html_VkPhysicalDeviceProperties);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderFloat16Int8FeaturesKHR(const VkPhysicalDeviceShaderFloat16Int8FeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderFloat16, settings, "VkBool32", "shaderFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInt8, settings, "VkBool32", "shaderInt8", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkFormatProperties2(const VkFormatProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormatProperties>(object.formatProperties, settings, "VkFormatProperties", "formatProperties", indents + 1, dump_html_VkFormatProperties);
    return settings.stream();
}
std::ostream& dump_html_VkCheckpointDataNV(const VkCheckpointDataNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineStageFlagBits>(object.stage, settings, "VkPipelineStageFlagBits", "stage", indents + 1, dump_html_VkPipelineStageFlagBits);
    dump_html_value<const void*>(object.pCheckpointMarker, settings, "void*", "pCheckpointMarker", indents + 1, dump_html_void);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
std::ostream& dump_html_VkMetalSurfaceCreateInfoEXT(const VkMetalSurfaceCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMetalSurfaceCreateFlagsEXT>(object.flags, settings, "VkMetalSurfaceCreateFlagsEXT", "flags", indents + 1, dump_html_VkMetalSurfaceCreateFlagsEXT);
    dump_html_pointer<const CAMetalLayer>(object.pLayer, settings, "const CAMetalLayer*", "pLayer", indents + 1, dump_html_CAMetalLayer);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_METAL_EXT
std::ostream& dump_html_VkPresentRegionKHR(const VkPresentRegionKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.rectangleCount, settings, "uint32_t", "rectangleCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRectLayerKHR>(object.pRectangles, object.rectangleCount, settings, "const VkRectLayerKHR*", "const VkRectLayerKHR", "pRectangles", indents + 1, dump_html_VkRectLayerKHR);
    return settings.stream();
}
std::ostream& dump_html_VkImageFormatProperties2(const VkImageFormatProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageFormatProperties>(object.imageFormatProperties, settings, "VkImageFormatProperties", "imageFormatProperties", indents + 1, dump_html_VkImageFormatProperties);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceDepthClipEnableFeaturesEXT(const VkPhysicalDeviceDepthClipEnableFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.depthClipEnable, settings, "VkBool32", "depthClipEnable", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkImageFormatListCreateInfoKHR(const VkImageFormatListCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.viewFormatCount, settings, "uint32_t", "viewFormatCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFormat>(object.pViewFormats, object.viewFormatCount, settings, "const VkFormat*", "const VkFormat", "pViewFormats", indents + 1, dump_html_VkFormat);
    return settings.stream();
}
std::ostream& dump_html_VkRectLayerKHR(const VkRectLayerKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkOffset2D>(object.offset, settings, "VkOffset2D", "offset", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.extent, settings, "VkExtent2D", "extent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.layer, settings, "uint32_t", "layer", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPresentRegionsKHR(const VkPresentRegionsKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.swapchainCount, settings, "uint32_t", "swapchainCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPresentRegionKHR>(object.pRegions, object.swapchainCount, settings, "const VkPresentRegionKHR*", "const VkPresentRegionKHR", "pRegions", indents + 1, dump_html_VkPresentRegionKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(const VkPhysicalDeviceFragmentDensityMapFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.fragmentDensityMap, settings, "VkBool32", "fragmentDensityMap", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentDensityMapDynamic, settings, "VkBool32", "fragmentDensityMapDynamic", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentDensityMapNonSubsampledImages, settings, "VkBool32", "fragmentDensityMapNonSubsampledImages", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkRefreshCycleDurationGOOGLE(const VkRefreshCycleDurationGOOGLE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint64_t>(object.refreshDuration, settings, "uint64_t", "refreshDuration", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceImageFormatInfo2(const VkPhysicalDeviceImageFormatInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkImageType>(object.type, settings, "VkImageType", "type", indents + 1, dump_html_VkImageType);
    dump_html_value<const VkImageTiling>(object.tiling, settings, "VkImageTiling", "tiling", indents + 1, dump_html_VkImageTiling);
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkImageCreateFlags>(object.flags, settings, "VkImageCreateFlags", "flags", indents + 1, dump_html_VkImageCreateFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceImageViewImageFormatInfoEXT(const VkPhysicalDeviceImageViewImageFormatInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageViewType>(object.imageViewType, settings, "VkImageViewType", "imageViewType", indents + 1, dump_html_VkImageViewType);
    return settings.stream();
}
std::ostream& dump_html_VkRenderPassCreateInfo(const VkRenderPassCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPassCreateFlags>(object.flags, settings, "VkRenderPassCreateFlags", "flags", indents + 1, dump_html_VkRenderPassCreateFlags);
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentDescription>(object.pAttachments, object.attachmentCount, settings, "const VkAttachmentDescription*", "const VkAttachmentDescription", "pAttachments", indents + 1, dump_html_VkAttachmentDescription);
    dump_html_value<const uint32_t>(object.subpassCount, settings, "uint32_t", "subpassCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassDescription>(object.pSubpasses, object.subpassCount, settings, "const VkSubpassDescription*", "const VkSubpassDescription", "pSubpasses", indents + 1, dump_html_VkSubpassDescription);
    dump_html_value<const uint32_t>(object.dependencyCount, settings, "uint32_t", "dependencyCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassDependency>(object.pDependencies, object.dependencyCount, settings, "const VkSubpassDependency*", "const VkSubpassDependency", "pDependencies", indents + 1, dump_html_VkSubpassDependency);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(const VkPhysicalDeviceFragmentDensityMapPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.minFragmentDensityTexelSize, settings, "VkExtent2D", "minFragmentDensityTexelSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxFragmentDensityTexelSize, settings, "VkExtent2D", "maxFragmentDensityTexelSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkBool32>(object.fragmentDensityInvocations, settings, "VkBool32", "fragmentDensityInvocations", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkAttachmentDescription(const VkAttachmentDescription& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkAttachmentDescriptionFlags>(object.flags, settings, "VkAttachmentDescriptionFlags", "flags", indents + 1, dump_html_VkAttachmentDescriptionFlags);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkSampleCountFlagBits>(object.samples, settings, "VkSampleCountFlagBits", "samples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkAttachmentLoadOp>(object.loadOp, settings, "VkAttachmentLoadOp", "loadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.storeOp, settings, "VkAttachmentStoreOp", "storeOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkAttachmentLoadOp>(object.stencilLoadOp, settings, "VkAttachmentLoadOp", "stencilLoadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.stencilStoreOp, settings, "VkAttachmentStoreOp", "stencilStoreOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkImageLayout>(object.initialLayout, settings, "VkImageLayout", "initialLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.finalLayout, settings, "VkImageLayout", "finalLayout", indents + 1, dump_html_VkImageLayout);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayPresentInfoKHR(const VkDisplayPresentInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRect2D>(object.srcRect, settings, "VkRect2D", "srcRect", indents + 1, dump_html_VkRect2D);
    dump_html_value<const VkRect2D>(object.dstRect, settings, "VkRect2D", "dstRect", indents + 1, dump_html_VkRect2D);
    dump_html_value<const VkBool32>(object.persistent, settings, "VkBool32", "persistent", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPastPresentationTimingGOOGLE(const VkPastPresentationTimingGOOGLE& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.presentID, settings, "uint32_t", "presentID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.desiredPresentTime, settings, "uint64_t", "desiredPresentTime", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.actualPresentTime, settings, "uint64_t", "actualPresentTime", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.earliestPresentTime, settings, "uint64_t", "earliestPresentTime", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.presentMargin, settings, "uint64_t", "presentMargin", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkQueueFamilyProperties2(const VkQueueFamilyProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueueFamilyProperties>(object.queueFamilyProperties, settings, "VkQueueFamilyProperties", "queueFamilyProperties", indents + 1, dump_html_VkQueueFamilyProperties);
    return settings.stream();
}
std::ostream& dump_html_VkImageResolve(const VkImageResolve& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.srcOffset, settings, "VkOffset3D", "srcOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.dstOffset, settings, "VkOffset3D", "dstOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineExecutableInternalRepresentationKHR(const VkPipelineExecutableInternalRepresentationKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.name, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "name", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const VkBool32>(object.isText, settings, "VkBool32", "isText", indents + 1, dump_html_VkBool32);
    dump_html_value<const size_t>(object.dataSize, settings, "size_t", "dataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pData, settings, "void*", "pData", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkHdrMetadataEXT(const VkHdrMetadataEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkXYColorEXT>(object.displayPrimaryRed, settings, "VkXYColorEXT", "displayPrimaryRed", indents + 1, dump_html_VkXYColorEXT);
    dump_html_value<const VkXYColorEXT>(object.displayPrimaryGreen, settings, "VkXYColorEXT", "displayPrimaryGreen", indents + 1, dump_html_VkXYColorEXT);
    dump_html_value<const VkXYColorEXT>(object.displayPrimaryBlue, settings, "VkXYColorEXT", "displayPrimaryBlue", indents + 1, dump_html_VkXYColorEXT);
    dump_html_value<const VkXYColorEXT>(object.whitePoint, settings, "VkXYColorEXT", "whitePoint", indents + 1, dump_html_VkXYColorEXT);
    dump_html_value<const float>(object.maxLuminance, settings, "float", "maxLuminance", indents + 1, dump_html_float);
    dump_html_value<const float>(object.minLuminance, settings, "float", "minLuminance", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxContentLightLevel, settings, "float", "maxContentLightLevel", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxFrameAverageLightLevel, settings, "float", "maxFrameAverageLightLevel", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkCmdReserveSpaceForCommandsInfoNVX(const VkCmdReserveSpaceForCommandsInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkObjectTableNVX>(object.objectTable, settings, "VkObjectTableNVX", "objectTable", indents + 1, dump_html_VkObjectTableNVX);
    dump_html_value<const VkIndirectCommandsLayoutNVX>(object.indirectCommandsLayout, settings, "VkIndirectCommandsLayoutNVX", "indirectCommandsLayout", indents + 1, dump_html_VkIndirectCommandsLayoutNVX);
    dump_html_value<const uint32_t>(object.maxSequencesCount, settings, "uint32_t", "maxSequencesCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayModeParametersKHR(const VkDisplayModeParametersKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkExtent2D>(object.visibleRegion, settings, "VkExtent2D", "visibleRegion", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.refreshRate, settings, "uint32_t", "refreshRate", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayModePropertiesKHR(const VkDisplayModePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDisplayModeKHR>(object.displayMode, settings, "VkDisplayModeKHR", "displayMode", indents + 1, dump_html_VkDisplayModeKHR);
    dump_html_value<const VkDisplayModeParametersKHR>(object.parameters, settings, "VkDisplayModeParametersKHR", "parameters", indents + 1, dump_html_VkDisplayModeParametersKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceMemoryProperties2(const VkPhysicalDeviceMemoryProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPhysicalDeviceMemoryProperties>(object.memoryProperties, settings, "VkPhysicalDeviceMemoryProperties", "memoryProperties", indents + 1, dump_html_VkPhysicalDeviceMemoryProperties);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayPlaneCapabilities2KHR(const VkDisplayPlaneCapabilities2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayPlaneCapabilitiesKHR>(object.capabilities, settings, "VkDisplayPlaneCapabilitiesKHR", "capabilities", indents + 1, dump_html_VkDisplayPlaneCapabilitiesKHR);
    return settings.stream();
}
std::ostream& dump_html_VkTextureLODGatherFormatPropertiesAMD(const VkTextureLODGatherFormatPropertiesAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.supportsTextureGatherLODBiasAMD, settings, "VkBool32", "supportsTextureGatherLODBiasAMD", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSurfaceCapabilitiesKHR(const VkSurfaceCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.minImageCount, settings, "uint32_t", "minImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxImageCount, settings, "uint32_t", "maxImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkExtent2D>(object.currentExtent, settings, "VkExtent2D", "currentExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.minImageExtent, settings, "VkExtent2D", "minImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxImageExtent, settings, "VkExtent2D", "maxImageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.maxImageArrayLayers, settings, "uint32_t", "maxImageArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSurfaceTransformFlagsKHR>(object.supportedTransforms, settings, "VkSurfaceTransformFlagsKHR", "supportedTransforms", indents + 1, dump_html_VkSurfaceTransformFlagsKHR);
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.currentTransform, settings, "VkSurfaceTransformFlagBitsKHR", "currentTransform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const VkCompositeAlphaFlagsKHR>(object.supportedCompositeAlpha, settings, "VkCompositeAlphaFlagsKHR", "supportedCompositeAlpha", indents + 1, dump_html_VkCompositeAlphaFlagsKHR);
    dump_html_value<const VkImageUsageFlags>(object.supportedUsageFlags, settings, "VkImageUsageFlags", "supportedUsageFlags", indents + 1, dump_html_VkImageUsageFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineRasterizationDepthClipStateCreateInfoEXT(const VkPipelineRasterizationDepthClipStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRasterizationDepthClipStateCreateFlagsEXT>(object.flags, settings, "VkPipelineRasterizationDepthClipStateCreateFlagsEXT", "flags", indents + 1, dump_html_VkPipelineRasterizationDepthClipStateCreateFlagsEXT);
    dump_html_value<const VkBool32>(object.depthClipEnable, settings, "VkBool32", "depthClipEnable", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSparseImageFormatProperties2(const VkSparseImageFormatProperties2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSparseImageFormatProperties>(object.properties, settings, "VkSparseImageFormatProperties", "properties", indents + 1, dump_html_VkSparseImageFormatProperties);
    return settings.stream();
}
std::ostream& dump_html_VkXYColorEXT(const VkXYColorEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.x, settings, "float", "x", indents + 1, dump_html_float);
    dump_html_value<const float>(object.y, settings, "float", "y", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayPlaneInfo2KHR(const VkDisplayPlaneInfo2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDisplayModeKHR>(object.mode, settings, "VkDisplayModeKHR", "mode", indents + 1, dump_html_VkDisplayModeKHR);
    dump_html_value<const uint32_t>(object.planeIndex, settings, "uint32_t", "planeIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkObjectTableCreateInfoNVX(const VkObjectTableCreateInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.objectCount, settings, "uint32_t", "objectCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkObjectEntryTypeNVX>(object.pObjectEntryTypes, object.objectCount, settings, "const VkObjectEntryTypeNVX*", "const VkObjectEntryTypeNVX", "pObjectEntryTypes", indents + 1, dump_html_VkObjectEntryTypeNVX);
    dump_html_array<const uint32_t>(object.pObjectEntryCounts, object.objectCount, settings, "const uint32_t*", "const uint32_t", "pObjectEntryCounts", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkObjectEntryUsageFlagsNVX>(object.pObjectEntryUsageFlags, object.objectCount, settings, "const VkObjectEntryUsageFlagsNVX*", "const VkObjectEntryUsageFlagsNVX", "pObjectEntryUsageFlags", indents + 1, dump_html_VkObjectEntryUsageFlagsNVX);
    dump_html_value<const uint32_t>(object.maxUniformBuffersPerDescriptor, settings, "uint32_t", "maxUniformBuffersPerDescriptor", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStorageBuffersPerDescriptor, settings, "uint32_t", "maxStorageBuffersPerDescriptor", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxStorageImagesPerDescriptor, settings, "uint32_t", "maxStorageImagesPerDescriptor", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxSampledImagesPerDescriptor, settings, "uint32_t", "maxSampledImagesPerDescriptor", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPipelineLayouts, settings, "uint32_t", "maxPipelineLayouts", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkShaderStatisticsInfoAMD(const VkShaderStatisticsInfoAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkShaderStageFlags>(object.shaderStageMask, settings, "VkShaderStageFlags", "shaderStageMask", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkShaderResourceUsageAMD>(object.resourceUsage, settings, "VkShaderResourceUsageAMD", "resourceUsage", indents + 1, dump_html_VkShaderResourceUsageAMD);
    dump_html_value<const uint32_t>(object.numPhysicalVgprs, settings, "uint32_t", "numPhysicalVgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.numPhysicalSgprs, settings, "uint32_t", "numPhysicalSgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.numAvailableVgprs, settings, "uint32_t", "numAvailableVgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.numAvailableSgprs, settings, "uint32_t", "numAvailableSgprs", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.computeWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "computeWorkGroupSize", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSparseImageFormatInfo2(const VkPhysicalDeviceSparseImageFormatInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkImageType>(object.type, settings, "VkImageType", "type", indents + 1, dump_html_VkImageType);
    dump_html_value<const VkSampleCountFlagBits>(object.samples, settings, "VkSampleCountFlagBits", "samples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkImageTiling>(object.tiling, settings, "VkImageTiling", "tiling", indents + 1, dump_html_VkImageTiling);
    return settings.stream();
}
std::ostream& dump_html_VkShaderResourceUsageAMD(const VkShaderResourceUsageAMD& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.numUsedVgprs, settings, "uint32_t", "numUsedVgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.numUsedSgprs, settings, "uint32_t", "numUsedSgprs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.ldsSizePerLocalWorkGroup, settings, "uint32_t", "ldsSizePerLocalWorkGroup", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.ldsUsageSizeInBytes, settings, "size_t", "ldsUsageSizeInBytes", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.scratchMemUsageInBytes, settings, "size_t", "scratchMemUsageInBytes", indents + 1, dump_html_size_t);
    return settings.stream();
}
std::ostream& dump_html_VkObjectTableEntryNVX(const VkObjectTableEntryNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkObjectEntryTypeNVX>(object.type, settings, "VkObjectEntryTypeNVX", "type", indents + 1, dump_html_VkObjectEntryTypeNVX);
    dump_html_value<const VkObjectEntryUsageFlagsNVX>(object.flags, settings, "VkObjectEntryUsageFlagsNVX", "flags", indents + 1, dump_html_VkObjectEntryUsageFlagsNVX);
    return settings.stream();
}
std::ostream& dump_html_VkDisplayPlaneCapabilitiesKHR(const VkDisplayPlaneCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDisplayPlaneAlphaFlagsKHR>(object.supportedAlpha, settings, "VkDisplayPlaneAlphaFlagsKHR", "supportedAlpha", indents + 1, dump_html_VkDisplayPlaneAlphaFlagsKHR);
    dump_html_value<const VkOffset2D>(object.minSrcPosition, settings, "VkOffset2D", "minSrcPosition", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkOffset2D>(object.maxSrcPosition, settings, "VkOffset2D", "maxSrcPosition", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.minSrcExtent, settings, "VkExtent2D", "minSrcExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxSrcExtent, settings, "VkExtent2D", "maxSrcExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkOffset2D>(object.minDstPosition, settings, "VkOffset2D", "minDstPosition", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkOffset2D>(object.maxDstPosition, settings, "VkOffset2D", "maxDstPosition", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.minDstExtent, settings, "VkExtent2D", "minDstExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const VkExtent2D>(object.maxDstExtent, settings, "VkExtent2D", "maxDstExtent", indents + 1, dump_html_VkExtent2D);
    return settings.stream();
}
std::ostream& dump_html_VkHeadlessSurfaceCreateInfoEXT(const VkHeadlessSurfaceCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkHeadlessSurfaceCreateFlagsEXT>(object.flags, settings, "VkHeadlessSurfaceCreateFlagsEXT", "flags", indents + 1, dump_html_VkHeadlessSurfaceCreateFlagsEXT);
    return settings.stream();
}
std::ostream& dump_html_VkBufferMemoryBarrier(const VkBufferMemoryBarrier& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const uint32_t>(object.srcQueueFamilyIndex, settings, "uint32_t", "srcQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstQueueFamilyIndex, settings, "uint32_t", "dstQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryBarrier(const VkMemoryBarrier& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceLineRasterizationFeaturesEXT(const VkPhysicalDeviceLineRasterizationFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.rectangularLines, settings, "VkBool32", "rectangularLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.bresenhamLines, settings, "VkBool32", "bresenhamLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.smoothLines, settings, "VkBool32", "smoothLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.stippledRectangularLines, settings, "VkBool32", "stippledRectangularLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.stippledBresenhamLines, settings, "VkBool32", "stippledBresenhamLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.stippledSmoothLines, settings, "VkBool32", "stippledSmoothLines", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkComputePipelineCreateInfo(const VkComputePipelineCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags>(object.flags, settings, "VkPipelineCreateFlags", "flags", indents + 1, dump_html_VkPipelineCreateFlags);
    dump_html_value<const VkPipelineShaderStageCreateInfo>(object.stage, settings, "VkPipelineShaderStageCreateInfo", "stage", indents + 1, dump_html_VkPipelineShaderStageCreateInfo);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkPipeline>(object.basePipelineHandle, settings, "VkPipeline", "basePipelineHandle", indents + 1, dump_html_VkPipeline);
    dump_html_value<const int32_t>(object.basePipelineIndex, settings, "int32_t", "basePipelineIndex", indents + 1, dump_html_int32_t);
    return settings.stream();
}
std::ostream& dump_html_VkImageMemoryBarrier(const VkImageMemoryBarrier& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkImageLayout>(object.oldLayout, settings, "VkImageLayout", "oldLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.newLayout, settings, "VkImageLayout", "newLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const uint32_t>(object.srcQueueFamilyIndex, settings, "uint32_t", "srcQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstQueueFamilyIndex, settings, "uint32_t", "dstQueueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageSubresourceRange>(object.subresourceRange, settings, "VkImageSubresourceRange", "subresourceRange", indents + 1, dump_html_VkImageSubresourceRange);
    return settings.stream();
}
std::ostream& dump_html_VkSurfaceFormatKHR(const VkSurfaceFormatKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkColorSpaceKHR>(object.colorSpace, settings, "VkColorSpaceKHR", "colorSpace", indents + 1, dump_html_VkColorSpaceKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceLineRasterizationPropertiesEXT(const VkPhysicalDeviceLineRasterizationPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.lineSubPixelPrecisionBits, settings, "uint32_t", "lineSubPixelPrecisionBits", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT(const VkPhysicalDeviceShaderDemoteToHelperInvocationFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderDemoteToHelperInvocation, settings, "VkBool32", "shaderDemoteToHelperInvocation", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceImagelessFramebufferFeaturesKHR(const VkPhysicalDeviceImagelessFramebufferFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.imagelessFramebuffer, settings, "VkBool32", "imagelessFramebuffer", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkObjectTablePipelineEntryNVX(const VkObjectTablePipelineEntryNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkObjectEntryTypeNVX>(object.type, settings, "VkObjectEntryTypeNVX", "type", indents + 1, dump_html_VkObjectEntryTypeNVX);
    dump_html_value<const VkObjectEntryUsageFlagsNVX>(object.flags, settings, "VkObjectEntryUsageFlagsNVX", "flags", indents + 1, dump_html_VkObjectEntryUsageFlagsNVX);
    dump_html_value<const VkPipeline>(object.pipeline, settings, "VkPipeline", "pipeline", indents + 1, dump_html_VkPipeline);
    return settings.stream();
}
std::ostream& dump_html_VkObjectTableVertexBufferEntryNVX(const VkObjectTableVertexBufferEntryNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkObjectEntryTypeNVX>(object.type, settings, "VkObjectEntryTypeNVX", "type", indents + 1, dump_html_VkObjectEntryTypeNVX);
    dump_html_value<const VkObjectEntryUsageFlagsNVX>(object.flags, settings, "VkObjectEntryUsageFlagsNVX", "flags", indents + 1, dump_html_VkObjectEntryUsageFlagsNVX);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    return settings.stream();
}
std::ostream& dump_html_VkCommandPoolCreateInfo(const VkCommandPoolCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCommandPoolCreateFlags>(object.flags, settings, "VkCommandPoolCreateFlags", "flags", indents + 1, dump_html_VkCommandPoolCreateFlags);
    dump_html_value<const uint32_t>(object.queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkObjectTableDescriptorSetEntryNVX(const VkObjectTableDescriptorSetEntryNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkObjectEntryTypeNVX>(object.type, settings, "VkObjectEntryTypeNVX", "type", indents + 1, dump_html_VkObjectEntryTypeNVX);
    dump_html_value<const VkObjectEntryUsageFlagsNVX>(object.flags, settings, "VkObjectEntryUsageFlagsNVX", "flags", indents + 1, dump_html_VkObjectEntryUsageFlagsNVX);
    dump_html_value<const VkPipelineLayout>(object.pipelineLayout, settings, "VkPipelineLayout", "pipelineLayout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkDescriptorSet>(object.descriptorSet, settings, "VkDescriptorSet", "descriptorSet", indents + 1, dump_html_VkDescriptorSet);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
std::ostream& dump_html_VkXlibSurfaceCreateInfoKHR(const VkXlibSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkXlibSurfaceCreateFlagsKHR>(object.flags, settings, "VkXlibSurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkXlibSurfaceCreateFlagsKHR);
    dump_html_value<const Display*>(object.dpy, settings, "Display*", "dpy", indents + 1, dump_html_Display);
    dump_html_value<const Window>(object.window, settings, "Window", "window", indents + 1, dump_html_Window);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_XLIB_KHR
std::ostream& dump_html_VkPipelineRasterizationLineStateCreateInfoEXT(const VkPipelineRasterizationLineStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkLineRasterizationModeEXT>(object.lineRasterizationMode, settings, "VkLineRasterizationModeEXT", "lineRasterizationMode", indents + 1, dump_html_VkLineRasterizationModeEXT);
    dump_html_value<const VkBool32>(object.stippledLineEnable, settings, "VkBool32", "stippledLineEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.lineStippleFactor, settings, "uint32_t", "lineStippleFactor", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint16_t>(object.lineStipplePattern, settings, "uint16_t", "lineStipplePattern", indents + 1, dump_html_uint16_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.texelBufferAlignment, settings, "VkBool32", "texelBufferAlignment", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPushConstantRange(const VkPushConstantRange& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.size, settings, "uint32_t", "size", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkFramebufferAttachmentsCreateInfoKHR(const VkFramebufferAttachmentsCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachmentImageInfoCount, settings, "uint32_t", "attachmentImageInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFramebufferAttachmentImageInfoKHR>(object.pAttachmentImageInfos, object.attachmentImageInfoCount, settings, "const VkFramebufferAttachmentImageInfoKHR*", "const VkFramebufferAttachmentImageInfoKHR", "pAttachmentImageInfos", indents + 1, dump_html_VkFramebufferAttachmentImageInfoKHR);
    return settings.stream();
}
std::ostream& dump_html_VkObjectTableIndexBufferEntryNVX(const VkObjectTableIndexBufferEntryNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkObjectEntryTypeNVX>(object.type, settings, "VkObjectEntryTypeNVX", "type", indents + 1, dump_html_VkObjectEntryTypeNVX);
    dump_html_value<const VkObjectEntryUsageFlagsNVX>(object.flags, settings, "VkObjectEntryUsageFlagsNVX", "flags", indents + 1, dump_html_VkObjectEntryUsageFlagsNVX);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkIndexType>(object.indexType, settings, "VkIndexType", "indexType", indents + 1, dump_html_VkIndexType);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineLayoutCreateInfo(const VkPipelineLayoutCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineLayoutCreateFlags>(object.flags, settings, "VkPipelineLayoutCreateFlags", "flags", indents + 1, dump_html_VkPipelineLayoutCreateFlags);
    dump_html_value<const uint32_t>(object.setLayoutCount, settings, "uint32_t", "setLayoutCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorSetLayout>(object.pSetLayouts, object.setLayoutCount, settings, "const VkDescriptorSetLayout*", "const VkDescriptorSetLayout", "pSetLayouts", indents + 1, dump_html_VkDescriptorSetLayout);
    dump_html_value<const uint32_t>(object.pushConstantRangeCount, settings, "uint32_t", "pushConstantRangeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPushConstantRange>(object.pPushConstantRanges, object.pushConstantRangeCount, settings, "const VkPushConstantRange*", "const VkPushConstantRange", "pPushConstantRanges", indents + 1, dump_html_VkPushConstantRange);
    return settings.stream();
}
std::ostream& dump_html_VkFramebufferAttachmentImageInfoKHR(const VkFramebufferAttachmentImageInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageCreateFlags>(object.flags, settings, "VkImageCreateFlags", "flags", indents + 1, dump_html_VkImageCreateFlags);
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.viewFormatCount, settings, "uint32_t", "viewFormatCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkFormat>(object.pViewFormats, object.viewFormatCount, settings, "const VkFormat*", "const VkFormat", "pViewFormats", indents + 1, dump_html_VkFormat);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceHostQueryResetFeaturesEXT(const VkPhysicalDeviceHostQueryResetFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.hostQueryReset, settings, "VkBool32", "hostQueryReset", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT(const VkPhysicalDeviceTexelBufferAlignmentPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.storageTexelBufferOffsetAlignmentBytes, settings, "VkDeviceSize", "storageTexelBufferOffsetAlignmentBytes", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBool32>(object.storageTexelBufferOffsetSingleTexelAlignment, settings, "VkBool32", "storageTexelBufferOffsetSingleTexelAlignment", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkDeviceSize>(object.uniformTexelBufferOffsetAlignmentBytes, settings, "VkDeviceSize", "uniformTexelBufferOffsetAlignmentBytes", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBool32>(object.uniformTexelBufferOffsetSingleTexelAlignment, settings, "VkBool32", "uniformTexelBufferOffsetSingleTexelAlignment", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
std::ostream& dump_html_VkIOSSurfaceCreateInfoMVK(const VkIOSSurfaceCreateInfoMVK& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkIOSSurfaceCreateFlagsMVK>(object.flags, settings, "VkIOSSurfaceCreateFlagsMVK", "flags", indents + 1, dump_html_VkIOSSurfaceCreateFlagsMVK);
    dump_html_value<const void*>(object.pView, settings, "const void*", "pView", indents + 1, dump_html_void);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_IOS_MVK
std::ostream& dump_html_VkObjectTablePushConstantEntryNVX(const VkObjectTablePushConstantEntryNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkObjectEntryTypeNVX>(object.type, settings, "VkObjectEntryTypeNVX", "type", indents + 1, dump_html_VkObjectEntryTypeNVX);
    dump_html_value<const VkObjectEntryUsageFlagsNVX>(object.flags, settings, "VkObjectEntryUsageFlagsNVX", "flags", indents + 1, dump_html_VkObjectEntryUsageFlagsNVX);
    dump_html_value<const VkPipelineLayout>(object.pipelineLayout, settings, "VkPipelineLayout", "pipelineLayout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceTransformFeedbackPropertiesEXT(const VkPhysicalDeviceTransformFeedbackPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxTransformFeedbackStreams, settings, "uint32_t", "maxTransformFeedbackStreams", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTransformFeedbackBuffers, settings, "uint32_t", "maxTransformFeedbackBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.maxTransformFeedbackBufferSize, settings, "VkDeviceSize", "maxTransformFeedbackBufferSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.maxTransformFeedbackStreamDataSize, settings, "uint32_t", "maxTransformFeedbackStreamDataSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTransformFeedbackBufferDataSize, settings, "uint32_t", "maxTransformFeedbackBufferDataSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTransformFeedbackBufferDataStride, settings, "uint32_t", "maxTransformFeedbackBufferDataStride", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.transformFeedbackQueries, settings, "VkBool32", "transformFeedbackQueries", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.transformFeedbackStreamsLinesTriangles, settings, "VkBool32", "transformFeedbackStreamsLinesTriangles", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.transformFeedbackRasterizationStreamSelect, settings, "VkBool32", "transformFeedbackRasterizationStreamSelect", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.transformFeedbackDraw, settings, "VkBool32", "transformFeedbackDraw", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDevicePointClippingProperties(const VkPhysicalDevicePointClippingProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPointClippingBehavior>(object.pointClippingBehavior, settings, "VkPointClippingBehavior", "pointClippingBehavior", indents + 1, dump_html_VkPointClippingBehavior);
    return settings.stream();
}
std::ostream& dump_html_VkRenderPassAttachmentBeginInfoKHR(const VkRenderPassAttachmentBeginInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkImageView>(object.pAttachments, object.attachmentCount, settings, "const VkImageView*", "const VkImageView", "pAttachments", indents + 1, dump_html_VkImageView);
    return settings.stream();
}
std::ostream& dump_html_VkRenderPassInputAttachmentAspectCreateInfo(const VkRenderPassInputAttachmentAspectCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.aspectReferenceCount, settings, "uint32_t", "aspectReferenceCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkInputAttachmentAspectReference>(object.pAspectReferences, object.aspectReferenceCount, settings, "const VkInputAttachmentAspectReference*", "const VkInputAttachmentAspectReference", "pAspectReferences", indents + 1, dump_html_VkInputAttachmentAspectReference);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceTransformFeedbackFeaturesEXT(const VkPhysicalDeviceTransformFeedbackFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.transformFeedback, settings, "VkBool32", "transformFeedback", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.geometryStreams, settings, "VkBool32", "geometryStreams", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_GGP)
std::ostream& dump_html_VkStreamDescriptorSurfaceCreateInfoGGP(const VkStreamDescriptorSurfaceCreateInfoGGP& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkStreamDescriptorSurfaceCreateFlagsGGP>(object.flags, settings, "VkStreamDescriptorSurfaceCreateFlagsGGP", "flags", indents + 1, dump_html_VkStreamDescriptorSurfaceCreateFlagsGGP);
    dump_html_value<const GgpStreamDescriptor>(object.streamDescriptor, settings, "GgpStreamDescriptor", "streamDescriptor", indents + 1, dump_html_GgpStreamDescriptor);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_GGP
std::ostream& dump_html_VkCommandBufferAllocateInfo(const VkCommandBufferAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCommandPool>(object.commandPool, settings, "VkCommandPool", "commandPool", indents + 1, dump_html_VkCommandPool);
    dump_html_value<const VkCommandBufferLevel>(object.level, settings, "VkCommandBufferLevel", "level", indents + 1, dump_html_VkCommandBufferLevel);
    dump_html_value<const uint32_t>(object.commandBufferCount, settings, "uint32_t", "commandBufferCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxVertexAttribDivisor, settings, "uint32_t", "maxVertexAttribDivisor", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkFormatProperties(const VkFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkFormatFeatureFlags>(object.linearTilingFeatures, settings, "VkFormatFeatureFlags", "linearTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkFormatFeatureFlags>(object.optimalTilingFeatures, settings, "VkFormatFeatureFlags", "optimalTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkFormatFeatureFlags>(object.bufferFeatures, settings, "VkFormatFeatureFlags", "bufferFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    return settings.stream();
}
std::ostream& dump_html_VkBindBufferMemoryInfo(const VkBindBufferMemoryInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceRayTracingPropertiesNV(const VkPhysicalDeviceRayTracingPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.shaderGroupHandleSize, settings, "uint32_t", "shaderGroupHandleSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxRecursionDepth, settings, "uint32_t", "maxRecursionDepth", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxShaderGroupStride, settings, "uint32_t", "maxShaderGroupStride", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderGroupBaseAlignment, settings, "uint32_t", "shaderGroupBaseAlignment", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.maxGeometryCount, settings, "uint64_t", "maxGeometryCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.maxInstanceCount, settings, "uint64_t", "maxInstanceCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.maxTriangleCount, settings, "uint64_t", "maxTriangleCount", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetAccelerationStructures, settings, "uint32_t", "maxDescriptorSetAccelerationStructures", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkVertexInputBindingDivisorDescriptionEXT(const VkVertexInputBindingDivisorDescriptionEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.divisor, settings, "uint32_t", "divisor", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkSparseImageMemoryBindInfo(const VkSparseImageMemoryBindInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const uint32_t>(object.bindCount, settings, "uint32_t", "bindCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSparseImageMemoryBind>(object.pBinds, object.bindCount, settings, "const VkSparseImageMemoryBind*", "const VkSparseImageMemoryBind", "pBinds", indents + 1, dump_html_VkSparseImageMemoryBind);
    return settings.stream();
}
std::ostream& dump_html_VkAccelerationStructureMemoryRequirementsInfoNV(const VkAccelerationStructureMemoryRequirementsInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureMemoryRequirementsTypeNV>(object.type, settings, "VkAccelerationStructureMemoryRequirementsTypeNV", "type", indents + 1, dump_html_VkAccelerationStructureMemoryRequirementsTypeNV);
    dump_html_value<const VkAccelerationStructureNV>(object.accelerationStructure, settings, "VkAccelerationStructureNV", "accelerationStructure", indents + 1, dump_html_VkAccelerationStructureNV);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceCornerSampledImageFeaturesNV(const VkPhysicalDeviceCornerSampledImageFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.cornerSampledImage, settings, "VkBool32", "cornerSampledImage", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkOffset3D(const VkOffset3D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const int32_t>(object.x, settings, "int32_t", "x", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.y, settings, "int32_t", "y", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.z, settings, "int32_t", "z", indents + 1, dump_html_int32_t);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_GGP)
std::ostream& dump_html_VkPresentFrameTokenGGP(const VkPresentFrameTokenGGP& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const GgpFrameToken>(object.frameToken, settings, "GgpFrameToken", "frameToken", indents + 1, dump_html_GgpFrameToken);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_GGP
std::ostream& dump_html_VkInstanceCreateInfo(const VkInstanceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkInstanceCreateFlags>(object.flags, settings, "VkInstanceCreateFlags", "flags", indents + 1, dump_html_VkInstanceCreateFlags);
    dump_html_pointer<const VkApplicationInfo>(object.pApplicationInfo, settings, "const VkApplicationInfo*", "pApplicationInfo", indents + 1, dump_html_VkApplicationInfo);
    dump_html_value<const uint32_t>(object.enabledLayerCount, settings, "uint32_t", "enabledLayerCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const char*>(object.ppEnabledLayerNames, object.enabledLayerCount, settings, "const char* const*", "const char* const", "ppEnabledLayerNames", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.enabledExtensionCount, settings, "uint32_t", "enabledExtensionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const char*>(object.ppEnabledExtensionNames, object.enabledExtensionCount, settings, "const char* const*", "const char* const", "ppEnabledExtensionNames", indents + 1, dump_html_cstring);
    return settings.stream();
}
std::ostream& dump_html_VkImageSubresource(const VkImageSubresource& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const uint32_t>(object.mipLevel, settings, "uint32_t", "mipLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.arrayLayer, settings, "uint32_t", "arrayLayer", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkBufferCopy(const VkBufferCopy& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.srcOffset, settings, "VkDeviceSize", "srcOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.dstOffset, settings, "VkDeviceSize", "dstOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkSparseImageMemoryBind(const VkSparseImageMemoryBind& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageSubresource>(object.subresource, settings, "VkImageSubresource", "subresource", indents + 1, dump_html_VkImageSubresource);
    dump_html_value<const VkOffset3D>(object.offset, settings, "VkOffset3D", "offset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkSparseMemoryBindFlags>(object.flags, settings, "VkSparseMemoryBindFlags", "flags", indents + 1, dump_html_VkSparseMemoryBindFlags);
    return settings.stream();
}
std::ostream& dump_html_VkBindImageMemoryInfo(const VkBindImageMemoryInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineVertexInputDivisorStateCreateInfoEXT(const VkPipelineVertexInputDivisorStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.vertexBindingDivisorCount, settings, "uint32_t", "vertexBindingDivisorCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVertexInputBindingDivisorDescriptionEXT>(object.pVertexBindingDivisors, object.vertexBindingDivisorCount, settings, "const VkVertexInputBindingDivisorDescriptionEXT*", "const VkVertexInputBindingDivisorDescriptionEXT", "pVertexBindingDivisors", indents + 1, dump_html_VkVertexInputBindingDivisorDescriptionEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.vertexAttributeInstanceRateDivisor, settings, "VkBool32", "vertexAttributeInstanceRateDivisor", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vertexAttributeInstanceRateZeroDivisor, settings, "VkBool32", "vertexAttributeInstanceRateZeroDivisor", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDevice16BitStorageFeatures(const VkPhysicalDevice16BitStorageFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.storageBuffer16BitAccess, settings, "VkBool32", "storageBuffer16BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.uniformAndStorageBuffer16BitAccess, settings, "VkBool32", "uniformAndStorageBuffer16BitAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storagePushConstant16, settings, "VkBool32", "storagePushConstant16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.storageInputOutput16, settings, "VkBool32", "storageInputOutput16", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkImageCopy(const VkImageCopy& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.srcOffset, settings, "VkOffset3D", "srcOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.dstOffset, settings, "VkOffset3D", "dstOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
    return settings.stream();
}
std::ostream& dump_html_VkExternalImageFormatPropertiesNV(const VkExternalImageFormatPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageFormatProperties>(object.imageFormatProperties, settings, "VkImageFormatProperties", "imageFormatProperties", indents + 1, dump_html_VkImageFormatProperties);
    dump_html_value<const VkExternalMemoryFeatureFlagsNV>(object.externalMemoryFeatures, settings, "VkExternalMemoryFeatureFlagsNV", "externalMemoryFeatures", indents + 1, dump_html_VkExternalMemoryFeatureFlagsNV);
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.exportFromImportedHandleTypes, settings, "VkExternalMemoryHandleTypeFlagsNV", "exportFromImportedHandleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.compatibleHandleTypes, settings, "VkExternalMemoryHandleTypeFlagsNV", "compatibleHandleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
    return settings.stream();
}
std::ostream& dump_html_VkImageSubresourceLayers(const VkImageSubresourceLayers& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const uint32_t>(object.mipLevel, settings, "uint32_t", "mipLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.baseArrayLayer, settings, "uint32_t", "baseArrayLayer", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineCreationFeedbackCreateInfoEXT(const VkPipelineCreationFeedbackCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_pointer<const VkPipelineCreationFeedbackEXT>(object.pPipelineCreationFeedback, settings, "VkPipelineCreationFeedbackEXT*", "pPipelineCreationFeedback", indents + 1, dump_html_VkPipelineCreationFeedbackEXT);
    dump_html_value<const uint32_t>(object.pipelineStageCreationFeedbackCount, settings, "uint32_t", "pipelineStageCreationFeedbackCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineCreationFeedbackEXT>(object.pPipelineStageCreationFeedbacks, object.pipelineStageCreationFeedbackCount, settings, "VkPipelineCreationFeedbackEXT*", "VkPipelineCreationFeedbackEXT", "pPipelineStageCreationFeedbacks", indents + 1, dump_html_VkPipelineCreationFeedbackEXT);
    return settings.stream();
}
std::ostream& dump_html_VkExternalMemoryImageCreateInfoNV(const VkExternalMemoryImageCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlagsNV", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineCreationFeedbackEXT(const VkPipelineCreationFeedbackEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkPipelineCreationFeedbackFlagsEXT>(object.flags, settings, "VkPipelineCreationFeedbackFlagsEXT", "flags", indents + 1, dump_html_VkPipelineCreationFeedbackFlagsEXT);
    dump_html_value<const uint64_t>(object.duration, settings, "uint64_t", "duration", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGeneratedCommandsFeaturesNVX(const VkDeviceGeneratedCommandsFeaturesNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.computeBindingPointSupport, settings, "VkBool32", "computeBindingPointSupport", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGeneratedCommandsLimitsNVX(const VkDeviceGeneratedCommandsLimitsNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxIndirectCommandsLayoutTokenCount, settings, "uint32_t", "maxIndirectCommandsLayoutTokenCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxObjectEntryCounts, settings, "uint32_t", "maxObjectEntryCounts", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minSequenceCountBufferOffsetAlignment, settings, "uint32_t", "minSequenceCountBufferOffsetAlignment", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minSequenceIndexBufferOffsetAlignment, settings, "uint32_t", "minSequenceIndexBufferOffsetAlignment", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.minCommandsTokenBufferOffsetAlignment, settings, "uint32_t", "minCommandsTokenBufferOffsetAlignment", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkExportMemoryAllocateInfoNV(const VkExportMemoryAllocateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlagsNV", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryDedicatedRequirements(const VkMemoryDedicatedRequirements& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.prefersDedicatedAllocation, settings, "VkBool32", "prefersDedicatedAllocation", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.requiresDedicatedAllocation, settings, "VkBool32", "requiresDedicatedAllocation", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceDriverPropertiesKHR(const VkPhysicalDeviceDriverPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDriverIdKHR>(object.driverID, settings, "VkDriverIdKHR", "driverID", indents + 1, dump_html_VkDriverIdKHR);
    dump_html_value<const char*>(object.driverName, settings, "char[VK_MAX_DRIVER_NAME_SIZE_KHR]", "driverName", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.driverInfo, settings, "char[VK_MAX_DRIVER_INFO_SIZE_KHR]", "driverInfo", indents + 1, dump_html_cstring);
    dump_html_value<const VkConformanceVersionKHR>(object.conformanceVersion, settings, "VkConformanceVersionKHR", "conformanceVersion", indents + 1, dump_html_VkConformanceVersionKHR);
    return settings.stream();
}
std::ostream& dump_html_VkIndirectCommandsTokenNVX(const VkIndirectCommandsTokenNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkIndirectCommandsTokenTypeNVX>(object.tokenType, settings, "VkIndirectCommandsTokenTypeNVX", "tokenType", indents + 1, dump_html_VkIndirectCommandsTokenTypeNVX);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkImageBlit(const VkImageBlit& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageSubresourceLayers>(object.srcSubresource, settings, "VkImageSubresourceLayers", "srcSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_array<const VkOffset3D>(object.srcOffsets, 2, settings, "VkOffset3D[2]", "VkOffset3D", "srcOffsets", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkImageSubresourceLayers>(object.dstSubresource, settings, "VkImageSubresourceLayers", "dstSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_array<const VkOffset3D>(object.dstOffsets, 2, settings, "VkOffset3D[2]", "VkOffset3D", "dstOffsets", indents + 1, dump_html_VkOffset3D);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkImportMemoryWin32HandleInfoNV(const VkImportMemoryWin32HandleInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagsNV", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
    dump_html_value<const HANDLE>(object.handle, settings, "HANDLE", "handle", indents + 1, dump_html_HANDLE);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkFenceCreateInfo(const VkFenceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFenceCreateFlags>(object.flags, settings, "VkFenceCreateFlags", "flags", indents + 1, dump_html_VkFenceCreateFlags);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryDedicatedAllocateInfo(const VkMemoryDedicatedAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkExportMemoryWin32HandleInfoNV(const VkExportMemoryWin32HandleInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const SECURITY_ATTRIBUTES*>(object.pAttributes, settings, "const SECURITY_ATTRIBUTES*", "pAttributes", indents + 1, dump_html_SECURITY_ATTRIBUTES);
    dump_html_value<const DWORD>(object.dwAccess, settings, "DWORD", "dwAccess", indents + 1, dump_html_DWORD);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkConformanceVersionKHR(const VkConformanceVersionKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint8_t>(object.major, settings, "uint8_t", "major", indents + 1, dump_html_uint8_t);
    dump_html_value<const uint8_t>(object.minor, settings, "uint8_t", "minor", indents + 1, dump_html_uint8_t);
    dump_html_value<const uint8_t>(object.subminor, settings, "uint8_t", "subminor", indents + 1, dump_html_uint8_t);
    dump_html_value<const uint8_t>(object.patch, settings, "uint8_t", "patch", indents + 1, dump_html_uint8_t);
    return settings.stream();
}
std::ostream& dump_html_VkIndirectCommandsLayoutCreateInfoNVX(const VkIndirectCommandsLayoutCreateInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const VkIndirectCommandsLayoutUsageFlagsNVX>(object.flags, settings, "VkIndirectCommandsLayoutUsageFlagsNVX", "flags", indents + 1, dump_html_VkIndirectCommandsLayoutUsageFlagsNVX);
    dump_html_value<const uint32_t>(object.tokenCount, settings, "uint32_t", "tokenCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkIndirectCommandsLayoutTokenNVX>(object.pTokens, object.tokenCount, settings, "const VkIndirectCommandsLayoutTokenNVX*", "const VkIndirectCommandsLayoutTokenNVX", "pTokens", indents + 1, dump_html_VkIndirectCommandsLayoutTokenNVX);
    return settings.stream();
}
std::ostream& dump_html_VkIndirectCommandsLayoutTokenNVX(const VkIndirectCommandsLayoutTokenNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkIndirectCommandsTokenTypeNVX>(object.tokenType, settings, "VkIndirectCommandsTokenTypeNVX", "tokenType", indents + 1, dump_html_VkIndirectCommandsTokenTypeNVX);
    dump_html_value<const uint32_t>(object.bindingUnit, settings, "uint32_t", "bindingUnit", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dynamicCount, settings, "uint32_t", "dynamicCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.divisor, settings, "uint32_t", "divisor", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkWin32KeyedMutexAcquireReleaseInfoNV(const VkWin32KeyedMutexAcquireReleaseInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.acquireCount, settings, "uint32_t", "acquireCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceMemory>(object.pAcquireSyncs, object.acquireCount, settings, "const VkDeviceMemory*", "const VkDeviceMemory", "pAcquireSyncs", indents + 1, dump_html_VkDeviceMemory);
    dump_html_array<const uint64_t>(object.pAcquireKeys, object.acquireCount, settings, "const uint64_t*", "const uint64_t", "pAcquireKeys", indents + 1, dump_html_uint64_t);
    dump_html_array<const uint32_t>(object.pAcquireTimeoutMilliseconds, object.acquireCount, settings, "const uint32_t*", "const uint32_t", "pAcquireTimeoutMilliseconds", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.releaseCount, settings, "uint32_t", "releaseCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceMemory>(object.pReleaseSyncs, object.releaseCount, settings, "const VkDeviceMemory*", "const VkDeviceMemory", "pReleaseSyncs", indents + 1, dump_html_VkDeviceMemory);
    dump_html_array<const uint64_t>(object.pReleaseKeys, object.releaseCount, settings, "const uint64_t*", "const uint64_t", "pReleaseKeys", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkDeviceGroupRenderPassBeginInfo(const VkDeviceGroupRenderPassBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.deviceRenderAreaCount, settings, "uint32_t", "deviceRenderAreaCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pDeviceRenderAreas, object.deviceRenderAreaCount, settings, "const VkRect2D*", "const VkRect2D", "pDeviceRenderAreas", indents + 1, dump_html_VkRect2D);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryAllocateFlagsInfo(const VkMemoryAllocateFlagsInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMemoryAllocateFlags>(object.flags, settings, "VkMemoryAllocateFlags", "flags", indents + 1, dump_html_VkMemoryAllocateFlags);
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkBufferImageCopy(const VkBufferImageCopy& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.bufferOffset, settings, "VkDeviceSize", "bufferOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.bufferRowLength, settings, "uint32_t", "bufferRowLength", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.bufferImageHeight, settings, "uint32_t", "bufferImageHeight", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageSubresourceLayers>(object.imageSubresource, settings, "VkImageSubresourceLayers", "imageSubresource", indents + 1, dump_html_VkImageSubresourceLayers);
    dump_html_value<const VkOffset3D>(object.imageOffset, settings, "VkOffset3D", "imageOffset", indents + 1, dump_html_VkOffset3D);
    dump_html_value<const VkExtent3D>(object.imageExtent, settings, "VkExtent3D", "imageExtent", indents + 1, dump_html_VkExtent3D);
    return settings.stream();
}
std::ostream& dump_html_VkCmdProcessCommandsInfoNVX(const VkCmdProcessCommandsInfoNVX& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkObjectTableNVX>(object.objectTable, settings, "VkObjectTableNVX", "objectTable", indents + 1, dump_html_VkObjectTableNVX);
    dump_html_value<const VkIndirectCommandsLayoutNVX>(object.indirectCommandsLayout, settings, "VkIndirectCommandsLayoutNVX", "indirectCommandsLayout", indents + 1, dump_html_VkIndirectCommandsLayoutNVX);
    dump_html_value<const uint32_t>(object.indirectCommandsTokenCount, settings, "uint32_t", "indirectCommandsTokenCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkIndirectCommandsTokenNVX>(object.pIndirectCommandsTokens, object.indirectCommandsTokenCount, settings, "const VkIndirectCommandsTokenNVX*", "const VkIndirectCommandsTokenNVX", "pIndirectCommandsTokens", indents + 1, dump_html_VkIndirectCommandsTokenNVX);
    dump_html_value<const uint32_t>(object.maxSequencesCount, settings, "uint32_t", "maxSequencesCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkCommandBuffer>(object.targetCommandBuffer, settings, "VkCommandBuffer", "targetCommandBuffer", indents + 1, dump_html_VkCommandBuffer);
    dump_html_value<const VkBuffer>(object.sequencesCountBuffer, settings, "VkBuffer", "sequencesCountBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.sequencesCountOffset, settings, "VkDeviceSize", "sequencesCountOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBuffer>(object.sequencesIndexBuffer, settings, "VkBuffer", "sequencesIndexBuffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.sequencesIndexOffset, settings, "VkDeviceSize", "sequencesIndexOffset", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceFloatControlsPropertiesKHR(const VkPhysicalDeviceFloatControlsPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderFloatControlsIndependenceKHR>(object.denormBehaviorIndependence, settings, "VkShaderFloatControlsIndependenceKHR", "denormBehaviorIndependence", indents + 1, dump_html_VkShaderFloatControlsIndependenceKHR);
    dump_html_value<const VkShaderFloatControlsIndependenceKHR>(object.roundingModeIndependence, settings, "VkShaderFloatControlsIndependenceKHR", "roundingModeIndependence", indents + 1, dump_html_VkShaderFloatControlsIndependenceKHR);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat16, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat32, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSignedZeroInfNanPreserveFloat64, settings, "VkBool32", "shaderSignedZeroInfNanPreserveFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat16, settings, "VkBool32", "shaderDenormPreserveFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat32, settings, "VkBool32", "shaderDenormPreserveFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormPreserveFloat64, settings, "VkBool32", "shaderDenormPreserveFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat16, settings, "VkBool32", "shaderDenormFlushToZeroFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat32, settings, "VkBool32", "shaderDenormFlushToZeroFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderDenormFlushToZeroFloat64, settings, "VkBool32", "shaderDenormFlushToZeroFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat16, settings, "VkBool32", "shaderRoundingModeRTEFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat32, settings, "VkBool32", "shaderRoundingModeRTEFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTEFloat64, settings, "VkBool32", "shaderRoundingModeRTEFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat16, settings, "VkBool32", "shaderRoundingModeRTZFloat16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat32, settings, "VkBool32", "shaderRoundingModeRTZFloat32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderRoundingModeRTZFloat64, settings, "VkBool32", "shaderRoundingModeRTZFloat64", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCoarseSampleOrderTypeNV>(object.sampleOrderType, settings, "VkCoarseSampleOrderTypeNV", "sampleOrderType", indents + 1, dump_html_VkCoarseSampleOrderTypeNV);
    dump_html_value<const uint32_t>(object.customSampleOrderCount, settings, "uint32_t", "customSampleOrderCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkCoarseSampleOrderCustomNV>(object.pCustomSampleOrders, object.customSampleOrderCount, settings, "const VkCoarseSampleOrderCustomNV*", "const VkCoarseSampleOrderCustomNV", "pCustomSampleOrders", indents + 1, dump_html_VkCoarseSampleOrderCustomNV);
    return settings.stream();
}
std::ostream& dump_html_VkSubpassDescription2KHR(const VkSubpassDescription2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSubpassDescriptionFlags>(object.flags, settings, "VkSubpassDescriptionFlags", "flags", indents + 1, dump_html_VkSubpassDescriptionFlags);
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const uint32_t>(object.viewMask, settings, "uint32_t", "viewMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.inputAttachmentCount, settings, "uint32_t", "inputAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentReference2KHR>(object.pInputAttachments, object.inputAttachmentCount, settings, "const VkAttachmentReference2KHR*", "const VkAttachmentReference2KHR", "pInputAttachments", indents + 1, dump_html_VkAttachmentReference2KHR);
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentReference2KHR>(object.pColorAttachments, object.colorAttachmentCount, settings, "const VkAttachmentReference2KHR*", "const VkAttachmentReference2KHR", "pColorAttachments", indents + 1, dump_html_VkAttachmentReference2KHR);
    dump_html_array<const VkAttachmentReference2KHR>(object.pResolveAttachments, object.colorAttachmentCount, settings, "const VkAttachmentReference2KHR*", "const VkAttachmentReference2KHR", "pResolveAttachments", indents + 1, dump_html_VkAttachmentReference2KHR);
    dump_html_pointer<const VkAttachmentReference2KHR>(object.pDepthStencilAttachment, settings, "const VkAttachmentReference2KHR*", "pDepthStencilAttachment", indents + 1, dump_html_VkAttachmentReference2KHR);
    dump_html_value<const uint32_t>(object.preserveAttachmentCount, settings, "uint32_t", "preserveAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pPreserveAttachments, object.preserveAttachmentCount, settings, "const uint32_t*", "const uint32_t", "pPreserveAttachments", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkAttachmentDescription2KHR(const VkAttachmentDescription2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAttachmentDescriptionFlags>(object.flags, settings, "VkAttachmentDescriptionFlags", "flags", indents + 1, dump_html_VkAttachmentDescriptionFlags);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkSampleCountFlagBits>(object.samples, settings, "VkSampleCountFlagBits", "samples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkAttachmentLoadOp>(object.loadOp, settings, "VkAttachmentLoadOp", "loadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.storeOp, settings, "VkAttachmentStoreOp", "storeOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkAttachmentLoadOp>(object.stencilLoadOp, settings, "VkAttachmentLoadOp", "stencilLoadOp", indents + 1, dump_html_VkAttachmentLoadOp);
    dump_html_value<const VkAttachmentStoreOp>(object.stencilStoreOp, settings, "VkAttachmentStoreOp", "stencilStoreOp", indents + 1, dump_html_VkAttachmentStoreOp);
    dump_html_value<const VkImageLayout>(object.initialLayout, settings, "VkImageLayout", "initialLayout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageLayout>(object.finalLayout, settings, "VkImageLayout", "finalLayout", indents + 1, dump_html_VkImageLayout);
    return settings.stream();
}
std::ostream& dump_html_VkRenderPassCreateInfo2KHR(const VkRenderPassCreateInfo2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPassCreateFlags>(object.flags, settings, "VkRenderPassCreateFlags", "flags", indents + 1, dump_html_VkRenderPassCreateFlags);
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentDescription2KHR>(object.pAttachments, object.attachmentCount, settings, "const VkAttachmentDescription2KHR*", "const VkAttachmentDescription2KHR", "pAttachments", indents + 1, dump_html_VkAttachmentDescription2KHR);
    dump_html_value<const uint32_t>(object.subpassCount, settings, "uint32_t", "subpassCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassDescription2KHR>(object.pSubpasses, object.subpassCount, settings, "const VkSubpassDescription2KHR*", "const VkSubpassDescription2KHR", "pSubpasses", indents + 1, dump_html_VkSubpassDescription2KHR);
    dump_html_value<const uint32_t>(object.dependencyCount, settings, "uint32_t", "dependencyCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubpassDependency2KHR>(object.pDependencies, object.dependencyCount, settings, "const VkSubpassDependency2KHR*", "const VkSubpassDependency2KHR", "pDependencies", indents + 1, dump_html_VkSubpassDependency2KHR);
    dump_html_value<const uint32_t>(object.correlatedViewMaskCount, settings, "uint32_t", "correlatedViewMaskCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pCorrelatedViewMasks, object.correlatedViewMaskCount, settings, "const uint32_t*", "const uint32_t", "pCorrelatedViewMasks", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(const VkPhysicalDeviceIndexTypeUint8FeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.indexTypeUint8, settings, "VkBool32", "indexTypeUint8", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkShaderModuleCreateInfo(const VkShaderModuleCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderModuleCreateFlags>(object.flags, settings, "VkShaderModuleCreateFlags", "flags", indents + 1, dump_html_VkShaderModuleCreateFlags);
    dump_html_value<const size_t>(object.codeSize, settings, "size_t", "codeSize", indents + 1, dump_html_size_t);
    if(settings.showShader())
        dump_html_array<const uint32_t>(object.pCode, object.codeSize / 4, settings, "const uint32_t*", "const uint32_t", "pCode", indents + 1, dump_html_uint32_t);
    else
        dump_html_special("SHADER DATA", settings, "const uint32_t*", "pCode", indents + 1);
    return settings.stream();
}
std::ostream& dump_html_VkCoarseSampleOrderCustomNV(const VkCoarseSampleOrderCustomNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkShadingRatePaletteEntryNV>(object.shadingRate, settings, "VkShadingRatePaletteEntryNV", "shadingRate", indents + 1, dump_html_VkShadingRatePaletteEntryNV);
    dump_html_value<const uint32_t>(object.sampleCount, settings, "uint32_t", "sampleCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sampleLocationCount, settings, "uint32_t", "sampleLocationCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkCoarseSampleLocationNV>(object.pSampleLocations, object.sampleLocationCount, settings, "const VkCoarseSampleLocationNV*", "const VkCoarseSampleLocationNV", "pSampleLocations", indents + 1, dump_html_VkCoarseSampleLocationNV);
    return settings.stream();
}
std::ostream& dump_html_VkDedicatedAllocationImageCreateInfoNV(const VkDedicatedAllocationImageCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dedicatedAllocation, settings, "VkBool32", "dedicatedAllocation", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkImportSemaphoreWin32HandleInfoKHR(const VkImportSemaphoreWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkSemaphoreImportFlags>(object.flags, settings, "VkSemaphoreImportFlags", "flags", indents + 1, dump_html_VkSemaphoreImportFlags);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
    dump_html_value<const HANDLE>(object.handle, settings, "HANDLE", "handle", indents + 1, dump_html_HANDLE);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkBufferViewCreateInfo(const VkBufferViewCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferViewCreateFlags>(object.flags, settings, "VkBufferViewCreateFlags", "flags", indents + 1, dump_html_VkBufferViewCreateFlags);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.range, settings, "VkDeviceSize", "range", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkDedicatedAllocationBufferCreateInfoNV(const VkDedicatedAllocationBufferCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.dedicatedAllocation, settings, "VkBool32", "dedicatedAllocation", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkAttachmentReference2KHR(const VkAttachmentReference2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.attachment, settings, "uint32_t", "attachment", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageLayout>(object.layout, settings, "VkImageLayout", "layout", indents + 1, dump_html_VkImageLayout);
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkExportSemaphoreWin32HandleInfoKHR(const VkExportSemaphoreWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const SECURITY_ATTRIBUTES*>(object.pAttributes, settings, "const SECURITY_ATTRIBUTES*", "pAttributes", indents + 1, dump_html_SECURITY_ATTRIBUTES);
    dump_html_value<const DWORD>(object.dwAccess, settings, "DWORD", "dwAccess", indents + 1, dump_html_DWORD);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkSubpassDependency2KHR(const VkSubpassDependency2KHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.srcSubpass, settings, "uint32_t", "srcSubpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstSubpass, settings, "uint32_t", "dstSubpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipelineStageFlags>(object.srcStageMask, settings, "VkPipelineStageFlags", "srcStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const VkPipelineStageFlags>(object.dstStageMask, settings, "VkPipelineStageFlags", "dstStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkDependencyFlags>(object.dependencyFlags, settings, "VkDependencyFlags", "dependencyFlags", indents + 1, dump_html_VkDependencyFlags);
    dump_html_value<const int32_t>(object.viewOffset, settings, "int32_t", "viewOffset", indents + 1, dump_html_int32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.pipelineExecutableInfo, settings, "VkBool32", "pipelineExecutableInfo", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineDepthStencilStateCreateInfo(const VkPipelineDepthStencilStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineDepthStencilStateCreateFlags>(object.flags, settings, "VkPipelineDepthStencilStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineDepthStencilStateCreateFlags);
    dump_html_value<const VkBool32>(object.depthTestEnable, settings, "VkBool32", "depthTestEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthWriteEnable, settings, "VkBool32", "depthWriteEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkCompareOp>(object.depthCompareOp, settings, "VkCompareOp", "depthCompareOp", indents + 1, dump_html_VkCompareOp);
    dump_html_value<const VkBool32>(object.depthBoundsTestEnable, settings, "VkBool32", "depthBoundsTestEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.stencilTestEnable, settings, "VkBool32", "stencilTestEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkStencilOpState>(object.front, settings, "VkStencilOpState", "front", indents + 1, dump_html_VkStencilOpState);
    dump_html_value<const VkStencilOpState>(object.back, settings, "VkStencilOpState", "back", indents + 1, dump_html_VkStencilOpState);
    dump_html_value<const float>(object.minDepthBounds, settings, "float", "minDepthBounds", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxDepthBounds, settings, "float", "maxDepthBounds", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkDedicatedAllocationMemoryAllocateInfoNV(const VkDedicatedAllocationMemoryAllocateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkBuffer>(object.buffer, settings, "VkBuffer", "buffer", indents + 1, dump_html_VkBuffer);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkD3D12FenceSubmitInfoKHR(const VkD3D12FenceSubmitInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreValuesCount, settings, "uint32_t", "waitSemaphoreValuesCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pWaitSemaphoreValues, object.waitSemaphoreValuesCount, settings, "const uint64_t*", "const uint64_t", "pWaitSemaphoreValues", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.signalSemaphoreValuesCount, settings, "uint32_t", "signalSemaphoreValuesCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pSignalSemaphoreValues, object.signalSemaphoreValuesCount, settings, "const uint64_t*", "const uint64_t", "pSignalSemaphoreValues", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkStencilOpState(const VkStencilOpState& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStencilOp>(object.failOp, settings, "VkStencilOp", "failOp", indents + 1, dump_html_VkStencilOp);
    dump_html_value<const VkStencilOp>(object.passOp, settings, "VkStencilOp", "passOp", indents + 1, dump_html_VkStencilOp);
    dump_html_value<const VkStencilOp>(object.depthFailOp, settings, "VkStencilOp", "depthFailOp", indents + 1, dump_html_VkStencilOp);
    dump_html_value<const VkCompareOp>(object.compareOp, settings, "VkCompareOp", "compareOp", indents + 1, dump_html_VkCompareOp);
    dump_html_value<const uint32_t>(object.compareMask, settings, "uint32_t", "compareMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.writeMask, settings, "uint32_t", "writeMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.reference, settings, "uint32_t", "reference", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineCacheCreateInfo(const VkPipelineCacheCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCacheCreateFlags>(object.flags, settings, "VkPipelineCacheCreateFlags", "flags", indents + 1, dump_html_VkPipelineCacheCreateFlags);
    dump_html_value<const size_t>(object.initialDataSize, settings, "size_t", "initialDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pInitialData, settings, "const void*", "pInitialData", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineInfoKHR(const VkPipelineInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipeline>(object.pipeline, settings, "VkPipeline", "pipeline", indents + 1, dump_html_VkPipeline);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkExportMemoryWin32HandleInfoKHR(const VkExportMemoryWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const SECURITY_ATTRIBUTES*>(object.pAttributes, settings, "const SECURITY_ATTRIBUTES*", "pAttributes", indents + 1, dump_html_SECURITY_ATTRIBUTES);
    dump_html_value<const DWORD>(object.dwAccess, settings, "DWORD", "dwAccess", indents + 1, dump_html_DWORD);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkRayTracingShaderGroupCreateInfoNV(const VkRayTracingShaderGroupCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRayTracingShaderGroupTypeNV>(object.type, settings, "VkRayTracingShaderGroupTypeNV", "type", indents + 1, dump_html_VkRayTracingShaderGroupTypeNV);
    dump_html_value<const uint32_t>(object.generalShader, settings, "uint32_t", "generalShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.closestHitShader, settings, "uint32_t", "closestHitShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.anyHitShader, settings, "uint32_t", "anyHitShader", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.intersectionShader, settings, "uint32_t", "intersectionShader", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkRayTracingPipelineCreateInfoNV(const VkRayTracingPipelineCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags>(object.flags, settings, "VkPipelineCreateFlags", "flags", indents + 1, dump_html_VkPipelineCreateFlags);
    dump_html_value<const uint32_t>(object.stageCount, settings, "uint32_t", "stageCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineShaderStageCreateInfo>(object.pStages, object.stageCount, settings, "const VkPipelineShaderStageCreateInfo*", "const VkPipelineShaderStageCreateInfo", "pStages", indents + 1, dump_html_VkPipelineShaderStageCreateInfo);
    dump_html_value<const uint32_t>(object.groupCount, settings, "uint32_t", "groupCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRayTracingShaderGroupCreateInfoNV>(object.pGroups, object.groupCount, settings, "const VkRayTracingShaderGroupCreateInfoNV*", "const VkRayTracingShaderGroupCreateInfoNV", "pGroups", indents + 1, dump_html_VkRayTracingShaderGroupCreateInfoNV);
    dump_html_value<const uint32_t>(object.maxRecursionDepth, settings, "uint32_t", "maxRecursionDepth", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkPipeline>(object.basePipelineHandle, settings, "VkPipeline", "basePipelineHandle", indents + 1, dump_html_VkPipeline);
    dump_html_value<const int32_t>(object.basePipelineIndex, settings, "int32_t", "basePipelineIndex", indents + 1, dump_html_int32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineExecutablePropertiesKHR(const VkPipelineExecutablePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkShaderStageFlags>(object.stages, settings, "VkShaderStageFlags", "stages", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const char*>(object.name, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "name", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.subgroupSize, settings, "uint32_t", "subgroupSize", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkSemaphoreGetWin32HandleInfoKHR(const VkSemaphoreGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkImageCreateInfo(const VkImageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageCreateFlags>(object.flags, settings, "VkImageCreateFlags", "flags", indents + 1, dump_html_VkImageCreateFlags);
    dump_html_value<const VkImageType>(object.imageType, settings, "VkImageType", "imageType", indents + 1, dump_html_VkImageType);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkExtent3D>(object.extent, settings, "VkExtent3D", "extent", indents + 1, dump_html_VkExtent3D);
    dump_html_value<const uint32_t>(object.mipLevels, settings, "uint32_t", "mipLevels", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.arrayLayers, settings, "uint32_t", "arrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkSampleCountFlagBits>(object.samples, settings, "VkSampleCountFlagBits", "samples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkImageTiling>(object.tiling, settings, "VkImageTiling", "tiling", indents + 1, dump_html_VkImageTiling);
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkSharingMode>(object.sharingMode, settings, "VkSharingMode", "sharingMode", indents + 1, dump_html_VkSharingMode);
    dump_html_value<const uint32_t>(object.queueFamilyIndexCount, settings, "uint32_t", "queueFamilyIndexCount", indents + 1, dump_html_uint32_t);
    if(object.sharingMode == VK_SHARING_MODE_CONCURRENT)
    dump_html_array<const uint32_t>(object.pQueueFamilyIndices, object.queueFamilyIndexCount, settings, "const uint32_t*", "const uint32_t", "pQueueFamilyIndices", indents + 1, dump_html_uint32_t);
    else
        dump_html_special("UNUSED", settings, "const uint32_t*", "pQueueFamilyIndices", indents + 1);
    dump_html_value<const VkImageLayout>(object.initialLayout, settings, "VkImageLayout", "initialLayout", indents + 1, dump_html_VkImageLayout);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineColorBlendStateCreateInfo(const VkPipelineColorBlendStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineColorBlendStateCreateFlags>(object.flags, settings, "VkPipelineColorBlendStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineColorBlendStateCreateFlags);
    dump_html_value<const VkBool32>(object.logicOpEnable, settings, "VkBool32", "logicOpEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkLogicOp>(object.logicOp, settings, "VkLogicOp", "logicOp", indents + 1, dump_html_VkLogicOp);
    dump_html_value<const uint32_t>(object.attachmentCount, settings, "uint32_t", "attachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineColorBlendAttachmentState>(object.pAttachments, object.attachmentCount, settings, "const VkPipelineColorBlendAttachmentState*", "const VkPipelineColorBlendAttachmentState", "pAttachments", indents + 1, dump_html_VkPipelineColorBlendAttachmentState);
    dump_html_array<const float>(object.blendConstants, 4, settings, "float[4]", "float", "blendConstants", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkImportSemaphoreFdInfoKHR(const VkImportSemaphoreFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkSemaphoreImportFlags>(object.flags, settings, "VkSemaphoreImportFlags", "flags", indents + 1, dump_html_VkSemaphoreImportFlags);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
    dump_html_value<const int>(object.fd, settings, "int", "fd", indents + 1, dump_html_int);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkAndroidHardwareBufferUsageANDROID(const VkAndroidHardwareBufferUsageANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.androidHardwareBufferUsage, settings, "uint64_t", "androidHardwareBufferUsage", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkGeometryTrianglesNV(const VkGeometryTrianglesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.vertexData, settings, "VkBuffer", "vertexData", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.vertexOffset, settings, "VkDeviceSize", "vertexOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.vertexCount, settings, "uint32_t", "vertexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.vertexStride, settings, "VkDeviceSize", "vertexStride", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkFormat>(object.vertexFormat, settings, "VkFormat", "vertexFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkBuffer>(object.indexData, settings, "VkBuffer", "indexData", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.indexOffset, settings, "VkDeviceSize", "indexOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.indexCount, settings, "uint32_t", "indexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkIndexType>(object.indexType, settings, "VkIndexType", "indexType", indents + 1, dump_html_VkIndexType);
    dump_html_value<const VkBuffer>(object.transformData, settings, "VkBuffer", "transformData", indents + 1, dump_html_VkBuffer);
    dump_html_value<const VkDeviceSize>(object.transformOffset, settings, "VkDeviceSize", "transformOffset", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkAndroidHardwareBufferFormatPropertiesANDROID(const VkAndroidHardwareBufferFormatPropertiesANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const uint64_t>(object.externalFormat, settings, "uint64_t", "externalFormat", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkFormatFeatureFlags>(object.formatFeatures, settings, "VkFormatFeatureFlags", "formatFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    dump_html_value<const VkComponentMapping>(object.samplerYcbcrConversionComponents, settings, "VkComponentMapping", "samplerYcbcrConversionComponents", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkSamplerYcbcrModelConversion>(object.suggestedYcbcrModel, settings, "VkSamplerYcbcrModelConversion", "suggestedYcbcrModel", indents + 1, dump_html_VkSamplerYcbcrModelConversion);
    dump_html_value<const VkSamplerYcbcrRange>(object.suggestedYcbcrRange, settings, "VkSamplerYcbcrRange", "suggestedYcbcrRange", indents + 1, dump_html_VkSamplerYcbcrRange);
    dump_html_value<const VkChromaLocation>(object.suggestedXChromaOffset, settings, "VkChromaLocation", "suggestedXChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkChromaLocation>(object.suggestedYChromaOffset, settings, "VkChromaLocation", "suggestedYChromaOffset", indents + 1, dump_html_VkChromaLocation);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkGeometryAABBNV(const VkGeometryAABBNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBuffer>(object.aabbData, settings, "VkBuffer", "aabbData", indents + 1, dump_html_VkBuffer);
    dump_html_value<const uint32_t>(object.numAABBs, settings, "uint32_t", "numAABBs", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stride, settings, "uint32_t", "stride", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineExecutableInfoKHR(const VkPipelineExecutableInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipeline>(object.pipeline, settings, "VkPipeline", "pipeline", indents + 1, dump_html_VkPipeline);
    dump_html_value<const uint32_t>(object.executableIndex, settings, "uint32_t", "executableIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkGraphicsPipelineCreateInfo(const VkGraphicsPipelineCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCreateFlags>(object.flags, settings, "VkPipelineCreateFlags", "flags", indents + 1, dump_html_VkPipelineCreateFlags);
    dump_html_value<const uint32_t>(object.stageCount, settings, "uint32_t", "stageCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPipelineShaderStageCreateInfo>(object.pStages, object.stageCount, settings, "const VkPipelineShaderStageCreateInfo*", "const VkPipelineShaderStageCreateInfo", "pStages", indents + 1, dump_html_VkPipelineShaderStageCreateInfo);
    dump_html_pointer<const VkPipelineVertexInputStateCreateInfo>(object.pVertexInputState, settings, "const VkPipelineVertexInputStateCreateInfo*", "pVertexInputState", indents + 1, dump_html_VkPipelineVertexInputStateCreateInfo);
    dump_html_pointer<const VkPipelineInputAssemblyStateCreateInfo>(object.pInputAssemblyState, settings, "const VkPipelineInputAssemblyStateCreateInfo*", "pInputAssemblyState", indents + 1, dump_html_VkPipelineInputAssemblyStateCreateInfo);
    dump_html_pointer<const VkPipelineTessellationStateCreateInfo>(object.pTessellationState, settings, "const VkPipelineTessellationStateCreateInfo*", "pTessellationState", indents + 1, dump_html_VkPipelineTessellationStateCreateInfo);
    dump_html_pointer<const VkPipelineViewportStateCreateInfo>(object.pViewportState, settings, "const VkPipelineViewportStateCreateInfo*", "pViewportState", indents + 1, dump_html_VkPipelineViewportStateCreateInfo, object.pDynamicState && std::count(object.pDynamicState->pDynamicStates, object.pDynamicState->pDynamicStates + object.pDynamicState->dynamicStateCount, VK_DYNAMIC_STATE_VIEWPORT), object.pDynamicState && std::count(object.pDynamicState->pDynamicStates, object.pDynamicState->pDynamicStates + object.pDynamicState->dynamicStateCount, VK_DYNAMIC_STATE_SCISSOR));
    dump_html_pointer<const VkPipelineRasterizationStateCreateInfo>(object.pRasterizationState, settings, "const VkPipelineRasterizationStateCreateInfo*", "pRasterizationState", indents + 1, dump_html_VkPipelineRasterizationStateCreateInfo);
    dump_html_pointer<const VkPipelineMultisampleStateCreateInfo>(object.pMultisampleState, settings, "const VkPipelineMultisampleStateCreateInfo*", "pMultisampleState", indents + 1, dump_html_VkPipelineMultisampleStateCreateInfo);
    dump_html_pointer<const VkPipelineDepthStencilStateCreateInfo>(object.pDepthStencilState, settings, "const VkPipelineDepthStencilStateCreateInfo*", "pDepthStencilState", indents + 1, dump_html_VkPipelineDepthStencilStateCreateInfo);
    dump_html_pointer<const VkPipelineColorBlendStateCreateInfo>(object.pColorBlendState, settings, "const VkPipelineColorBlendStateCreateInfo*", "pColorBlendState", indents + 1, dump_html_VkPipelineColorBlendStateCreateInfo);
    dump_html_pointer<const VkPipelineDynamicStateCreateInfo>(object.pDynamicState, settings, "const VkPipelineDynamicStateCreateInfo*", "pDynamicState", indents + 1, dump_html_VkPipelineDynamicStateCreateInfo);
    dump_html_value<const VkPipelineLayout>(object.layout, settings, "VkPipelineLayout", "layout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const uint32_t>(object.subpass, settings, "uint32_t", "subpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipeline>(object.basePipelineHandle, settings, "VkPipeline", "basePipelineHandle", indents + 1, dump_html_VkPipeline);
    dump_html_value<const int32_t>(object.basePipelineIndex, settings, "int32_t", "basePipelineIndex", indents + 1, dump_html_int32_t);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkAndroidHardwareBufferPropertiesANDROID(const VkAndroidHardwareBufferPropertiesANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.allocationSize, settings, "VkDeviceSize", "allocationSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkPipelineExecutableStatisticKHR(const VkPipelineExecutableStatisticKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.name, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "name", indents + 1, dump_html_cstring);
    dump_html_value<const char*>(object.description, settings, "char[VK_MAX_DESCRIPTION_SIZE]", "description", indents + 1, dump_html_cstring);
    dump_html_value<const VkPipelineExecutableStatisticFormatKHR>(object.format, settings, "VkPipelineExecutableStatisticFormatKHR", "format", indents + 1, dump_html_VkPipelineExecutableStatisticFormatKHR);
    dump_html_value<const VkPipelineExecutableStatisticValueKHR>(object.value, settings, "VkPipelineExecutableStatisticValueKHR", "value", indents + 1, dump_html_VkPipelineExecutableStatisticValueKHR);
    return settings.stream();
}
std::ostream& dump_html_VkSemaphoreGetFdInfoKHR(const VkSemaphoreGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkSubpassBeginInfoKHR(const VkSubpassBeginInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSubpassContents>(object.contents, settings, "VkSubpassContents", "contents", indents + 1, dump_html_VkSubpassContents);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkImportAndroidHardwareBufferInfoANDROID(const VkImportAndroidHardwareBufferInfoANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const AHardwareBuffer*>(object.buffer, settings, "struct AHardwareBuffer*", "buffer", indents + 1, dump_html_AHardwareBuffer);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkPipelineShaderStageCreateInfo(const VkPipelineShaderStageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineShaderStageCreateFlags>(object.flags, settings, "VkPipelineShaderStageCreateFlags", "flags", indents + 1, dump_html_VkPipelineShaderStageCreateFlags);
    dump_html_value<const VkShaderStageFlagBits>(object.stage, settings, "VkShaderStageFlagBits", "stage", indents + 1, dump_html_VkShaderStageFlagBits);
    dump_html_value<const VkShaderModule>(object.module, settings, "VkShaderModule", "module", indents + 1, dump_html_VkShaderModule);
    dump_html_value<const char*>(object.pName, settings, "const char*", "pName", indents + 1, dump_html_cstring);
    dump_html_pointer<const VkSpecializationInfo>(object.pSpecializationInfo, settings, "const VkSpecializationInfo*", "pSpecializationInfo", indents + 1, dump_html_VkSpecializationInfo);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGroupCommandBufferBeginInfo(const VkDeviceGroupCommandBufferBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.deviceMask, settings, "uint32_t", "deviceMask", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkExportFenceCreateInfo(const VkExportFenceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalFenceHandleTypeFlags>(object.handleTypes, settings, "VkExternalFenceHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalFenceHandleTypeFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.advancedBlendCoherentOperations, settings, "VkBool32", "advancedBlendCoherentOperations", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(const VkPhysicalDeviceImageDrmFormatModifierInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
    dump_html_value<const VkSharingMode>(object.sharingMode, settings, "VkSharingMode", "sharingMode", indents + 1, dump_html_VkSharingMode);
    dump_html_value<const uint32_t>(object.queueFamilyIndexCount, settings, "uint32_t", "queueFamilyIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pQueueFamilyIndices, object.queueFamilyIndexCount, settings, "const uint32_t*", "const uint32_t", "pQueueFamilyIndices", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_MACOS_MVK)
std::ostream& dump_html_VkMacOSSurfaceCreateInfoMVK(const VkMacOSSurfaceCreateInfoMVK& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkMacOSSurfaceCreateFlagsMVK>(object.flags, settings, "VkMacOSSurfaceCreateFlagsMVK", "flags", indents + 1, dump_html_VkMacOSSurfaceCreateFlagsMVK);
    dump_html_value<const void*>(object.pView, settings, "const void*", "pView", indents + 1, dump_html_void);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_MACOS_MVK
std::ostream& dump_html_VkImageViewUsageCreateInfo(const VkImageViewUsageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageUsageFlags>(object.usage, settings, "VkImageUsageFlags", "usage", indents + 1, dump_html_VkImageUsageFlags);
    return settings.stream();
}
std::ostream& dump_html_VkInputAttachmentAspectReference(const VkInputAttachmentAspectReference& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.subpass, settings, "uint32_t", "subpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.inputAttachmentIndex, settings, "uint32_t", "inputAttachmentIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    return settings.stream();
}
std::ostream& dump_html_VkSamplerCreateInfo(const VkSamplerCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSamplerCreateFlags>(object.flags, settings, "VkSamplerCreateFlags", "flags", indents + 1, dump_html_VkSamplerCreateFlags);
    dump_html_value<const VkFilter>(object.magFilter, settings, "VkFilter", "magFilter", indents + 1, dump_html_VkFilter);
    dump_html_value<const VkFilter>(object.minFilter, settings, "VkFilter", "minFilter", indents + 1, dump_html_VkFilter);
    dump_html_value<const VkSamplerMipmapMode>(object.mipmapMode, settings, "VkSamplerMipmapMode", "mipmapMode", indents + 1, dump_html_VkSamplerMipmapMode);
    dump_html_value<const VkSamplerAddressMode>(object.addressModeU, settings, "VkSamplerAddressMode", "addressModeU", indents + 1, dump_html_VkSamplerAddressMode);
    dump_html_value<const VkSamplerAddressMode>(object.addressModeV, settings, "VkSamplerAddressMode", "addressModeV", indents + 1, dump_html_VkSamplerAddressMode);
    dump_html_value<const VkSamplerAddressMode>(object.addressModeW, settings, "VkSamplerAddressMode", "addressModeW", indents + 1, dump_html_VkSamplerAddressMode);
    dump_html_value<const float>(object.mipLodBias, settings, "float", "mipLodBias", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.anisotropyEnable, settings, "VkBool32", "anisotropyEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const float>(object.maxAnisotropy, settings, "float", "maxAnisotropy", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.compareEnable, settings, "VkBool32", "compareEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkCompareOp>(object.compareOp, settings, "VkCompareOp", "compareOp", indents + 1, dump_html_VkCompareOp);
    dump_html_value<const float>(object.minLod, settings, "float", "minLod", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxLod, settings, "float", "maxLod", indents + 1, dump_html_float);
    dump_html_value<const VkBorderColor>(object.borderColor, settings, "VkBorderColor", "borderColor", indents + 1, dump_html_VkBorderColor);
    dump_html_value<const VkBool32>(object.unnormalizedCoordinates, settings, "VkBool32", "unnormalizedCoordinates", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGroupSubmitInfo(const VkDeviceGroupSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreCount, settings, "uint32_t", "waitSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pWaitSemaphoreDeviceIndices, object.waitSemaphoreCount, settings, "const uint32_t*", "const uint32_t", "pWaitSemaphoreDeviceIndices", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.commandBufferCount, settings, "uint32_t", "commandBufferCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pCommandBufferDeviceMasks, object.commandBufferCount, settings, "const uint32_t*", "const uint32_t", "pCommandBufferDeviceMasks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.signalSemaphoreCount, settings, "uint32_t", "signalSemaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pSignalSemaphoreDeviceIndices, object.signalSemaphoreCount, settings, "const uint32_t*", "const uint32_t", "pSignalSemaphoreDeviceIndices", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkSubpassEndInfoKHR(const VkSubpassEndInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.advancedBlendMaxColorAttachments, settings, "uint32_t", "advancedBlendMaxColorAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.advancedBlendIndependentBlend, settings, "VkBool32", "advancedBlendIndependentBlend", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.advancedBlendNonPremultipliedSrcColor, settings, "VkBool32", "advancedBlendNonPremultipliedSrcColor", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.advancedBlendNonPremultipliedDstColor, settings, "VkBool32", "advancedBlendNonPremultipliedDstColor", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.advancedBlendCorrelatedOverlap, settings, "VkBool32", "advancedBlendCorrelatedOverlap", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.advancedBlendAllOperations, settings, "VkBool32", "advancedBlendAllOperations", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkMemoryWin32HandlePropertiesKHR(const VkMemoryWin32HandlePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkDebugUtilsObjectNameInfoEXT(const VkDebugUtilsObjectNameInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkObjectType>(object.objectType, settings, "VkObjectType", "objectType", indents + 1, dump_html_VkObjectType);
    dump_html_value<const uint64_t>(object.objectHandle, settings, "uint64_t", "objectHandle", indents + 1, dump_html_uint64_t);
    dump_html_value<const char*>(object.pObjectName, settings, "const char*", "pObjectName", indents + 1, dump_html_cstring);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkMemoryGetAndroidHardwareBufferInfoANDROID(const VkMemoryGetAndroidHardwareBufferInfoANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkExternalFormatANDROID(const VkExternalFormatANDROID& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.externalFormat, settings, "uint64_t", "externalFormat", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkSubresourceLayout(const VkSubresourceLayout& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.offset, settings, "VkDeviceSize", "offset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.rowPitch, settings, "VkDeviceSize", "rowPitch", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.arrayPitch, settings, "VkDeviceSize", "arrayPitch", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkDeviceSize>(object.depthPitch, settings, "VkDeviceSize", "depthPitch", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkExportSemaphoreCreateInfo(const VkExportSemaphoreCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalSemaphoreHandleTypeFlags>(object.handleTypes, settings, "VkExternalSemaphoreHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlags);
    return settings.stream();
}
std::ostream& dump_html_VkSharedPresentSurfaceCapabilitiesKHR(const VkSharedPresentSurfaceCapabilitiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageUsageFlags>(object.sharedPresentSupportedUsageFlags, settings, "VkImageUsageFlags", "sharedPresentSupportedUsageFlags", indents + 1, dump_html_VkImageUsageFlags);
    return settings.stream();
}
std::ostream& dump_html_VkDebugUtilsObjectTagInfoEXT(const VkDebugUtilsObjectTagInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkObjectType>(object.objectType, settings, "VkObjectType", "objectType", indents + 1, dump_html_VkObjectType);
    dump_html_value<const uint64_t>(object.objectHandle, settings, "uint64_t", "objectHandle", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint64_t>(object.tagName, settings, "uint64_t", "tagName", indents + 1, dump_html_uint64_t);
    dump_html_value<const size_t>(object.tagSize, settings, "size_t", "tagSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pTag, settings, "const void*", "pTag", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineColorBlendAdvancedStateCreateInfoEXT(const VkPipelineColorBlendAdvancedStateCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.srcPremultiplied, settings, "VkBool32", "srcPremultiplied", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.dstPremultiplied, settings, "VkBool32", "dstPremultiplied", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBlendOverlapEXT>(object.blendOverlap, settings, "VkBlendOverlapEXT", "blendOverlap", indents + 1, dump_html_VkBlendOverlapEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineViewportStateCreateInfo(const VkPipelineViewportStateCreateInfo& object, const ApiDumpSettings& settings, int indents, bool is_dynamic_viewport, bool is_dynamic_scissor)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineViewportStateCreateFlags>(object.flags, settings, "VkPipelineViewportStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineViewportStateCreateFlags);
    dump_html_value<const uint32_t>(object.viewportCount, settings, "uint32_t", "viewportCount", indents + 1, dump_html_uint32_t);
    if(!is_dynamic_viewport)
    dump_html_array<const VkViewport>(object.pViewports, object.viewportCount, settings, "const VkViewport*", "const VkViewport", "pViewports", indents + 1, dump_html_VkViewport);
    else
        dump_html_special("UNUSED", settings, "const VkViewport*", "pViewports", indents + 1);
    dump_html_value<const uint32_t>(object.scissorCount, settings, "uint32_t", "scissorCount", indents + 1, dump_html_uint32_t);
    if(!is_dynamic_scissor)
    dump_html_array<const VkRect2D>(object.pScissors, object.scissorCount, settings, "const VkRect2D*", "const VkRect2D", "pScissors", indents + 1, dump_html_VkRect2D);
    else
        dump_html_special("UNUSED", settings, "const VkRect2D*", "pScissors", indents + 1);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineTessellationDomainOriginStateCreateInfo(const VkPipelineTessellationDomainOriginStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkTessellationDomainOrigin>(object.domainOrigin, settings, "VkTessellationDomainOrigin", "domainOrigin", indents + 1, dump_html_VkTessellationDomainOrigin);
    return settings.stream();
}
std::ostream& dump_html_VkDrmFormatModifierPropertiesEXT(const VkDrmFormatModifierPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.drmFormatModifierPlaneCount, settings, "uint32_t", "drmFormatModifierPlaneCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormatFeatureFlags>(object.drmFormatModifierTilingFeatures, settings, "VkFormatFeatureFlags", "drmFormatModifierTilingFeatures", indents + 1, dump_html_VkFormatFeatureFlags);
    return settings.stream();
}
std::ostream& dump_html_VkDrmFormatModifierPropertiesListEXT(const VkDrmFormatModifierPropertiesListEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.drmFormatModifierCount, settings, "uint32_t", "drmFormatModifierCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDrmFormatModifierPropertiesEXT>(object.pDrmFormatModifierProperties, object.drmFormatModifierCount, settings, "VkDrmFormatModifierPropertiesEXT*", "VkDrmFormatModifierPropertiesEXT", "pDrmFormatModifierProperties", indents + 1, dump_html_VkDrmFormatModifierPropertiesEXT);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGroupBindSparseInfo(const VkDeviceGroupBindSparseInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.resourceDeviceIndex, settings, "uint32_t", "resourceDeviceIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.memoryDeviceIndex, settings, "uint32_t", "memoryDeviceIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkRenderPassMultiviewCreateInfo(const VkRenderPassMultiviewCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.subpassCount, settings, "uint32_t", "subpassCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pViewMasks, object.subpassCount, settings, "const uint32_t*", "const uint32_t", "pViewMasks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dependencyCount, settings, "uint32_t", "dependencyCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const int32_t>(object.pViewOffsets, object.dependencyCount, settings, "const int32_t*", "const int32_t", "pViewOffsets", indents + 1, dump_html_int32_t);
    dump_html_value<const uint32_t>(object.correlationMaskCount, settings, "uint32_t", "correlationMaskCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pCorrelationMasks, object.correlationMaskCount, settings, "const uint32_t*", "const uint32_t", "pCorrelationMasks", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDebugUtilsMessengerCallbackDataEXT(const VkDebugUtilsMessengerCallbackDataEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugUtilsMessengerCallbackDataFlagsEXT>(object.flags, settings, "VkDebugUtilsMessengerCallbackDataFlagsEXT", "flags", indents + 1, dump_html_VkDebugUtilsMessengerCallbackDataFlagsEXT);
    dump_html_value<const char*>(object.pMessageIdName, settings, "const char*", "pMessageIdName", indents + 1, dump_html_cstring);
    dump_html_value<const int32_t>(object.messageIdNumber, settings, "int32_t", "messageIdNumber", indents + 1, dump_html_int32_t);
    dump_html_value<const char*>(object.pMessage, settings, "const char*", "pMessage", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.queueLabelCount, settings, "uint32_t", "queueLabelCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDebugUtilsLabelEXT>(object.pQueueLabels, object.queueLabelCount, settings, "const VkDebugUtilsLabelEXT*", "const VkDebugUtilsLabelEXT", "pQueueLabels", indents + 1, dump_html_VkDebugUtilsLabelEXT);
    dump_html_value<const uint32_t>(object.cmdBufLabelCount, settings, "uint32_t", "cmdBufLabelCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDebugUtilsLabelEXT>(object.pCmdBufLabels, object.cmdBufLabelCount, settings, "const VkDebugUtilsLabelEXT*", "const VkDebugUtilsLabelEXT", "pCmdBufLabels", indents + 1, dump_html_VkDebugUtilsLabelEXT);
    dump_html_value<const uint32_t>(object.objectCount, settings, "uint32_t", "objectCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDebugUtilsObjectNameInfoEXT>(object.pObjects, object.objectCount, settings, "const VkDebugUtilsObjectNameInfoEXT*", "const VkDebugUtilsObjectNameInfoEXT", "pObjects", indents + 1, dump_html_VkDebugUtilsObjectNameInfoEXT);
    return settings.stream();
}
std::ostream& dump_html_VkRect2D(const VkRect2D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkOffset2D>(object.offset, settings, "VkOffset2D", "offset", indents + 1, dump_html_VkOffset2D);
    dump_html_value<const VkExtent2D>(object.extent, settings, "VkExtent2D", "extent", indents + 1, dump_html_VkExtent2D);
    return settings.stream();
}
std::ostream& dump_html_VkViewport(const VkViewport& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.x, settings, "float", "x", indents + 1, dump_html_float);
    dump_html_value<const float>(object.y, settings, "float", "y", indents + 1, dump_html_float);
    dump_html_value<const float>(object.width, settings, "float", "width", indents + 1, dump_html_float);
    dump_html_value<const float>(object.height, settings, "float", "height", indents + 1, dump_html_float);
    dump_html_value<const float>(object.minDepth, settings, "float", "minDepth", indents + 1, dump_html_float);
    dump_html_value<const float>(object.maxDepth, settings, "float", "maxDepth", indents + 1, dump_html_float);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkImportFenceWin32HandleInfoKHR(const VkImportFenceWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const VkFenceImportFlags>(object.flags, settings, "VkFenceImportFlags", "flags", indents + 1, dump_html_VkFenceImportFlags);
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
    dump_html_value<const HANDLE>(object.handle, settings, "HANDLE", "handle", indents + 1, dump_html_HANDLE);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkMemoryGetWin32HandleInfoKHR(const VkMemoryGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkExportFenceWin32HandleInfoKHR(const VkExportFenceWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const SECURITY_ATTRIBUTES*>(object.pAttributes, settings, "const SECURITY_ATTRIBUTES*", "pAttributes", indents + 1, dump_html_SECURITY_ATTRIBUTES);
    dump_html_value<const DWORD>(object.dwAccess, settings, "DWORD", "dwAccess", indents + 1, dump_html_DWORD);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkPhysicalDeviceMultiviewFeatures(const VkPhysicalDeviceMultiviewFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.multiview, settings, "VkBool32", "multiview", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiviewGeometryShader, settings, "VkBool32", "multiviewGeometryShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiviewTessellationShader, settings, "VkBool32", "multiviewTessellationShader", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkImageDrmFormatModifierExplicitCreateInfoEXT(const VkImageDrmFormatModifierExplicitCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.drmFormatModifierPlaneCount, settings, "uint32_t", "drmFormatModifierPlaneCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSubresourceLayout>(object.pPlaneLayouts, object.drmFormatModifierPlaneCount, settings, "const VkSubresourceLayout*", "const VkSubresourceLayout", "pPlaneLayouts", indents + 1, dump_html_VkSubresourceLayout);
    return settings.stream();
}
std::ostream& dump_html_VkImageViewCreateInfo(const VkImageViewCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageViewCreateFlags>(object.flags, settings, "VkImageViewCreateFlags", "flags", indents + 1, dump_html_VkImageViewCreateFlags);
    dump_html_value<const VkImage>(object.image, settings, "VkImage", "image", indents + 1, dump_html_VkImage);
    dump_html_value<const VkImageViewType>(object.viewType, settings, "VkImageViewType", "viewType", indents + 1, dump_html_VkImageViewType);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkComponentMapping>(object.components, settings, "VkComponentMapping", "components", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkImageSubresourceRange>(object.subresourceRange, settings, "VkImageSubresourceRange", "subresourceRange", indents + 1, dump_html_VkImageSubresourceRange);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineDynamicStateCreateInfo(const VkPipelineDynamicStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineDynamicStateCreateFlags>(object.flags, settings, "VkPipelineDynamicStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineDynamicStateCreateFlags);
    dump_html_value<const uint32_t>(object.dynamicStateCount, settings, "uint32_t", "dynamicStateCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDynamicState>(object.pDynamicStates, object.dynamicStateCount, settings, "const VkDynamicState*", "const VkDynamicState", "pDynamicStates", indents + 1, dump_html_VkDynamicState);
    return settings.stream();
}
std::ostream& dump_html_VkImageSubresourceRange(const VkImageSubresourceRange& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const uint32_t>(object.baseMipLevel, settings, "uint32_t", "baseMipLevel", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.levelCount, settings, "uint32_t", "levelCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.baseArrayLayer, settings, "uint32_t", "baseArrayLayer", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceExternalSemaphoreInfo(const VkPhysicalDeviceExternalSemaphoreInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalSemaphoreHandleTypeFlagBits>(object.handleType, settings, "VkExternalSemaphoreHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceInlineUniformBlockPropertiesEXT(const VkPhysicalDeviceInlineUniformBlockPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxInlineUniformBlockSize, settings, "uint32_t", "maxInlineUniformBlockSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorInlineUniformBlocks, settings, "uint32_t", "maxPerStageDescriptorInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetInlineUniformBlocks, settings, "uint32_t", "maxDescriptorSetInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindInlineUniformBlocks, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindInlineUniformBlocks", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorPoolCreateInfo(const VkDescriptorPoolCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorPoolCreateFlags>(object.flags, settings, "VkDescriptorPoolCreateFlags", "flags", indents + 1, dump_html_VkDescriptorPoolCreateFlags);
    dump_html_value<const uint32_t>(object.maxSets, settings, "uint32_t", "maxSets", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.poolSizeCount, settings, "uint32_t", "poolSizeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorPoolSize>(object.pPoolSizes, object.poolSizeCount, settings, "const VkDescriptorPoolSize*", "const VkDescriptorPoolSize", "pPoolSizes", indents + 1, dump_html_VkDescriptorPoolSize);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceProtectedMemoryFeatures(const VkPhysicalDeviceProtectedMemoryFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.protectedMemory, settings, "VkBool32", "protectedMemory", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkExternalSemaphoreProperties(const VkExternalSemaphoreProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalSemaphoreHandleTypeFlags>(object.exportFromImportedHandleTypes, settings, "VkExternalSemaphoreHandleTypeFlags", "exportFromImportedHandleTypes", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlags);
    dump_html_value<const VkExternalSemaphoreHandleTypeFlags>(object.compatibleHandleTypes, settings, "VkExternalSemaphoreHandleTypeFlags", "compatibleHandleTypes", indents + 1, dump_html_VkExternalSemaphoreHandleTypeFlags);
    dump_html_value<const VkExternalSemaphoreFeatureFlags>(object.externalSemaphoreFeatures, settings, "VkExternalSemaphoreFeatureFlags", "externalSemaphoreFeatures", indents + 1, dump_html_VkExternalSemaphoreFeatureFlags);
    return settings.stream();
}
std::ostream& dump_html_VkSamplerReductionModeCreateInfoEXT(const VkSamplerReductionModeCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSamplerReductionModeEXT>(object.reductionMode, settings, "VkSamplerReductionModeEXT", "reductionMode", indents + 1, dump_html_VkSamplerReductionModeEXT);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryFdPropertiesKHR(const VkMemoryFdPropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.memoryTypeBits, settings, "uint32_t", "memoryTypeBits", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorPoolSize(const VkDescriptorPoolSize& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDescriptorType>(object.type, settings, "VkDescriptorType", "type", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkImageDrmFormatModifierListCreateInfoEXT(const VkImageDrmFormatModifierListCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.drmFormatModifierCount, settings, "uint32_t", "drmFormatModifierCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pDrmFormatModifiers, object.drmFormatModifierCount, settings, "const uint64_t*", "const uint64_t", "pDrmFormatModifiers", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkDebugUtilsLabelEXT(const VkDebugUtilsLabelEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.pLabelName, settings, "const char*", "pLabelName", indents + 1, dump_html_cstring);
    dump_html_array<const float>(object.color, 4, settings, "float[4]", "float", "color", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorSetLayoutSupport(const VkDescriptorSetLayoutSupport& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.supported, settings, "VkBool32", "supported", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineCoverageModulationStateCreateInfoNV(const VkPipelineCoverageModulationStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCoverageModulationStateCreateFlagsNV>(object.flags, settings, "VkPipelineCoverageModulationStateCreateFlagsNV", "flags", indents + 1, dump_html_VkPipelineCoverageModulationStateCreateFlagsNV);
    dump_html_value<const VkCoverageModulationModeNV>(object.coverageModulationMode, settings, "VkCoverageModulationModeNV", "coverageModulationMode", indents + 1, dump_html_VkCoverageModulationModeNV);
    dump_html_value<const VkBool32>(object.coverageModulationTableEnable, settings, "VkBool32", "coverageModulationTableEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.coverageModulationTableCount, settings, "uint32_t", "coverageModulationTableCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const float>(object.pCoverageModulationTable, object.coverageModulationTableCount, settings, "const float*", "const float", "pCoverageModulationTable", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkBindImageMemoryDeviceGroupInfo(const VkBindImageMemoryDeviceGroupInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.deviceIndexCount, settings, "uint32_t", "deviceIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDeviceIndices, object.deviceIndexCount, settings, "const uint32_t*", "const uint32_t", "pDeviceIndices", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.splitInstanceBindRegionCount, settings, "uint32_t", "splitInstanceBindRegionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkRect2D>(object.pSplitInstanceBindRegions, object.splitInstanceBindRegionCount, settings, "const VkRect2D*", "const VkRect2D", "pSplitInstanceBindRegions", indents + 1, dump_html_VkRect2D);
    return settings.stream();
}
std::ostream& dump_html_VkComponentMapping(const VkComponentMapping& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkComponentSwizzle>(object.r, settings, "VkComponentSwizzle", "r", indents + 1, dump_html_VkComponentSwizzle);
    dump_html_value<const VkComponentSwizzle>(object.g, settings, "VkComponentSwizzle", "g", indents + 1, dump_html_VkComponentSwizzle);
    dump_html_value<const VkComponentSwizzle>(object.b, settings, "VkComponentSwizzle", "b", indents + 1, dump_html_VkComponentSwizzle);
    dump_html_value<const VkComponentSwizzle>(object.a, settings, "VkComponentSwizzle", "a", indents + 1, dump_html_VkComponentSwizzle);
    return settings.stream();
}
std::ostream& dump_html_VkExtent2D(const VkExtent2D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.width, settings, "uint32_t", "width", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.height, settings, "uint32_t", "height", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDebugUtilsMessengerCreateInfoEXT(const VkDebugUtilsMessengerCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugUtilsMessengerCreateFlagsEXT>(object.flags, settings, "VkDebugUtilsMessengerCreateFlagsEXT", "flags", indents + 1, dump_html_VkDebugUtilsMessengerCreateFlagsEXT);
    dump_html_value<const VkDebugUtilsMessageSeverityFlagsEXT>(object.messageSeverity, settings, "VkDebugUtilsMessageSeverityFlagsEXT", "messageSeverity", indents + 1, dump_html_VkDebugUtilsMessageSeverityFlagsEXT);
    dump_html_value<const VkDebugUtilsMessageTypeFlagsEXT>(object.messageType, settings, "VkDebugUtilsMessageTypeFlagsEXT", "messageType", indents + 1, dump_html_VkDebugUtilsMessageTypeFlagsEXT);
    dump_html_value<const PFN_vkDebugUtilsMessengerCallbackEXT>(object.pfnUserCallback, settings, "PFN_vkDebugUtilsMessengerCallbackEXT", "pfnUserCallback", indents + 1, dump_html_PFN_vkDebugUtilsMessengerCallbackEXT);
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkOffset2D(const VkOffset2D& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const int32_t>(object.x, settings, "int32_t", "x", indents + 1, dump_html_int32_t);
    dump_html_value<const int32_t>(object.y, settings, "int32_t", "y", indents + 1, dump_html_int32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineCoverageToColorStateCreateInfoNV(const VkPipelineCoverageToColorStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineCoverageToColorStateCreateFlagsNV>(object.flags, settings, "VkPipelineCoverageToColorStateCreateFlagsNV", "flags", indents + 1, dump_html_VkPipelineCoverageToColorStateCreateFlagsNV);
    dump_html_value<const VkBool32>(object.coverageToColorEnable, settings, "VkBool32", "coverageToColorEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.coverageToColorLocation, settings, "uint32_t", "coverageToColorLocation", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT(const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.filterMinmaxSingleComponentFormats, settings, "VkBool32", "filterMinmaxSingleComponentFormats", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.filterMinmaxImageComponentMapping, settings, "VkBool32", "filterMinmaxImageComponentMapping", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkImportMemoryFdInfoKHR(const VkImportMemoryFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    dump_html_value<const int>(object.fd, settings, "int", "fd", indents + 1, dump_html_int);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderSMBuiltins, settings, "VkBool32", "shaderSMBuiltins", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkImageDrmFormatModifierPropertiesEXT(const VkImageDrmFormatModifierPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.drmFormatModifier, settings, "uint64_t", "drmFormatModifier", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineRasterizationStateCreateInfo(const VkPipelineRasterizationStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineRasterizationStateCreateFlags>(object.flags, settings, "VkPipelineRasterizationStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineRasterizationStateCreateFlags);
    dump_html_value<const VkBool32>(object.depthClampEnable, settings, "VkBool32", "depthClampEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.rasterizerDiscardEnable, settings, "VkBool32", "rasterizerDiscardEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkPolygonMode>(object.polygonMode, settings, "VkPolygonMode", "polygonMode", indents + 1, dump_html_VkPolygonMode);
    dump_html_value<const VkCullModeFlags>(object.cullMode, settings, "VkCullModeFlags", "cullMode", indents + 1, dump_html_VkCullModeFlags);
    dump_html_value<const VkFrontFace>(object.frontFace, settings, "VkFrontFace", "frontFace", indents + 1, dump_html_VkFrontFace);
    dump_html_value<const VkBool32>(object.depthBiasEnable, settings, "VkBool32", "depthBiasEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const float>(object.depthBiasConstantFactor, settings, "float", "depthBiasConstantFactor", indents + 1, dump_html_float);
    dump_html_value<const float>(object.depthBiasClamp, settings, "float", "depthBiasClamp", indents + 1, dump_html_float);
    dump_html_value<const float>(object.depthBiasSlopeFactor, settings, "float", "depthBiasSlopeFactor", indents + 1, dump_html_float);
    dump_html_value<const float>(object.lineWidth, settings, "float", "lineWidth", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkBindBufferMemoryDeviceGroupInfo(const VkBindBufferMemoryDeviceGroupInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.deviceIndexCount, settings, "uint32_t", "deviceIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDeviceIndices, object.deviceIndexCount, settings, "const uint32_t*", "const uint32_t", "pDeviceIndices", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceMultiviewProperties(const VkPhysicalDeviceMultiviewProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxMultiviewViewCount, settings, "uint32_t", "maxMultiviewViewCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMultiviewInstanceIndex, settings, "uint32_t", "maxMultiviewInstanceIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceInlineUniformBlockFeaturesEXT(const VkPhysicalDeviceInlineUniformBlockFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.inlineUniformBlock, settings, "VkBool32", "inlineUniformBlock", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingInlineUniformBlockUpdateAfterBind, settings, "VkBool32", "descriptorBindingInlineUniformBlockUpdateAfterBind", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkFenceGetWin32HandleInfoKHR(const VkFenceGetWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkPhysicalDeviceMaintenance3Properties(const VkPhysicalDeviceMaintenance3Properties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxPerSetDescriptors, settings, "uint32_t", "maxPerSetDescriptors", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDeviceSize>(object.maxMemoryAllocationSize, settings, "VkDeviceSize", "maxMemoryAllocationSize", indents + 1, dump_html_VkDeviceSize);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryGetFdInfoKHR(const VkMemoryGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceVariablePointersFeatures(const VkPhysicalDeviceVariablePointersFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.variablePointersStorageBuffer, settings, "VkBool32", "variablePointersStorageBuffer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.variablePointers, settings, "VkBool32", "variablePointers", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkImportFenceFdInfoKHR(const VkImportFenceFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const VkFenceImportFlags>(object.flags, settings, "VkFenceImportFlags", "flags", indents + 1, dump_html_VkFenceImportFlags);
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
    dump_html_value<const int>(object.fd, settings, "int", "fd", indents + 1, dump_html_int);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorPoolInlineUniformBlockCreateInfoEXT(const VkDescriptorPoolInlineUniformBlockCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxInlineUniformBlockBindings, settings, "uint32_t", "maxInlineUniformBlockBindings", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.shaderSMCount, settings, "uint32_t", "shaderSMCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shaderWarpsPerSM, settings, "uint32_t", "shaderWarpsPerSM", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkValidationCacheCreateInfoEXT(const VkValidationCacheCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkValidationCacheCreateFlagsEXT>(object.flags, settings, "VkValidationCacheCreateFlagsEXT", "flags", indents + 1, dump_html_VkValidationCacheCreateFlagsEXT);
    dump_html_value<const size_t>(object.initialDataSize, settings, "size_t", "initialDataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pInitialData, settings, "const void*", "pInitialData", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderDrawParametersFeatures(const VkPhysicalDeviceShaderDrawParametersFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderDrawParameters, settings, "VkBool32", "shaderDrawParameters", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorSetAllocateInfo(const VkDescriptorSetAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorPool>(object.descriptorPool, settings, "VkDescriptorPool", "descriptorPool", indents + 1, dump_html_VkDescriptorPool);
    dump_html_value<const uint32_t>(object.descriptorSetCount, settings, "uint32_t", "descriptorSetCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorSetLayout>(object.pSetLayouts, object.descriptorSetCount, settings, "const VkDescriptorSetLayout*", "const VkDescriptorSetLayout", "pSetLayouts", indents + 1, dump_html_VkDescriptorSetLayout);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceProtectedMemoryProperties(const VkPhysicalDeviceProtectedMemoryProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.protectedNoFault, settings, "VkBool32", "protectedNoFault", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkShaderModuleValidationCacheCreateInfoEXT(const VkShaderModuleValidationCacheCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkValidationCacheEXT>(object.validationCache, settings, "VkValidationCacheEXT", "validationCache", indents + 1, dump_html_VkValidationCacheEXT);
    return settings.stream();
}
std::ostream& dump_html_VkFenceGetFdInfoKHR(const VkFenceGetFdInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFence>(object.fence, settings, "VkFence", "fence", indents + 1, dump_html_VkFence);
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorSetLayoutCreateInfo(const VkDescriptorSetLayoutCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorSetLayoutCreateFlags>(object.flags, settings, "VkDescriptorSetLayoutCreateFlags", "flags", indents + 1, dump_html_VkDescriptorSetLayoutCreateFlags);
    dump_html_value<const uint32_t>(object.bindingCount, settings, "uint32_t", "bindingCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorSetLayoutBinding>(object.pBindings, object.bindingCount, settings, "const VkDescriptorSetLayoutBinding*", "const VkDescriptorSetLayoutBinding", "pBindings", indents + 1, dump_html_VkDescriptorSetLayoutBinding);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceQueueInfo2(const VkDeviceQueueInfo2& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceQueueCreateFlags>(object.flags, settings, "VkDeviceQueueCreateFlags", "flags", indents + 1, dump_html_VkDeviceQueueCreateFlags);
    dump_html_value<const uint32_t>(object.queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.queueIndex, settings, "uint32_t", "queueIndex", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkWin32KeyedMutexAcquireReleaseInfoKHR(const VkWin32KeyedMutexAcquireReleaseInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.acquireCount, settings, "uint32_t", "acquireCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceMemory>(object.pAcquireSyncs, object.acquireCount, settings, "const VkDeviceMemory*", "const VkDeviceMemory", "pAcquireSyncs", indents + 1, dump_html_VkDeviceMemory);
    dump_html_array<const uint64_t>(object.pAcquireKeys, object.acquireCount, settings, "const uint64_t*", "const uint64_t", "pAcquireKeys", indents + 1, dump_html_uint64_t);
    dump_html_array<const uint32_t>(object.pAcquireTimeouts, object.acquireCount, settings, "const uint32_t*", "const uint32_t", "pAcquireTimeouts", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.releaseCount, settings, "uint32_t", "releaseCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceMemory>(object.pReleaseSyncs, object.releaseCount, settings, "const VkDeviceMemory*", "const VkDeviceMemory", "pReleaseSyncs", indents + 1, dump_html_VkDeviceMemory);
    dump_html_array<const uint64_t>(object.pReleaseKeys, object.releaseCount, settings, "const uint64_t*", "const uint64_t", "pReleaseKeys", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_VkWriteDescriptorSetInlineUniformBlockEXT(const VkWriteDescriptorSetInlineUniformBlockEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.dataSize, settings, "uint32_t", "dataSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const void*>(object.pData, settings, "const void*", "pData", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorSetLayoutBinding(const VkDescriptorSetLayoutBinding& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDescriptorType>(object.descriptorType, settings, "VkDescriptorType", "descriptorType", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkShaderStageFlags>(object.stageFlags, settings, "VkShaderStageFlags", "stageFlags", indents + 1, dump_html_VkShaderStageFlags);
    if((object.descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER) || (object.descriptorType == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER))
    dump_html_array<const VkSampler>(object.pImmutableSamplers, object.descriptorCount, settings, "const VkSampler*", "const VkSampler", "pImmutableSamplers", indents + 1, dump_html_VkSampler);
    else
        dump_html_special("UNUSED", settings, "const VkSampler*", "pImmutableSamplers", indents + 1);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceGroupDeviceCreateInfo(const VkDeviceGroupDeviceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.physicalDeviceCount, settings, "uint32_t", "physicalDeviceCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPhysicalDevice>(object.pPhysicalDevices, object.physicalDeviceCount, settings, "const VkPhysicalDevice*", "const VkPhysicalDevice", "pPhysicalDevices", indents + 1, dump_html_VkPhysicalDevice);
    return settings.stream();
}
std::ostream& dump_html_VkSampleLocationEXT(const VkSampleLocationEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.x, settings, "float", "x", indents + 1, dump_html_float);
    dump_html_value<const float>(object.y, settings, "float", "y", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineMultisampleStateCreateInfo(const VkPipelineMultisampleStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineMultisampleStateCreateFlags>(object.flags, settings, "VkPipelineMultisampleStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineMultisampleStateCreateFlags);
    dump_html_value<const VkSampleCountFlagBits>(object.rasterizationSamples, settings, "VkSampleCountFlagBits", "rasterizationSamples", indents + 1, dump_html_VkSampleCountFlagBits);
    dump_html_value<const VkBool32>(object.sampleShadingEnable, settings, "VkBool32", "sampleShadingEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const float>(object.minSampleShading, settings, "float", "minSampleShading", indents + 1, dump_html_float);
    dump_html_array<const VkSampleMask>(object.pSampleMask, object.rasterizationSamples / 32, settings, "const VkSampleMask*", "const VkSampleMask", "pSampleMask", indents + 1, dump_html_VkSampleMask);
    dump_html_value<const VkBool32>(object.alphaToCoverageEnable, settings, "VkBool32", "alphaToCoverageEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.alphaToOneEnable, settings, "VkBool32", "alphaToOneEnable", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkProtectedSubmitInfo(const VkProtectedSubmitInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.protectedSubmit, settings, "VkBool32", "protectedSubmit", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkApplicationInfo(const VkApplicationInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const char*>(object.pApplicationName, settings, "const char*", "pApplicationName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.applicationVersion, settings, "uint32_t", "applicationVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const char*>(object.pEngineName, settings, "const char*", "pEngineName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.engineVersion, settings, "uint32_t", "engineVersion", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.apiVersion, settings, "uint32_t", "apiVersion", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkAllocationCallbacks(const VkAllocationCallbacks& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
    dump_html_value<const PFN_vkAllocationFunction>(object.pfnAllocation, settings, "PFN_vkAllocationFunction", "pfnAllocation", indents + 1, dump_html_PFN_vkAllocationFunction);
    dump_html_value<const PFN_vkReallocationFunction>(object.pfnReallocation, settings, "PFN_vkReallocationFunction", "pfnReallocation", indents + 1, dump_html_PFN_vkReallocationFunction);
    dump_html_value<const PFN_vkFreeFunction>(object.pfnFree, settings, "PFN_vkFreeFunction", "pfnFree", indents + 1, dump_html_PFN_vkFreeFunction);
    dump_html_value<const PFN_vkInternalAllocationNotification>(object.pfnInternalAllocation, settings, "PFN_vkInternalAllocationNotification", "pfnInternalAllocation", indents + 1, dump_html_PFN_vkInternalAllocationNotification);
    dump_html_value<const PFN_vkInternalFreeNotification>(object.pfnInternalFree, settings, "PFN_vkInternalFreeNotification", "pfnInternalFree", indents + 1, dump_html_PFN_vkInternalFreeNotification);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineVertexInputStateCreateInfo(const VkPipelineVertexInputStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineVertexInputStateCreateFlags>(object.flags, settings, "VkPipelineVertexInputStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineVertexInputStateCreateFlags);
    dump_html_value<const uint32_t>(object.vertexBindingDescriptionCount, settings, "uint32_t", "vertexBindingDescriptionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVertexInputBindingDescription>(object.pVertexBindingDescriptions, object.vertexBindingDescriptionCount, settings, "const VkVertexInputBindingDescription*", "const VkVertexInputBindingDescription", "pVertexBindingDescriptions", indents + 1, dump_html_VkVertexInputBindingDescription);
    dump_html_value<const uint32_t>(object.vertexAttributeDescriptionCount, settings, "uint32_t", "vertexAttributeDescriptionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkVertexInputAttributeDescription>(object.pVertexAttributeDescriptions, object.vertexAttributeDescriptionCount, settings, "const VkVertexInputAttributeDescription*", "const VkVertexInputAttributeDescription", "pVertexAttributeDescriptions", indents + 1, dump_html_VkVertexInputAttributeDescription);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorUpdateTemplateEntry(const VkDescriptorUpdateTemplateEntry& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.dstBinding, settings, "uint32_t", "dstBinding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstArrayElement, settings, "uint32_t", "dstArrayElement", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.descriptorCount, settings, "uint32_t", "descriptorCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkDescriptorType>(object.descriptorType, settings, "VkDescriptorType", "descriptorType", indents + 1, dump_html_VkDescriptorType);
    dump_html_value<const size_t>(object.offset, settings, "size_t", "offset", indents + 1, dump_html_size_t);
    dump_html_value<const size_t>(object.stride, settings, "size_t", "stride", indents + 1, dump_html_size_t);
    return settings.stream();
}
std::ostream& dump_html_VkExternalBufferProperties(const VkExternalBufferProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryProperties>(object.externalMemoryProperties, settings, "VkExternalMemoryProperties", "externalMemoryProperties", indents + 1, dump_html_VkExternalMemoryProperties);
    return settings.stream();
}
std::ostream& dump_html_VkMemoryHeap(const VkMemoryHeap& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkMemoryHeapFlags>(object.flags, settings, "VkMemoryHeapFlags", "flags", indents + 1, dump_html_VkMemoryHeapFlags);
    return settings.stream();
}
std::ostream& dump_html_VkSubpassDescription(const VkSubpassDescription& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkSubpassDescriptionFlags>(object.flags, settings, "VkSubpassDescriptionFlags", "flags", indents + 1, dump_html_VkSubpassDescriptionFlags);
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const uint32_t>(object.inputAttachmentCount, settings, "uint32_t", "inputAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentReference>(object.pInputAttachments, object.inputAttachmentCount, settings, "const VkAttachmentReference*", "const VkAttachmentReference", "pInputAttachments", indents + 1, dump_html_VkAttachmentReference);
    dump_html_value<const uint32_t>(object.colorAttachmentCount, settings, "uint32_t", "colorAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAttachmentReference>(object.pColorAttachments, object.colorAttachmentCount, settings, "const VkAttachmentReference*", "const VkAttachmentReference", "pColorAttachments", indents + 1, dump_html_VkAttachmentReference);
    dump_html_array<const VkAttachmentReference>(object.pResolveAttachments, object.colorAttachmentCount, settings, "const VkAttachmentReference*", "const VkAttachmentReference", "pResolveAttachments", indents + 1, dump_html_VkAttachmentReference);
    dump_html_pointer<const VkAttachmentReference>(object.pDepthStencilAttachment, settings, "const VkAttachmentReference*", "pDepthStencilAttachment", indents + 1, dump_html_VkAttachmentReference);
    dump_html_value<const uint32_t>(object.preserveAttachmentCount, settings, "uint32_t", "preserveAttachmentCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pPreserveAttachments, object.preserveAttachmentCount, settings, "const uint32_t*", "const uint32_t", "pPreserveAttachments", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorUpdateTemplateCreateInfo(const VkDescriptorUpdateTemplateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDescriptorUpdateTemplateCreateFlags>(object.flags, settings, "VkDescriptorUpdateTemplateCreateFlags", "flags", indents + 1, dump_html_VkDescriptorUpdateTemplateCreateFlags);
    dump_html_value<const uint32_t>(object.descriptorUpdateEntryCount, settings, "uint32_t", "descriptorUpdateEntryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorUpdateTemplateEntry>(object.pDescriptorUpdateEntries, object.descriptorUpdateEntryCount, settings, "const VkDescriptorUpdateTemplateEntry*", "const VkDescriptorUpdateTemplateEntry", "pDescriptorUpdateEntries", indents + 1, dump_html_VkDescriptorUpdateTemplateEntry);
    dump_html_value<const VkDescriptorUpdateTemplateType>(object.templateType, settings, "VkDescriptorUpdateTemplateType", "templateType", indents + 1, dump_html_VkDescriptorUpdateTemplateType);
    dump_html_value<const VkDescriptorSetLayout>(object.descriptorSetLayout, settings, "VkDescriptorSetLayout", "descriptorSetLayout", indents + 1, dump_html_VkDescriptorSetLayout);
    dump_html_value<const VkPipelineBindPoint>(object.pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", indents + 1, dump_html_VkPipelineBindPoint);
    dump_html_value<const VkPipelineLayout>(object.pipelineLayout, settings, "VkPipelineLayout", "pipelineLayout", indents + 1, dump_html_VkPipelineLayout);
    dump_html_value<const uint32_t>(object.set, settings, "uint32_t", "set", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkGeometryDataNV(const VkGeometryDataNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkGeometryTrianglesNV>(object.triangles, settings, "VkGeometryTrianglesNV", "triangles", indents + 1, dump_html_VkGeometryTrianglesNV);
    dump_html_value<const VkGeometryAABBNV>(object.aabbs, settings, "VkGeometryAABBNV", "aabbs", indents + 1, dump_html_VkGeometryAABBNV);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceIDProperties(const VkPhysicalDeviceIDProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_array<const uint8_t>(object.deviceUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "deviceUUID", indents + 1, dump_html_uint8_t);
    dump_html_array<const uint8_t>(object.driverUUID, 16, settings, "uint8_t[VK_UUID_SIZE]", "uint8_t", "driverUUID", indents + 1, dump_html_uint8_t);
    dump_html_array<const uint8_t>(object.deviceLUID, 8, settings, "uint8_t[VK_LUID_SIZE]", "uint8_t", "deviceLUID", indents + 1, dump_html_uint8_t);
    dump_html_value<const uint32_t>(object.deviceNodeMask, settings, "uint32_t", "deviceNodeMask", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.deviceLUIDValid, settings, "VkBool32", "deviceLUIDValid", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkCommandBufferBeginInfo(const VkCommandBufferBeginInfo& object, const ApiDumpSettings& settings, int indents, VkCommandBuffer cmd_buffer)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkCommandBufferUsageFlags>(object.flags, settings, "VkCommandBufferUsageFlags", "flags", indents + 1, dump_html_VkCommandBufferUsageFlags);
    if(ApiDumpInstance::current().getCmdBufferLevel(cmd_buffer) == VK_COMMAND_BUFFER_LEVEL_SECONDARY)
    dump_html_pointer<const VkCommandBufferInheritanceInfo>(object.pInheritanceInfo, settings, "const VkCommandBufferInheritanceInfo*", "pInheritanceInfo", indents + 1, dump_html_VkCommandBufferInheritanceInfo);
    else
        dump_html_special("UNUSED", settings, "const VkCommandBufferInheritanceInfo*", "pInheritanceInfo", indents + 1);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceQueueCreateInfo(const VkDeviceQueueCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceQueueCreateFlags>(object.flags, settings, "VkDeviceQueueCreateFlags", "flags", indents + 1, dump_html_VkDeviceQueueCreateFlags);
    dump_html_value<const uint32_t>(object.queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.queueCount, settings, "uint32_t", "queueCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const float>(object.pQueuePriorities, object.queueCount, settings, "const float*", "const float", "pQueuePriorities", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkExternalMemoryImageCreateInfo(const VkExternalMemoryImageCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorSetLayoutBindingFlagsCreateInfoEXT(const VkDescriptorSetLayoutBindingFlagsCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.bindingCount, settings, "uint32_t", "bindingCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDescriptorBindingFlagsEXT>(object.pBindingFlags, object.bindingCount, settings, "const VkDescriptorBindingFlagsEXT*", "const VkDescriptorBindingFlagsEXT", "pBindingFlags", indents + 1, dump_html_VkDescriptorBindingFlagsEXT);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceDescriptorIndexingFeaturesEXT(const VkPhysicalDeviceDescriptorIndexingFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayDynamicIndexing, settings, "VkBool32", "shaderInputAttachmentArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformTexelBufferArrayDynamicIndexing, settings, "VkBool32", "shaderUniformTexelBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageTexelBufferArrayDynamicIndexing, settings, "VkBool32", "shaderStorageTexelBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderUniformBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampledImageArrayNonUniformIndexing, settings, "VkBool32", "shaderSampledImageArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageImageArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayNonUniformIndexing, settings, "VkBool32", "shaderInputAttachmentArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformTexelBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderUniformTexelBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageTexelBufferArrayNonUniformIndexing, settings, "VkBool32", "shaderStorageTexelBufferArrayNonUniformIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUniformBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingUniformBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingSampledImageUpdateAfterBind, settings, "VkBool32", "descriptorBindingSampledImageUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageImageUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageImageUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUniformTexelBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingUniformTexelBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingStorageTexelBufferUpdateAfterBind, settings, "VkBool32", "descriptorBindingStorageTexelBufferUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingUpdateUnusedWhilePending, settings, "VkBool32", "descriptorBindingUpdateUnusedWhilePending", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingPartiallyBound, settings, "VkBool32", "descriptorBindingPartiallyBound", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.descriptorBindingVariableDescriptorCount, settings, "VkBool32", "descriptorBindingVariableDescriptorCount", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.runtimeDescriptorArray, settings, "VkBool32", "runtimeDescriptorArray", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkGeometryNV(const VkGeometryNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkGeometryTypeNV>(object.geometryType, settings, "VkGeometryTypeNV", "geometryType", indents + 1, dump_html_VkGeometryTypeNV);
    dump_html_value<const VkGeometryDataNV>(object.geometry, settings, "VkGeometryDataNV", "geometry", indents + 1, dump_html_VkGeometryDataNV);
    dump_html_value<const VkGeometryFlagsNV>(object.flags, settings, "VkGeometryFlagsNV", "flags", indents + 1, dump_html_VkGeometryFlagsNV);
    return settings.stream();
}
std::ostream& dump_html_VkDebugReportCallbackCreateInfoEXT(const VkDebugReportCallbackCreateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDebugReportFlagsEXT>(object.flags, settings, "VkDebugReportFlagsEXT", "flags", indents + 1, dump_html_VkDebugReportFlagsEXT);
    dump_html_value<const PFN_vkDebugReportCallbackEXT>(object.pfnCallback, settings, "PFN_vkDebugReportCallbackEXT", "pfnCallback", indents + 1, dump_html_PFN_vkDebugReportCallbackEXT);
    dump_html_value<const void*>(object.pUserData, settings, "void*", "pUserData", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkSpecializationInfo(const VkSpecializationInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.mapEntryCount, settings, "uint32_t", "mapEntryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSpecializationMapEntry>(object.pMapEntries, object.mapEntryCount, settings, "const VkSpecializationMapEntry*", "const VkSpecializationMapEntry", "pMapEntries", indents + 1, dump_html_VkSpecializationMapEntry);
    dump_html_value<const size_t>(object.dataSize, settings, "size_t", "dataSize", indents + 1, dump_html_size_t);
    dump_html_value<const void*>(object.pData, settings, "const void*", "pData", indents + 1, dump_html_void);
    return settings.stream();
}
std::ostream& dump_html_VkCommandBufferInheritanceInfo(const VkCommandBufferInheritanceInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const uint32_t>(object.subpass, settings, "uint32_t", "subpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFramebuffer>(object.framebuffer, settings, "VkFramebuffer", "framebuffer", indents + 1, dump_html_VkFramebuffer);
    dump_html_value<const VkBool32>(object.occlusionQueryEnable, settings, "VkBool32", "occlusionQueryEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkQueryControlFlags>(object.queryFlags, settings, "VkQueryControlFlags", "queryFlags", indents + 1, dump_html_VkQueryControlFlags);
    dump_html_value<const VkQueryPipelineStatisticFlags>(object.pipelineStatistics, settings, "VkQueryPipelineStatisticFlags", "pipelineStatistics", indents + 1, dump_html_VkQueryPipelineStatisticFlags);
    return settings.stream();
}
std::ostream& dump_html_VkSpecializationMapEntry(const VkSpecializationMapEntry& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.constantID, settings, "uint32_t", "constantID", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
    dump_html_value<const size_t>(object.size, settings, "size_t", "size", indents + 1, dump_html_size_t);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorSetVariableDescriptorCountLayoutSupportEXT(const VkDescriptorSetVariableDescriptorCountLayoutSupportEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxVariableDescriptorCount, settings, "uint32_t", "maxVariableDescriptorCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkAttachmentReference(const VkAttachmentReference& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.attachment, settings, "uint32_t", "attachment", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageLayout>(object.layout, settings, "VkImageLayout", "layout", indents + 1, dump_html_VkImageLayout);
    return settings.stream();
}
std::ostream& dump_html_VkSubpassDependency(const VkSubpassDependency& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.srcSubpass, settings, "uint32_t", "srcSubpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.dstSubpass, settings, "uint32_t", "dstSubpass", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkPipelineStageFlags>(object.srcStageMask, settings, "VkPipelineStageFlags", "srcStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const VkPipelineStageFlags>(object.dstStageMask, settings, "VkPipelineStageFlags", "dstStageMask", indents + 1, dump_html_VkPipelineStageFlags);
    dump_html_value<const VkAccessFlags>(object.srcAccessMask, settings, "VkAccessFlags", "srcAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkAccessFlags>(object.dstAccessMask, settings, "VkAccessFlags", "dstAccessMask", indents + 1, dump_html_VkAccessFlags);
    dump_html_value<const VkDependencyFlags>(object.dependencyFlags, settings, "VkDependencyFlags", "dependencyFlags", indents + 1, dump_html_VkDependencyFlags);
    return settings.stream();
}
std::ostream& dump_html_VkDeviceCreateInfo(const VkDeviceCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceCreateFlags>(object.flags, settings, "VkDeviceCreateFlags", "flags", indents + 1, dump_html_VkDeviceCreateFlags);
    dump_html_value<const uint32_t>(object.queueCreateInfoCount, settings, "uint32_t", "queueCreateInfoCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkDeviceQueueCreateInfo>(object.pQueueCreateInfos, object.queueCreateInfoCount, settings, "const VkDeviceQueueCreateInfo*", "const VkDeviceQueueCreateInfo", "pQueueCreateInfos", indents + 1, dump_html_VkDeviceQueueCreateInfo);
    dump_html_value<const uint32_t>(object.enabledLayerCount, settings, "uint32_t", "enabledLayerCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const char*>(object.ppEnabledLayerNames, object.enabledLayerCount, settings, "const char* const*", "const char* const", "ppEnabledLayerNames", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.enabledExtensionCount, settings, "uint32_t", "enabledExtensionCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const char*>(object.ppEnabledExtensionNames, object.enabledExtensionCount, settings, "const char* const*", "const char* const", "ppEnabledExtensionNames", indents + 1, dump_html_cstring);
    dump_html_pointer<const VkPhysicalDeviceFeatures>(object.pEnabledFeatures, settings, "const VkPhysicalDeviceFeatures*", "pEnabledFeatures", indents + 1, dump_html_VkPhysicalDeviceFeatures);
    return settings.stream();
}
std::ostream& dump_html_VkShadingRatePaletteNV(const VkShadingRatePaletteNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.shadingRatePaletteEntryCount, settings, "uint32_t", "shadingRatePaletteEntryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkShadingRatePaletteEntryNV>(object.pShadingRatePaletteEntries, object.shadingRatePaletteEntryCount, settings, "const VkShadingRatePaletteEntryNV*", "const VkShadingRatePaletteEntryNV", "pShadingRatePaletteEntries", indents + 1, dump_html_VkShadingRatePaletteEntryNV);
    return settings.stream();
}
std::ostream& dump_html_VkExternalMemoryBufferCreateInfo(const VkExternalMemoryBufferCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
    return settings.stream();
}
std::ostream& dump_html_VkAccelerationStructureInfoNV(const VkAccelerationStructureInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureTypeNV>(object.type, settings, "VkAccelerationStructureTypeNV", "type", indents + 1, dump_html_VkAccelerationStructureTypeNV);
    dump_html_value<const VkBuildAccelerationStructureFlagsNV>(object.flags, settings, "VkBuildAccelerationStructureFlagsNV", "flags", indents + 1, dump_html_VkBuildAccelerationStructureFlagsNV);
    dump_html_value<const uint32_t>(object.instanceCount, settings, "uint32_t", "instanceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.geometryCount, settings, "uint32_t", "geometryCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkGeometryNV>(object.pGeometries, object.geometryCount, settings, "const VkGeometryNV*", "const VkGeometryNV", "pGeometries", indents + 1, dump_html_VkGeometryNV);
    return settings.stream();
}
std::ostream& dump_html_VkSwapchainCreateInfoKHR(const VkSwapchainCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSwapchainCreateFlagsKHR>(object.flags, settings, "VkSwapchainCreateFlagsKHR", "flags", indents + 1, dump_html_VkSwapchainCreateFlagsKHR);
    dump_html_value<const VkSurfaceKHR>(object.surface, settings, "VkSurfaceKHR", "surface", indents + 1, dump_html_VkSurfaceKHR);
    dump_html_value<const uint32_t>(object.minImageCount, settings, "uint32_t", "minImageCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormat>(object.imageFormat, settings, "VkFormat", "imageFormat", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkColorSpaceKHR>(object.imageColorSpace, settings, "VkColorSpaceKHR", "imageColorSpace", indents + 1, dump_html_VkColorSpaceKHR);
    dump_html_value<const VkExtent2D>(object.imageExtent, settings, "VkExtent2D", "imageExtent", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.imageArrayLayers, settings, "uint32_t", "imageArrayLayers", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkImageUsageFlags>(object.imageUsage, settings, "VkImageUsageFlags", "imageUsage", indents + 1, dump_html_VkImageUsageFlags);
    dump_html_value<const VkSharingMode>(object.imageSharingMode, settings, "VkSharingMode", "imageSharingMode", indents + 1, dump_html_VkSharingMode);
    dump_html_value<const uint32_t>(object.queueFamilyIndexCount, settings, "uint32_t", "queueFamilyIndexCount", indents + 1, dump_html_uint32_t);
    if(object.imageSharingMode == VK_SHARING_MODE_CONCURRENT)
    dump_html_array<const uint32_t>(object.pQueueFamilyIndices, object.queueFamilyIndexCount, settings, "const uint32_t*", "const uint32_t", "pQueueFamilyIndices", indents + 1, dump_html_uint32_t);
    else
        dump_html_special("UNUSED", settings, "const uint32_t*", "pQueueFamilyIndices", indents + 1);
    dump_html_value<const VkSurfaceTransformFlagBitsKHR>(object.preTransform, settings, "VkSurfaceTransformFlagBitsKHR", "preTransform", indents + 1, dump_html_VkSurfaceTransformFlagBitsKHR);
    dump_html_value<const VkCompositeAlphaFlagBitsKHR>(object.compositeAlpha, settings, "VkCompositeAlphaFlagBitsKHR", "compositeAlpha", indents + 1, dump_html_VkCompositeAlphaFlagBitsKHR);
    dump_html_value<const VkPresentModeKHR>(object.presentMode, settings, "VkPresentModeKHR", "presentMode", indents + 1, dump_html_VkPresentModeKHR);
    dump_html_value<const VkBool32>(object.clipped, settings, "VkBool32", "clipped", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkSwapchainKHR>(object.oldSwapchain, settings, "VkSwapchainKHR", "oldSwapchain", indents + 1, dump_html_VkSwapchainKHR);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceDescriptorIndexingPropertiesEXT(const VkPhysicalDeviceDescriptorIndexingPropertiesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxUpdateAfterBindDescriptorsInAllPools, settings, "uint32_t", "maxUpdateAfterBindDescriptorsInAllPools", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkBool32>(object.shaderUniformBufferArrayNonUniformIndexingNative, settings, "VkBool32", "shaderUniformBufferArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampledImageArrayNonUniformIndexingNative, settings, "VkBool32", "shaderSampledImageArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageBufferArrayNonUniformIndexingNative, settings, "VkBool32", "shaderStorageBufferArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageArrayNonUniformIndexingNative, settings, "VkBool32", "shaderStorageImageArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInputAttachmentArrayNonUniformIndexingNative, settings, "VkBool32", "shaderInputAttachmentArrayNonUniformIndexingNative", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.robustBufferAccessUpdateAfterBind, settings, "VkBool32", "robustBufferAccessUpdateAfterBind", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.quadDivergentImplicitLod, settings, "VkBool32", "quadDivergentImplicitLod", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindSamplers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindUniformBuffers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindStorageBuffers, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindSampledImages, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindStorageImages, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageDescriptorUpdateAfterBindInputAttachments, settings, "uint32_t", "maxPerStageDescriptorUpdateAfterBindInputAttachments", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxPerStageUpdateAfterBindResources, settings, "uint32_t", "maxPerStageUpdateAfterBindResources", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindSamplers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindSamplers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindUniformBuffers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindUniformBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindUniformBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageBuffers, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageBuffers", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageBuffersDynamic", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindSampledImages, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindSampledImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindStorageImages, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindStorageImages", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxDescriptorSetUpdateAfterBindInputAttachments, settings, "uint32_t", "maxDescriptorSetUpdateAfterBindInputAttachments", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkExportMemoryAllocateInfo(const VkExportMemoryAllocateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.handleTypes, settings, "VkExternalMemoryHandleTypeFlags", "handleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
    return settings.stream();
}
std::ostream& dump_html_VkVertexInputBindingDescription(const VkVertexInputBindingDescription& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.stride, settings, "uint32_t", "stride", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkVertexInputRate>(object.inputRate, settings, "VkVertexInputRate", "inputRate", indents + 1, dump_html_VkVertexInputRate);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineViewportShadingRateImageStateCreateInfoNV(const VkPipelineViewportShadingRateImageStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shadingRateImageEnable, settings, "VkBool32", "shadingRateImageEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.viewportCount, settings, "uint32_t", "viewportCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkShadingRatePaletteNV>(object.pShadingRatePalettes, object.viewportCount, settings, "const VkShadingRatePaletteNV*", "const VkShadingRatePaletteNV", "pShadingRatePalettes", indents + 1, dump_html_VkShadingRatePaletteNV);
    return settings.stream();
}
std::ostream& dump_html_VkBufferCreateInfo(const VkBufferCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferCreateFlags>(object.flags, settings, "VkBufferCreateFlags", "flags", indents + 1, dump_html_VkBufferCreateFlags);
    dump_html_value<const VkDeviceSize>(object.size, settings, "VkDeviceSize", "size", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkBufferUsageFlags>(object.usage, settings, "VkBufferUsageFlags", "usage", indents + 1, dump_html_VkBufferUsageFlags);
    dump_html_value<const VkSharingMode>(object.sharingMode, settings, "VkSharingMode", "sharingMode", indents + 1, dump_html_VkSharingMode);
    dump_html_value<const uint32_t>(object.queueFamilyIndexCount, settings, "uint32_t", "queueFamilyIndexCount", indents + 1, dump_html_uint32_t);
    if(object.sharingMode == VK_SHARING_MODE_CONCURRENT)
    dump_html_array<const uint32_t>(object.pQueueFamilyIndices, object.queueFamilyIndexCount, settings, "const uint32_t*", "const uint32_t", "pQueueFamilyIndices", indents + 1, dump_html_uint32_t);
    else
        dump_html_special("UNUSED", settings, "const uint32_t*", "pQueueFamilyIndices", indents + 1);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineInputAssemblyStateCreateInfo(const VkPipelineInputAssemblyStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineInputAssemblyStateCreateFlags>(object.flags, settings, "VkPipelineInputAssemblyStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineInputAssemblyStateCreateFlags);
    dump_html_value<const VkPrimitiveTopology>(object.topology, settings, "VkPrimitiveTopology", "topology", indents + 1, dump_html_VkPrimitiveTopology);
    dump_html_value<const VkBool32>(object.primitiveRestartEnable, settings, "VkBool32", "primitiveRestartEnable", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShadingRateImagePropertiesNV(const VkPhysicalDeviceShadingRateImagePropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExtent2D>(object.shadingRateTexelSize, settings, "VkExtent2D", "shadingRateTexelSize", indents + 1, dump_html_VkExtent2D);
    dump_html_value<const uint32_t>(object.shadingRatePaletteSize, settings, "uint32_t", "shadingRatePaletteSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.shadingRateMaxCoarseSamples, settings, "uint32_t", "shadingRateMaxCoarseSamples", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkVertexInputAttributeDescription(const VkVertexInputAttributeDescription& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.location, settings, "uint32_t", "location", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.binding, settings, "uint32_t", "binding", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const uint32_t>(object.offset, settings, "uint32_t", "offset", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkAccelerationStructureCreateInfoNV(const VkAccelerationStructureCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkDeviceSize>(object.compactedSize, settings, "VkDeviceSize", "compactedSize", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const VkAccelerationStructureInfoNV>(object.info, settings, "VkAccelerationStructureInfoNV", "info", indents + 1, dump_html_VkAccelerationStructureInfoNV);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShadingRateImageFeaturesNV(const VkPhysicalDeviceShadingRateImageFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shadingRateImage, settings, "VkBool32", "shadingRateImage", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shadingRateCoarseSampleOrder, settings, "VkBool32", "shadingRateCoarseSampleOrder", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkExtensionProperties(const VkExtensionProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const char*>(object.extensionName, settings, "char[VK_MAX_EXTENSION_NAME_SIZE]", "extensionName", indents + 1, dump_html_cstring);
    dump_html_value<const uint32_t>(object.specVersion, settings, "uint32_t", "specVersion", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceExternalFenceInfo(const VkPhysicalDeviceExternalFenceInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalFenceHandleTypeFlagBits>(object.handleType, settings, "VkExternalFenceHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalFenceHandleTypeFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkExternalFenceProperties(const VkExternalFenceProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalFenceHandleTypeFlags>(object.exportFromImportedHandleTypes, settings, "VkExternalFenceHandleTypeFlags", "exportFromImportedHandleTypes", indents + 1, dump_html_VkExternalFenceHandleTypeFlags);
    dump_html_value<const VkExternalFenceHandleTypeFlags>(object.compatibleHandleTypes, settings, "VkExternalFenceHandleTypeFlags", "compatibleHandleTypes", indents + 1, dump_html_VkExternalFenceHandleTypeFlags);
    dump_html_value<const VkExternalFenceFeatureFlags>(object.externalFenceFeatures, settings, "VkExternalFenceFeatureFlags", "externalFenceFeatures", indents + 1, dump_html_VkExternalFenceFeatureFlags);
    return settings.stream();
}
std::ostream& dump_html_VkBindAccelerationStructureMemoryInfoNV(const VkBindAccelerationStructureMemoryInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAccelerationStructureNV>(object.accelerationStructure, settings, "VkAccelerationStructureNV", "accelerationStructure", indents + 1, dump_html_VkAccelerationStructureNV);
    dump_html_value<const VkDeviceMemory>(object.memory, settings, "VkDeviceMemory", "memory", indents + 1, dump_html_VkDeviceMemory);
    dump_html_value<const VkDeviceSize>(object.memoryOffset, settings, "VkDeviceSize", "memoryOffset", indents + 1, dump_html_VkDeviceSize);
    dump_html_value<const uint32_t>(object.deviceIndexCount, settings, "uint32_t", "deviceIndexCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDeviceIndices, object.deviceIndexCount, settings, "const uint32_t*", "const uint32_t", "pDeviceIndices", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceFeatures(const VkPhysicalDeviceFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBool32>(object.robustBufferAccess, settings, "VkBool32", "robustBufferAccess", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fullDrawIndexUint32, settings, "VkBool32", "fullDrawIndexUint32", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.imageCubeArray, settings, "VkBool32", "imageCubeArray", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.independentBlend, settings, "VkBool32", "independentBlend", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.geometryShader, settings, "VkBool32", "geometryShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.tessellationShader, settings, "VkBool32", "tessellationShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sampleRateShading, settings, "VkBool32", "sampleRateShading", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.dualSrcBlend, settings, "VkBool32", "dualSrcBlend", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.logicOp, settings, "VkBool32", "logicOp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiDrawIndirect, settings, "VkBool32", "multiDrawIndirect", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.drawIndirectFirstInstance, settings, "VkBool32", "drawIndirectFirstInstance", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthClamp, settings, "VkBool32", "depthClamp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthBiasClamp, settings, "VkBool32", "depthBiasClamp", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fillModeNonSolid, settings, "VkBool32", "fillModeNonSolid", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.depthBounds, settings, "VkBool32", "depthBounds", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.wideLines, settings, "VkBool32", "wideLines", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.largePoints, settings, "VkBool32", "largePoints", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.alphaToOne, settings, "VkBool32", "alphaToOne", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.multiViewport, settings, "VkBool32", "multiViewport", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.samplerAnisotropy, settings, "VkBool32", "samplerAnisotropy", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureCompressionETC2, settings, "VkBool32", "textureCompressionETC2", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureCompressionASTC_LDR, settings, "VkBool32", "textureCompressionASTC_LDR", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.textureCompressionBC, settings, "VkBool32", "textureCompressionBC", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.occlusionQueryPrecise, settings, "VkBool32", "occlusionQueryPrecise", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.pipelineStatisticsQuery, settings, "VkBool32", "pipelineStatisticsQuery", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.vertexPipelineStoresAndAtomics, settings, "VkBool32", "vertexPipelineStoresAndAtomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.fragmentStoresAndAtomics, settings, "VkBool32", "fragmentStoresAndAtomics", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderTessellationAndGeometryPointSize, settings, "VkBool32", "shaderTessellationAndGeometryPointSize", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderImageGatherExtended, settings, "VkBool32", "shaderImageGatherExtended", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageExtendedFormats, settings, "VkBool32", "shaderStorageImageExtendedFormats", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageMultisample, settings, "VkBool32", "shaderStorageImageMultisample", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageReadWithoutFormat, settings, "VkBool32", "shaderStorageImageReadWithoutFormat", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageWriteWithoutFormat, settings, "VkBool32", "shaderStorageImageWriteWithoutFormat", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderUniformBufferArrayDynamicIndexing, settings, "VkBool32", "shaderUniformBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderSampledImageArrayDynamicIndexing, settings, "VkBool32", "shaderSampledImageArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageBufferArrayDynamicIndexing, settings, "VkBool32", "shaderStorageBufferArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderStorageImageArrayDynamicIndexing, settings, "VkBool32", "shaderStorageImageArrayDynamicIndexing", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderClipDistance, settings, "VkBool32", "shaderClipDistance", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderCullDistance, settings, "VkBool32", "shaderCullDistance", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderFloat64, settings, "VkBool32", "shaderFloat64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInt64, settings, "VkBool32", "shaderInt64", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderInt16, settings, "VkBool32", "shaderInt16", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderResourceResidency, settings, "VkBool32", "shaderResourceResidency", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.shaderResourceMinLod, settings, "VkBool32", "shaderResourceMinLod", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseBinding, settings, "VkBool32", "sparseBinding", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidencyBuffer, settings, "VkBool32", "sparseResidencyBuffer", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidencyImage2D, settings, "VkBool32", "sparseResidencyImage2D", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidencyImage3D, settings, "VkBool32", "sparseResidencyImage3D", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidency2Samples, settings, "VkBool32", "sparseResidency2Samples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidency4Samples, settings, "VkBool32", "sparseResidency4Samples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidency8Samples, settings, "VkBool32", "sparseResidency8Samples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidency16Samples, settings, "VkBool32", "sparseResidency16Samples", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.sparseResidencyAliased, settings, "VkBool32", "sparseResidencyAliased", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.variableMultisampleRate, settings, "VkBool32", "variableMultisampleRate", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.inheritedQueries, settings, "VkBool32", "inheritedQueries", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkExternalMemoryProperties(const VkExternalMemoryProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkExternalMemoryFeatureFlags>(object.externalMemoryFeatures, settings, "VkExternalMemoryFeatureFlags", "externalMemoryFeatures", indents + 1, dump_html_VkExternalMemoryFeatureFlags);
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.exportFromImportedHandleTypes, settings, "VkExternalMemoryHandleTypeFlags", "exportFromImportedHandleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
    dump_html_value<const VkExternalMemoryHandleTypeFlags>(object.compatibleHandleTypes, settings, "VkExternalMemoryHandleTypeFlags", "compatibleHandleTypes", indents + 1, dump_html_VkExternalMemoryHandleTypeFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceExternalImageFormatInfo(const VkPhysicalDeviceExternalImageFormatInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkWriteDescriptorSetAccelerationStructureNV(const VkWriteDescriptorSetAccelerationStructureNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.accelerationStructureCount, settings, "uint32_t", "accelerationStructureCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkAccelerationStructureNV>(object.pAccelerationStructures, object.accelerationStructureCount, settings, "const VkAccelerationStructureNV*", "const VkAccelerationStructureNV", "pAccelerationStructures", indents + 1, dump_html_VkAccelerationStructureNV);
    return settings.stream();
}
std::ostream& dump_html_VkCoarseSampleLocationNV(const VkCoarseSampleLocationNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.pixelX, settings, "uint32_t", "pixelX", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.pixelY, settings, "uint32_t", "pixelY", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.sample, settings, "uint32_t", "sample", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDescriptorSetVariableDescriptorCountAllocateInfoEXT(const VkDescriptorSetVariableDescriptorCountAllocateInfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.descriptorSetCount, settings, "uint32_t", "descriptorSetCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.pDescriptorCounts, object.descriptorSetCount, settings, "const uint32_t*", "const uint32_t", "pDescriptorCounts", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineTessellationStateCreateInfo(const VkPipelineTessellationStateCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkPipelineTessellationStateCreateFlags>(object.flags, settings, "VkPipelineTessellationStateCreateFlags", "flags", indents + 1, dump_html_VkPipelineTessellationStateCreateFlags);
    dump_html_value<const uint32_t>(object.patchControlPoints, settings, "uint32_t", "patchControlPoints", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkExternalImageFormatProperties(const VkExternalImageFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryProperties>(object.externalMemoryProperties, settings, "VkExternalMemoryProperties", "externalMemoryProperties", indents + 1, dump_html_VkExternalMemoryProperties);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceExternalBufferInfo(const VkPhysicalDeviceExternalBufferInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBufferCreateFlags>(object.flags, settings, "VkBufferCreateFlags", "flags", indents + 1, dump_html_VkBufferCreateFlags);
    dump_html_value<const VkBufferUsageFlags>(object.usage, settings, "VkBufferUsageFlags", "usage", indents + 1, dump_html_VkBufferUsageFlags);
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceTimelineSemaphorePropertiesKHR(const VkPhysicalDeviceTimelineSemaphorePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint64_t>(object.maxTimelineSemaphoreValueDifference, settings, "uint64_t", "maxTimelineSemaphoreValueDifference", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceTimelineSemaphoreFeaturesKHR(const VkPhysicalDeviceTimelineSemaphoreFeaturesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.timelineSemaphore, settings, "VkBool32", "timelineSemaphore", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSamplerYcbcrConversionCreateInfo(const VkSamplerYcbcrConversionCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.format, settings, "VkFormat", "format", indents + 1, dump_html_VkFormat);
    dump_html_value<const VkSamplerYcbcrModelConversion>(object.ycbcrModel, settings, "VkSamplerYcbcrModelConversion", "ycbcrModel", indents + 1, dump_html_VkSamplerYcbcrModelConversion);
    dump_html_value<const VkSamplerYcbcrRange>(object.ycbcrRange, settings, "VkSamplerYcbcrRange", "ycbcrRange", indents + 1, dump_html_VkSamplerYcbcrRange);
    dump_html_value<const VkComponentMapping>(object.components, settings, "VkComponentMapping", "components", indents + 1, dump_html_VkComponentMapping);
    dump_html_value<const VkChromaLocation>(object.xChromaOffset, settings, "VkChromaLocation", "xChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkChromaLocation>(object.yChromaOffset, settings, "VkChromaLocation", "yChromaOffset", indents + 1, dump_html_VkChromaLocation);
    dump_html_value<const VkFilter>(object.chromaFilter, settings, "VkFilter", "chromaFilter", indents + 1, dump_html_VkFilter);
    dump_html_value<const VkBool32>(object.forceExplicitReconstruction, settings, "VkBool32", "forceExplicitReconstruction", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDrawIndirectCommand(const VkDrawIndirectCommand& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.vertexCount, settings, "uint32_t", "vertexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.instanceCount, settings, "uint32_t", "instanceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstVertex, settings, "uint32_t", "firstVertex", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstInstance, settings, "uint32_t", "firstInstance", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkSubpassDescriptionDepthStencilResolveKHR(const VkSubpassDescriptionDepthStencilResolveKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkResolveModeFlagBitsKHR>(object.depthResolveMode, settings, "VkResolveModeFlagBitsKHR", "depthResolveMode", indents + 1, dump_html_VkResolveModeFlagBitsKHR);
    dump_html_value<const VkResolveModeFlagBitsKHR>(object.stencilResolveMode, settings, "VkResolveModeFlagBitsKHR", "stencilResolveMode", indents + 1, dump_html_VkResolveModeFlagBitsKHR);
    dump_html_pointer<const VkAttachmentReference2KHR>(object.pDepthStencilResolveAttachment, settings, "const VkAttachmentReference2KHR*", "pDepthStencilResolveAttachment", indents + 1, dump_html_VkAttachmentReference2KHR);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_VI_NN)
std::ostream& dump_html_VkViSurfaceCreateInfoNN(const VkViSurfaceCreateInfoNN& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkViSurfaceCreateFlagsNN>(object.flags, settings, "VkViSurfaceCreateFlagsNN", "flags", indents + 1, dump_html_VkViSurfaceCreateFlagsNN);
    dump_html_value<const void*>(object.window, settings, "void*", "window", indents + 1, dump_html_void);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_VI_NN
std::ostream& dump_html_VkTimelineSemaphoreSubmitInfoKHR(const VkTimelineSemaphoreSubmitInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.waitSemaphoreValueCount, settings, "uint32_t", "waitSemaphoreValueCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pWaitSemaphoreValues, object.waitSemaphoreValueCount, settings, "const uint64_t*", "const uint64_t", "pWaitSemaphoreValues", indents + 1, dump_html_uint64_t);
    dump_html_value<const uint32_t>(object.signalSemaphoreValueCount, settings, "uint32_t", "signalSemaphoreValueCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint64_t>(object.pSignalSemaphoreValues, object.signalSemaphoreValueCount, settings, "const uint64_t*", "const uint64_t", "pSignalSemaphoreValues", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkBaseOutStructure(const VkBaseOutStructure& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    dump_html_pointer<const VkBaseOutStructure>(object.pNext, settings, "struct VkBaseOutStructure*", "pNext", indents + 1, dump_html_VkBaseOutStructure);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_XCB_KHR)
std::ostream& dump_html_VkXcbSurfaceCreateInfoKHR(const VkXcbSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkXcbSurfaceCreateFlagsKHR>(object.flags, settings, "VkXcbSurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkXcbSurfaceCreateFlagsKHR);
    dump_html_value<const xcb_connection_t*>(object.connection, settings, "xcb_", "connection", indents + 1, dump_html_xcb_connection_t);
    dump_html_value<const xcb_window_t>(object.window, settings, "xcb_", "window", indents + 1, dump_html_xcb_window_t);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_XCB_KHR
std::ostream& dump_html_VkPhysicalDeviceDepthStencilResolvePropertiesKHR(const VkPhysicalDeviceDepthStencilResolvePropertiesKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkResolveModeFlagsKHR>(object.supportedDepthResolveModes, settings, "VkResolveModeFlagsKHR", "supportedDepthResolveModes", indents + 1, dump_html_VkResolveModeFlagsKHR);
    dump_html_value<const VkResolveModeFlagsKHR>(object.supportedStencilResolveModes, settings, "VkResolveModeFlagsKHR", "supportedStencilResolveModes", indents + 1, dump_html_VkResolveModeFlagsKHR);
    dump_html_value<const VkBool32>(object.independentResolveNone, settings, "VkBool32", "independentResolveNone", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.independentResolve, settings, "VkBool32", "independentResolve", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSemaphoreCreateInfo(const VkSemaphoreCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphoreCreateFlags>(object.flags, settings, "VkSemaphoreCreateFlags", "flags", indents + 1, dump_html_VkSemaphoreCreateFlags);
    return settings.stream();
}
std::ostream& dump_html_VkSemaphoreTypeCreateInfoKHR(const VkSemaphoreTypeCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphoreTypeKHR>(object.semaphoreType, settings, "VkSemaphoreTypeKHR", "semaphoreType", indents + 1, dump_html_VkSemaphoreTypeKHR);
    dump_html_value<const uint64_t>(object.initialValue, settings, "uint64_t", "initialValue", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT(const VkPhysicalDeviceTextureCompressionASTCHDRFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.textureCompressionASTC_HDR, settings, "VkBool32", "textureCompressionASTC_HDR", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkViewportWScalingNV(const VkViewportWScalingNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.xcoeff, settings, "float", "xcoeff", indents + 1, dump_html_float);
    dump_html_value<const float>(object.ycoeff, settings, "float", "ycoeff", indents + 1, dump_html_float);
    return settings.stream();
}
std::ostream& dump_html_VkSamplerYcbcrConversionInfo(const VkSamplerYcbcrConversionInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSamplerYcbcrConversion>(object.conversion, settings, "VkSamplerYcbcrConversion", "conversion", indents + 1, dump_html_VkSamplerYcbcrConversion);
    return settings.stream();
}
std::ostream& dump_html_VkImageViewASTCDecodeModeEXT(const VkImageViewASTCDecodeModeEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkFormat>(object.decodeMode, settings, "VkFormat", "decodeMode", indents + 1, dump_html_VkFormat);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceMeshShaderPropertiesNV(const VkPhysicalDeviceMeshShaderPropertiesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.maxDrawMeshTasksCount, settings, "uint32_t", "maxDrawMeshTasksCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTaskWorkGroupInvocations, settings, "uint32_t", "maxTaskWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxTaskWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxTaskWorkGroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTaskTotalMemorySize, settings, "uint32_t", "maxTaskTotalMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxTaskOutputCount, settings, "uint32_t", "maxTaskOutputCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshWorkGroupInvocations, settings, "uint32_t", "maxMeshWorkGroupInvocations", indents + 1, dump_html_uint32_t);
    dump_html_array<const uint32_t>(object.maxMeshWorkGroupSize, 3, settings, "uint32_t[3]", "uint32_t", "maxMeshWorkGroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshTotalMemorySize, settings, "uint32_t", "maxMeshTotalMemorySize", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputVertices, settings, "uint32_t", "maxMeshOutputVertices", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshOutputPrimitives, settings, "uint32_t", "maxMeshOutputPrimitives", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.maxMeshMultiviewViewCount, settings, "uint32_t", "maxMeshMultiviewViewCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.meshOutputPerVertexGranularity, settings, "uint32_t", "meshOutputPerVertexGranularity", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.meshOutputPerPrimitiveGranularity, settings, "uint32_t", "meshOutputPerPrimitiveGranularity", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkEventCreateInfo(const VkEventCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkEventCreateFlags>(object.flags, settings, "VkEventCreateFlags", "flags", indents + 1, dump_html_VkEventCreateFlags);
    return settings.stream();
}
std::ostream& dump_html_VkSemaphoreWaitInfoKHR(const VkSemaphoreWaitInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphoreWaitFlagsKHR>(object.flags, settings, "VkSemaphoreWaitFlagsKHR", "flags", indents + 1, dump_html_VkSemaphoreWaitFlagsKHR);
    dump_html_value<const uint32_t>(object.semaphoreCount, settings, "uint32_t", "semaphoreCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkSemaphore>(object.pSemaphores, object.semaphoreCount, settings, "const VkSemaphore*", "const VkSemaphore", "pSemaphores", indents + 1, dump_html_VkSemaphore);
    dump_html_array<const uint64_t>(object.pValues, object.semaphoreCount, settings, "const uint64_t*", "const uint64_t", "pValues", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceASTCDecodeFeaturesEXT(const VkPhysicalDeviceASTCDecodeFeaturesEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.decodeModeSharedExponent, settings, "VkBool32", "decodeModeSharedExponent", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineViewportWScalingStateCreateInfoNV(const VkPipelineViewportWScalingStateCreateInfoNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.viewportWScalingEnable, settings, "VkBool32", "viewportWScalingEnable", indents + 1, dump_html_VkBool32);
    dump_html_value<const uint32_t>(object.viewportCount, settings, "uint32_t", "viewportCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkViewportWScalingNV>(object.pViewportWScalings, object.viewportCount, settings, "const VkViewportWScalingNV*", "const VkViewportWScalingNV", "pViewportWScalings", indents + 1, dump_html_VkViewportWScalingNV);
    return settings.stream();
}
std::ostream& dump_html_VkBindImagePlaneMemoryInfo(const VkBindImagePlaneMemoryInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageAspectFlagBits>(object.planeAspect, settings, "VkImageAspectFlagBits", "planeAspect", indents + 1, dump_html_VkImageAspectFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkClearDepthStencilValue(const VkClearDepthStencilValue& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const float>(object.depth, settings, "float", "depth", indents + 1, dump_html_float);
    dump_html_value<const uint32_t>(object.stencil, settings, "uint32_t", "stencil", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.computeDerivativeGroupQuads, settings, "VkBool32", "computeDerivativeGroupQuads", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.computeDerivativeGroupLinear, settings, "VkBool32", "computeDerivativeGroupLinear", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkSemaphoreSignalInfoKHR(const VkSemaphoreSignalInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkSemaphore>(object.semaphore, settings, "VkSemaphore", "semaphore", indents + 1, dump_html_VkSemaphore);
    dump_html_value<const uint64_t>(object.value, settings, "uint64_t", "value", indents + 1, dump_html_uint64_t);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
std::ostream& dump_html_VkWaylandSurfaceCreateInfoKHR(const VkWaylandSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkWaylandSurfaceCreateFlagsKHR>(object.flags, settings, "VkWaylandSurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkWaylandSurfaceCreateFlagsKHR);
    dump_html_pointer<const wl_display>(object.display, settings, "struct wl_", "display", indents + 1, dump_html_wl_display);
    dump_html_pointer<const wl_surface>(object.surface, settings, "struct wl_", "surface", indents + 1, dump_html_wl_surface);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
std::ostream& dump_html_VkRenderPassBeginInfo(const VkRenderPassBeginInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkRenderPass>(object.renderPass, settings, "VkRenderPass", "renderPass", indents + 1, dump_html_VkRenderPass);
    dump_html_value<const VkFramebuffer>(object.framebuffer, settings, "VkFramebuffer", "framebuffer", indents + 1, dump_html_VkFramebuffer);
    dump_html_value<const VkRect2D>(object.renderArea, settings, "VkRect2D", "renderArea", indents + 1, dump_html_VkRect2D);
    dump_html_value<const uint32_t>(object.clearValueCount, settings, "uint32_t", "clearValueCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkClearValue>(object.pClearValues, object.clearValueCount, settings, "const VkClearValue*", "const VkClearValue", "pClearValues", indents + 1, dump_html_VkClearValue);
    return settings.stream();
}
std::ostream& dump_html_VkImagePlaneMemoryRequirementsInfo(const VkImagePlaneMemoryRequirementsInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkImageAspectFlagBits>(object.planeAspect, settings, "VkImageAspectFlagBits", "planeAspect", indents + 1, dump_html_VkImageAspectFlagBits);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceMeshShaderFeaturesNV(const VkPhysicalDeviceMeshShaderFeaturesNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.taskShader, settings, "VkBool32", "taskShader", indents + 1, dump_html_VkBool32);
    dump_html_value<const VkBool32>(object.meshShader, settings, "VkBool32", "meshShader", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSamplerYcbcrConversionFeatures(const VkPhysicalDeviceSamplerYcbcrConversionFeatures& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.samplerYcbcrConversion, settings, "VkBool32", "samplerYcbcrConversion", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkImportMemoryWin32HandleInfoKHR(const VkImportMemoryWin32HandleInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(object.handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", indents + 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
    dump_html_value<const HANDLE>(object.handle, settings, "HANDLE", "handle", indents + 1, dump_html_HANDLE);
    dump_html_value<const LPCWSTR>(object.name, settings, "LPCWSTR", "name", indents + 1, dump_html_LPCWSTR);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_VkAndroidSurfaceCreateInfoKHR(const VkAndroidSurfaceCreateInfoKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkAndroidSurfaceCreateFlagsKHR>(object.flags, settings, "VkAndroidSurfaceCreateFlagsKHR", "flags", indents + 1, dump_html_VkAndroidSurfaceCreateFlagsKHR);
    dump_html_value<const ANativeWindow*>(object.window, settings, "struct ANativeWindow*", "window", indents + 1, dump_html_ANativeWindow);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_VkBaseInStructure(const VkBaseInStructure& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    dump_html_pointer<const VkBaseInStructure>(object.pNext, settings, "const struct VkBaseInStructure*", "pNext", indents + 1, dump_html_VkBaseInStructure);
    return settings.stream();
}
std::ostream& dump_html_VkClearAttachment(const VkClearAttachment& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkImageAspectFlags>(object.aspectMask, settings, "VkImageAspectFlags", "aspectMask", indents + 1, dump_html_VkImageAspectFlags);
    dump_html_value<const uint32_t>(object.colorAttachment, settings, "uint32_t", "colorAttachment", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkClearValue>(object.clearValue, settings, "VkClearValue", "clearValue", indents + 1, dump_html_VkClearValue);
    return settings.stream();
}
std::ostream& dump_html_VkSamplerYcbcrConversionImageFormatProperties(const VkSamplerYcbcrConversionImageFormatProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.combinedImageSamplerDescriptorCount, settings, "uint32_t", "combinedImageSamplerDescriptorCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkClearRect(const VkClearRect& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkRect2D>(object.rect, settings, "VkRect2D", "rect", indents + 1, dump_html_VkRect2D);
    dump_html_value<const uint32_t>(object.baseArrayLayer, settings, "uint32_t", "baseArrayLayer", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.layerCount, settings, "uint32_t", "layerCount", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkDrawMeshTasksIndirectCommandNV(const VkDrawMeshTasksIndirectCommandNV& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.taskCount, settings, "uint32_t", "taskCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstTask, settings, "uint32_t", "firstTask", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkBool32>(object.shaderIntegerFunctions2, settings, "VkBool32", "shaderIntegerFunctions2", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkQueryPoolCreateInfo(const VkQueryPoolCreateInfo& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const VkQueryPoolCreateFlags>(object.flags, settings, "VkQueryPoolCreateFlags", "flags", indents + 1, dump_html_VkQueryPoolCreateFlags);
    dump_html_value<const VkQueryType>(object.queryType, settings, "VkQueryType", "queryType", indents + 1, dump_html_VkQueryType);
    dump_html_value<const uint32_t>(object.queryCount, settings, "uint32_t", "queryCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkQueryPipelineStatisticFlags>(object.pipelineStatistics, settings, "VkQueryPipelineStatisticFlags", "pipelineStatistics", indents + 1, dump_html_VkQueryPipelineStatisticFlags);
    return settings.stream();
}
std::ostream& dump_html_VkPhysicalDeviceSubgroupProperties(const VkPhysicalDeviceSubgroupProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.subgroupSize, settings, "uint32_t", "subgroupSize", indents + 1, dump_html_uint32_t);
    dump_html_value<const VkShaderStageFlags>(object.supportedStages, settings, "VkShaderStageFlags", "supportedStages", indents + 1, dump_html_VkShaderStageFlags);
    dump_html_value<const VkSubgroupFeatureFlags>(object.supportedOperations, settings, "VkSubgroupFeatureFlags", "supportedOperations", indents + 1, dump_html_VkSubgroupFeatureFlags);
    dump_html_value<const VkBool32>(object.quadOperationsInAllStages, settings, "VkBool32", "quadOperationsInAllStages", indents + 1, dump_html_VkBool32);
    return settings.stream();
}
std::ostream& dump_html_VkDispatchIndirectCommand(const VkDispatchIndirectCommand& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.x, settings, "uint32_t", "x", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.y, settings, "uint32_t", "y", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.z, settings, "uint32_t", "z", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkValidationFlagsEXT(const VkValidationFlagsEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    if(object.pNext != nullptr){
        dump_html_pNext_trampoline(object.pNext, settings, indents + 1);
    } else {
        dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    }
    dump_html_value<const uint32_t>(object.disabledValidationCheckCount, settings, "uint32_t", "disabledValidationCheckCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkValidationCheckEXT>(object.pDisabledValidationChecks, object.disabledValidationCheckCount, settings, "const VkValidationCheckEXT*", "const VkValidationCheckEXT", "pDisabledValidationChecks", indents + 1, dump_html_VkValidationCheckEXT);
    return settings.stream();
}
std::ostream& dump_html_VkDrawIndexedIndirectCommand(const VkDrawIndexedIndirectCommand& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.indexCount, settings, "uint32_t", "indexCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.instanceCount, settings, "uint32_t", "instanceCount", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint32_t>(object.firstIndex, settings, "uint32_t", "firstIndex", indents + 1, dump_html_uint32_t);
    dump_html_value<const int32_t>(object.vertexOffset, settings, "int32_t", "vertexOffset", indents + 1, dump_html_int32_t);
    dump_html_value<const uint32_t>(object.firstInstance, settings, "uint32_t", "firstInstance", indents + 1, dump_html_uint32_t);
    return settings.stream();
}

#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_VkSurfaceFullScreenExclusiveWin32InfoEXT(const VkSurfaceFullScreenExclusiveWin32InfoEXT& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    dump_html_value<const void*>(object.pNext, settings, "const void*", "pNext", indents + 1, dump_html_void);
    dump_html_value<const HMONITOR>(object.hmonitor, settings, "HMONITOR", "hmonitor", indents + 1, dump_html_HMONITOR);
    return settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR

std::ostream& dump_html_VkPhysicalDeviceMemoryProperties(const VkPhysicalDeviceMemoryProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.memoryTypeCount, settings, "uint32_t", "memoryTypeCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMemoryType>(object.memoryTypes, object.memoryTypeCount, settings, "VkMemoryType[VK_MAX_MEMORY_TYPES]", "VkMemoryType", "memoryTypes", indents + 1, dump_html_VkMemoryType);
    dump_html_value<const uint32_t>(object.memoryHeapCount, settings, "uint32_t", "memoryHeapCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkMemoryHeap>(object.memoryHeaps, object.memoryHeapCount, settings, "VkMemoryHeap[VK_MAX_MEMORY_HEAPS]", "VkMemoryHeap", "memoryHeaps", indents + 1, dump_html_VkMemoryHeap);
    return settings.stream();
}

std::ostream& dump_html_VkPhysicalDeviceGroupProperties(const VkPhysicalDeviceGroupProperties& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << "\n";
    else
        settings.stream() << "address\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkStructureType>(object.sType, settings, "VkStructureType", "sType", indents + 1, dump_html_VkStructureType);
    dump_html_value<const void*>(object.pNext, settings, "void*", "pNext", indents + 1, dump_html_void);
    dump_html_value<const uint32_t>(object.physicalDeviceCount, settings, "uint32_t", "physicalDeviceCount", indents + 1, dump_html_uint32_t);
    dump_html_array<const VkPhysicalDevice>(object.physicalDevices, object.physicalDeviceCount, settings, "VkPhysicalDevice[VK_MAX_DEVICE_GROUP_SIZE]", "VkPhysicalDevice", "physicalDevices", indents + 1, dump_html_VkPhysicalDevice);
    dump_html_value<const VkBool32>(object.subsetAllocation, settings, "VkBool32", "subsetAllocation", indents + 1, dump_html_VkBool32);
    return settings.stream();
}

//========================== Union Implementations ==========================//

std::ostream& dump_html_VkPerformanceValueDataINTEL(const VkPerformanceValueDataINTEL& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const uint32_t>(object.value32, settings, "uint32_t", "value32", indents + 1, dump_html_uint32_t);
    dump_html_value<const uint64_t>(object.value64, settings, "uint64_t", "value64", indents + 1, dump_html_uint64_t);
    dump_html_value<const float>(object.valueFloat, settings, "float", "valueFloat", indents + 1, dump_html_float);
    dump_html_value<const VkBool32>(object.valueBool, settings, "VkBool32", "valueBool", indents + 1, dump_html_VkBool32);
    dump_html_value<const char*>(object.valueString, settings, "const char*", "valueString", indents + 1, dump_html_cstring);
    return settings.stream();
}
std::ostream& dump_html_VkClearColorValue(const VkClearColorValue& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_array<const float>(object.float32, 4, settings, "float[4]", "float", "float32", indents + 1, dump_html_float);
    dump_html_array<const int32_t>(object.int32, 4, settings, "int32_t[4]", "int32_t", "int32", indents + 1, dump_html_int32_t);
    dump_html_array<const uint32_t>(object.uint32, 4, settings, "uint32_t[4]", "uint32_t", "uint32", indents + 1, dump_html_uint32_t);
    return settings.stream();
}
std::ostream& dump_html_VkPipelineExecutableStatisticValueKHR(const VkPipelineExecutableStatisticValueKHR& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkBool32>(object.b32, settings, "VkBool32", "b32", indents + 1, dump_html_VkBool32);
    dump_html_value<const int64_t>(object.i64, settings, "int64_t", "i64", indents + 1, dump_html_int64_t);
    dump_html_value<const uint64_t>(object.u64, settings, "uint64_t", "u64", indents + 1, dump_html_uint64_t);
    dump_html_value<const double>(object.f64, settings, "double", "f64", indents + 1, dump_html_double);
    return settings.stream();
}
std::ostream& dump_html_VkClearValue(const VkClearValue& object, const ApiDumpSettings& settings, int indents)
{
    settings.stream() << "<div class='val'>";
    if(settings.showAddress())
        settings.stream() << &object << " (Union):\n";
    else
        settings.stream() << "address (Union):\n";
    settings.stream() << "</div></summary>";
    dump_html_value<const VkClearColorValue>(object.color, settings, "VkClearColorValue", "color", indents + 1, dump_html_VkClearColorValue);
    dump_html_value<const VkClearDepthStencilValue>(object.depthStencil, settings, "VkClearDepthStencilValue", "depthStencil", indents + 1, dump_html_VkClearDepthStencilValue);
    return settings.stream();
}

//========================= Function Implementations ========================//

std::ostream& dump_html_head_vkGetBufferDeviceAddressEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferDeviceAddressInfoEXT* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetBufferDeviceAddressEXT(device, pInfo)", "VkDeviceAddress");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDebugReportMessageEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDebugReportMessageEXT(instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkQueuePresentKHR(ApiDumpInstance& dump_inst, VkQueue queue, const VkPresentInfoKHR* pPresentInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkQueuePresentKHR(queue, pPresentInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDebugMarkerSetObjectTagEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDebugMarkerSetObjectTagEXT(device, pTagInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPastPresentationTimingGOOGLE(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPastPresentationTimingGOOGLE(device, swapchain, pPresentationTimingCount, pPresentationTimings)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageSparseMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageSparseMemoryRequirements(device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkQueueWaitIdle(ApiDumpInstance& dump_inst, VkQueue queue)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkQueueWaitIdle(queue)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkEnumerateInstanceLayerProperties(ApiDumpInstance& dump_inst, uint32_t* pPropertyCount, VkLayerProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkEnumerateInstanceLayerProperties(pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBindTransformFeedbackBuffersEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBindTransformFeedbackBuffersEXT(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetBufferMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetBufferMemoryRequirements(device, buffer, pMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyDebugReportCallbackEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyDebugReportCallbackEXT(instance, callback, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDebugMarkerSetObjectNameEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDebugMarkerSetObjectNameEXT(device, pNameInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDeviceQueue(ApiDumpInstance& dump_inst, VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDeviceQueue(device, queueFamilyIndex, queueIndex, pQueue)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDeviceWaitIdle(ApiDumpInstance& dump_inst, VkDevice device)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDeviceWaitIdle(device)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDebugMarkerBeginEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDebugMarkerBeginEXT(commandBuffer, pMarkerInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageMemoryRequirements(device, image, pMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDebugMarkerEndEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDebugMarkerEndEXT(commandBuffer)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetRefreshCycleDurationGOOGLE(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetRefreshCycleDurationGOOGLE(device, swapchain, pDisplayTimingProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkAllocateMemory(ApiDumpInstance& dump_inst, VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkAllocateMemory(device, pAllocateInfo, pAllocator, pMemory)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDebugMarkerInsertEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDebugMarkerInsertEXT(commandBuffer, pMarkerInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkEnumerateDeviceLayerProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkEnumerateDeviceLayerProperties(physicalDevice, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetCalibratedTimestampsEXT(ApiDumpInstance& dump_inst, VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetCalibratedTimestampsEXT(device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkQueueSubmit(ApiDumpInstance& dump_inst, VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkQueueSubmit(queue, submitCount, pSubmits, fence)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkUnmapMemory(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkUnmapMemory(device, memory)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceProperties(physicalDevice, pProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkMapMemory(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkMapMemory(device, memory, offset, size, flags, ppData)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBeginTransformFeedbackEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBeginTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkFreeMemory(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkFreeMemory(device, memory, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceMemoryProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceMemoryProperties(physicalDevice, pMemoryProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainEXT* pTimeDomains)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(physicalDevice, pTimeDomainCount, pTimeDomains)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdEndTransformFeedbackEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdEndTransformFeedbackEXT(commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSurfaceFormats2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(physicalDevice, pCombinationCount, pCombinations)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkBindBufferMemory(ApiDumpInstance& dump_inst, VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkBindBufferMemory(device, buffer, memory, memoryOffset)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSparseImageFormatProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBeginQueryIndexedEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBeginQueryIndexedEXT(commandBuffer, queryPool, query, flags, index)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSurfaceCapabilities2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice, pSurfaceInfo, pSurfaceCapabilities)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkFlushMappedMemoryRanges(ApiDumpInstance& dump_inst, VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkFlushMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdEndQueryIndexedEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdEndQueryIndexedEXT(commandBuffer, queryPool, query, index)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceQueueFamilyProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawIndirectByteCountEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawIndirectByteCountEXT(commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkInitializePerformanceApiINTEL(ApiDumpInstance& dump_inst, VkDevice device, const VkInitializePerformanceApiInfoINTEL* pInitializeInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkInitializePerformanceApiINTEL(device, pInitializeInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkUninitializePerformanceApiINTEL(ApiDumpInstance& dump_inst, VkDevice device)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkUninitializePerformanceApiINTEL(device)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkQueueBindSparse(ApiDumpInstance& dump_inst, VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkQueueBindSparse(queue, bindInfoCount, pBindInfo, fence)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetMemoryHostPointerPropertiesEXT(ApiDumpInstance& dump_inst, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetMemoryHostPointerPropertiesEXT(device, handleType, pHostPointer, pMemoryHostPointerProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetPerformanceMarkerINTEL(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetPerformanceMarkerINTEL(commandBuffer, pMarkerInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkInvalidateMappedMemoryRanges(ApiDumpInstance& dump_inst, VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkInvalidateMappedMemoryRanges(device, memoryRangeCount, pMemoryRanges)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetPerformanceStreamMarkerINTEL(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetPerformanceStreamMarkerINTEL(commandBuffer, pMarkerInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdWriteBufferMarkerAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdWriteBufferMarkerAMD(commandBuffer, pipelineStage, dstBuffer, dstOffset, marker)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDeviceMemoryCommitment(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDeviceMemoryCommitment(device, memory, pCommittedMemoryInBytes)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetPerformanceOverrideINTEL(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetPerformanceOverrideINTEL(commandBuffer, pOverrideInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkReleasePerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkDevice device, VkPerformanceConfigurationINTEL configuration)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkReleasePerformanceConfigurationINTEL(device, configuration)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDeviceGroupPresentCapabilitiesKHR(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDeviceGroupPresentCapabilitiesKHR(device, pDeviceGroupPresentCapabilities)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkBindImageMemory(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkBindImageMemory(device, image, memory, memoryOffset)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(physicalDevice, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkAcquirePerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkAcquirePerformanceConfigurationINTEL(device, pAcquireInfo, pConfiguration)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkGetPhysicalDeviceSurfacePresentModes2EXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSurfacePresentModes2EXT(physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkUpdateDescriptorSets(ApiDumpInstance& dump_inst, VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkUpdateDescriptorSets(device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdPushDescriptorSetKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdPushDescriptorSetKHR(commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkQueueSetPerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkQueue queue, VkPerformanceConfigurationINTEL configuration)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkQueueSetPerformanceConfigurationINTEL(queue, configuration)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDisplayPlaneSupportedDisplaysKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice, planeIndex, pDisplayCount, pDisplays)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawMeshTasksIndirectCountNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawMeshTasksIndirectCountNV(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawMeshTasksIndirectNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawMeshTasksIndirectNV(commandBuffer, buffer, offset, drawCount, stride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkCreateWin32SurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateWin32SurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkGetPerformanceParameterINTEL(ApiDumpInstance& dump_inst, VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPerformanceParameterINTEL(device, parameter, pValue)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetRayTracingShaderGroupHandlesNV(ApiDumpInstance& dump_inst, VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetRayTracingShaderGroupHandlesNV(device, pipeline, firstGroup, groupCount, dataSize, pData)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkGetPhysicalDeviceWin32PresentationSupportKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice, queueFamilyIndex)", "VkBool32");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkGetAccelerationStructureHandleNV(ApiDumpInstance& dump_inst, VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetAccelerationStructureHandleNV(device, accelerationStructure, dataSize, pData)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdPushDescriptorSetWithTemplateKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer, descriptorUpdateTemplate, layout, set, pData)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceDisplayPropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdWriteAccelerationStructuresPropertiesNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdWriteAccelerationStructuresPropertiesNV(commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSurfaceCapabilities2EXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice, surface, pSurfaceCapabilities)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDisplayModePropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDisplayModePropertiesKHR(physicalDevice, display, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateDisplayModeKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDisplayModeKHR(physicalDevice, display, pCreateInfo, pAllocator, pMode)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateFramebuffer(ApiDumpInstance& dump_inst, VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateFramebuffer(device, pCreateInfo, pAllocator, pFramebuffer)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageSparseMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageSparseMemoryRequirements2(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetDiscardRectangleEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetDiscardRectangleEXT(commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDisplayPlaneCapabilitiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDisplayPlaneCapabilitiesKHR(physicalDevice, mode, planeIndex, pCapabilities)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageMemoryRequirements2(device, pInfo, pMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetExclusiveScissorNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetExclusiveScissorNV(commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateDisplayPlaneSurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDisplayPlaneSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetBufferMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetBufferMemoryRequirements2(device, pInfo, pMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkSetLocalDimmingAMD(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkSetLocalDimmingAMD(device, swapChain, localDimmingEnable)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCompileDeferredNV(ApiDumpInstance& dump_inst, VkDevice device, VkPipeline pipeline, uint32_t shader)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCompileDeferredNV(device, pipeline, shader)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
std::ostream& dump_html_head_vkCreateImagePipeSurfaceFUCHSIA(ApiDumpInstance& dump_inst, VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateImagePipeSurfaceFUCHSIA(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_FUCHSIA
std::ostream& dump_html_head_vkCmdBeginConditionalRenderingEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBeginConditionalRenderingEXT(commandBuffer, pConditionalRenderingBegin)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetCheckpointNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const void* pCheckpointMarker)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetCheckpointNV(commandBuffer, pCheckpointMarker)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageViewHandleNVX(ApiDumpInstance& dump_inst, VkDevice device, const VkImageViewHandleInfoNVX* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageViewHandleNVX(device, pInfo)", "uint32_t");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkRegisterDeviceEventEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkRegisterDeviceEventEXT(device, pDeviceEventInfo, pAllocator, pFence)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetSampleLocationsEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetSampleLocationsEXT(commandBuffer, pSampleLocationsInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdEndConditionalRenderingEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdEndConditionalRenderingEXT(commandBuffer)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawIndirectCountKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDisplayPowerControlEXT(ApiDumpInstance& dump_inst, VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDisplayPowerControlEXT(device, display, pDisplayPowerInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageSparseMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageSparseMemoryRequirements2KHR(device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateDescriptorUpdateTemplateKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDescriptorUpdateTemplateKHR(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDescriptorSetLayoutSupportKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDescriptorSetLayoutSupportKHR(device, pCreateInfo, pSupport)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkRegisterDisplayEventEXT(ApiDumpInstance& dump_inst, VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkRegisterDisplayEventEXT(device, display, pDisplayEventInfo, pAllocator, pFence)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
std::ostream& dump_html_head_vkCreateMetalSurfaceEXT(ApiDumpInstance& dump_inst, VkInstance instance, const VkMetalSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateMetalSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_METAL_EXT
std::ostream& dump_html_head_vkCmdDrawIndirectCountAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetSwapchainCounterEXT(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetSwapchainCounterEXT(device, swapchain, counter, pCounterValue)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateRenderPass(ApiDumpInstance& dump_inst, VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateRenderPass(device, pCreateInfo, pAllocator, pRenderPass)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceMultisamplePropertiesEXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceMultisamplePropertiesEXT(physicalDevice, samples, pMultisampleProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawIndexedIndirectCountAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawIndexedIndirectCountAMD(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawIndexedIndirectCountKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawIndexedIndirectCountKHR(commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyFramebuffer(ApiDumpInstance& dump_inst, VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyFramebuffer(device, framebuffer, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageMemoryRequirements2KHR(device, pInfo, pMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetBufferMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetBufferMemoryRequirements2KHR(device, pInfo, pMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetQueueCheckpointDataNV(ApiDumpInstance& dump_inst, VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetQueueCheckpointDataNV(queue, pCheckpointDataCount, pCheckpointData)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdWaitEvents(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdWaitEvents(commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSurfaceSupportKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice, queueFamilyIndex, surface, pSupported)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateSharedSwapchainsKHR(ApiDumpInstance& dump_inst, VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateSharedSwapchainsKHR(device, swapchainCount, pCreateInfos, pAllocator, pSwapchains)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateComputePipelines(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateComputePipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkAcquireFullScreenExclusiveModeEXT(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkAcquireFullScreenExclusiveModeEXT(device, swapchain)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkGetPhysicalDeviceSurfaceFormatsKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkReleaseFullScreenExclusiveModeEXT(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkReleaseFullScreenExclusiveModeEXT(device, swapchain)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkCreateCommandPool(ApiDumpInstance& dump_inst, VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateCommandPool(device, pCreateInfo, pAllocator, pCommandPool)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice, surface, pSurfaceCapabilities)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetEvent(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetEvent(commandBuffer, event, stageMask)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkSetHdrMetadataEXT(ApiDumpInstance& dump_inst, VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkSetHdrMetadataEXT(device, swapchainCount, pSwapchains, pMetadata)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPipelineExecutablePropertiesKHR(ApiDumpInstance& dump_inst, VkDevice                        device, const VkPipelineInfoKHR*        pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPipelineExecutablePropertiesKHR(device, pPipelineInfo, pExecutableCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdResetEvent(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdResetEvent(commandBuffer, event, stageMask)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkGetDeviceGroupSurfacePresentModes2EXT(ApiDumpInstance& dump_inst, VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDeviceGroupSurfacePresentModes2EXT(device, pSurfaceInfo, pModes)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkGetPhysicalDeviceFeatures2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceFeatures2(physicalDevice, pFeatures)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateHeadlessSurfaceEXT(ApiDumpInstance& dump_inst, VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateHeadlessSurfaceEXT(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetRenderAreaGranularity(ApiDumpInstance& dump_inst, VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetRenderAreaGranularity(device, renderPass, pGranularity)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDisplayModeProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDisplayModeProperties2KHR(physicalDevice, display, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetShaderInfoAMD(ApiDumpInstance& dump_inst, VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetShaderInfoAMD(device, pipeline, shaderStage, infoType, pInfoSize, pInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPipelineExecutableStatisticsKHR(ApiDumpInstance& dump_inst, VkDevice                        device, const VkPipelineExecutableInfoKHR*  pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPipelineExecutableStatisticsKHR(device, pExecutableInfo, pStatisticCount, pStatistics)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreatePipelineLayout(ApiDumpInstance& dump_inst, VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreatePipelineLayout(device, pCreateInfo, pAllocator, pPipelineLayout)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyRenderPass(ApiDumpInstance& dump_inst, VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyRenderPass(device, renderPass, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceProperties2(physicalDevice, pProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPipelineExecutableInternalRepresentationsKHR(ApiDumpInstance& dump_inst, VkDevice                        device, const VkPipelineExecutableInfoKHR*  pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPipelineExecutableInternalRepresentationsKHR(device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceMemoryProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceMemoryProperties2(physicalDevice, pMemoryProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceFormatProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceFormatProperties2(physicalDevice, format, pFormatProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSurfacePresentModesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice, surface, pPresentModeCount, pPresentModes)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdPipelineBarrier(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdPipelineBarrier(commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceDisplayProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceDisplayProperties2KHR(physicalDevice, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceImageFormatProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceImageFormatProperties2(physicalDevice, pImageFormatInfo, pImageFormatProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateRenderPass2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkRenderPassCreateInfo2KHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateRenderPass2KHR(device, pCreateInfo, pAllocator, pRenderPass)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyPipeline(ApiDumpInstance& dump_inst, VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyPipeline(device, pipeline, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceDisplayPlaneProperties2KHR(physicalDevice, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSparseImageFormatProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSparseImageFormatProperties2(physicalDevice, pFormatInfo, pPropertyCount, pProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdProcessCommandsNVX(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdProcessCommandsNVX(commandBuffer, pProcessCommandsInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceQueueFamilyProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceQueueFamilyProperties2(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
std::ostream& dump_html_head_vkCreateXlibSurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateXlibSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_XLIB_KHR
std::ostream& dump_html_head_vkFreeCommandBuffers(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyPipelineLayout(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyPipelineLayout(device, pipelineLayout, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkTrimCommandPool(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkTrimCommandPool(device, commandPool, flags)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDisplayPlaneCapabilities2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDisplayPlaneCapabilities2KHR(physicalDevice, pDisplayPlaneInfo, pCapabilities)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
std::ostream& dump_html_head_vkGetPhysicalDeviceXlibPresentationSupportKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice, queueFamilyIndex, dpy, visualID)", "VkBool32");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_XLIB_KHR
std::ostream& dump_html_head_vkDestroyCommandPool(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyCommandPool(device, commandPool, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkResetCommandPool(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkResetCommandPool(device, commandPool, flags)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
std::ostream& dump_html_head_vkCreateIOSSurfaceMVK(ApiDumpInstance& dump_inst, VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateIOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_IOS_MVK
std::ostream& dump_html_head_vkCmdReserveSpaceForCommandsNVX(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdReserveSpaceForCommandsNVX(commandBuffer, pReserveSpaceInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBeginQuery(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBeginQuery(commandBuffer, queryPool, query, flags)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetLineStippleEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetLineStippleEXT(commandBuffer, lineStippleFactor, lineStipplePattern)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateIndirectCommandsLayoutNVX(ApiDumpInstance& dump_inst, VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateIndirectCommandsLayoutNVX(device, pCreateInfo, pAllocator, pIndirectCommandsLayout)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkResetQueryPoolEXT(ApiDumpInstance& dump_inst, VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkResetQueryPoolEXT(device, queryPool, firstQuery, queryCount)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkAllocateCommandBuffers(ApiDumpInstance& dump_inst, VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyIndirectCommandsLayoutNVX(ApiDumpInstance& dump_inst, VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyIndirectCommandsLayoutNVX(device, indirectCommandsLayout, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_GGP)
std::ostream& dump_html_head_vkCreateStreamDescriptorSurfaceGGP(ApiDumpInstance& dump_inst, VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateStreamDescriptorSurfaceGGP(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_GGP
std::ostream& dump_html_head_vkUpdateDescriptorSetWithTemplateKHR(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkUpdateDescriptorSetWithTemplateKHR(device, descriptorSet, descriptorUpdateTemplate, pData)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDispatch(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDispatch(commandBuffer, groupCountX, groupCountY, groupCountZ)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyInstance(ApiDumpInstance& dump_inst, VkInstance instance, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyInstance(instance, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyDescriptorUpdateTemplateKHR(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyDescriptorUpdateTemplateKHR(device, descriptorUpdateTemplate, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdCopyBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdCopyBuffer(commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateInstance(ApiDumpInstance& dump_inst, const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateInstance(pCreateInfo, pAllocator, pInstance)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateAccelerationStructureNV(ApiDumpInstance& dump_inst, VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateAccelerationStructureNV(device, pCreateInfo, pAllocator, pAccelerationStructure)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDispatchIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDispatchIndirect(commandBuffer, buffer, offset)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdCopyImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdCopyImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateFence(ApiDumpInstance& dump_inst, VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateFence(device, pCreateInfo, pAllocator, pFence)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBlitImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBlitImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkBindBufferMemory2(ApiDumpInstance& dump_inst, VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkBindBufferMemory2(device, bindInfoCount, pBindInfos)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkBindImageMemory2(ApiDumpInstance& dump_inst, VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkBindImageMemory2(device, bindInfoCount, pBindInfos)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBuildAccelerationStructureNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBuildAccelerationStructureNV(commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetAccelerationStructureMemoryRequirementsNV(ApiDumpInstance& dump_inst, VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetAccelerationStructureMemoryRequirementsNV(device, pInfo, pMemoryRequirements)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyAccelerationStructureNV(ApiDumpInstance& dump_inst, VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyAccelerationStructureNV(device, accelerationStructure, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkBindAccelerationStructureMemoryNV(ApiDumpInstance& dump_inst, VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkBindAccelerationStructureMemoryNV(device, bindInfoCount, pBindInfos)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdCopyBufferToImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdCopyBufferToImage(commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdCopyAccelerationStructureNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeNV mode)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdCopyAccelerationStructureNV(commandBuffer, dst, src, mode)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkGetMemoryWin32HandleNV(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetMemoryWin32HandleNV(device, memory, handleType, pHandle)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkGetPhysicalDeviceFormatProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceFormatProperties(physicalDevice, format, pFormatProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkResetFences(ApiDumpInstance& dump_inst, VkDevice device, uint32_t fenceCount, const VkFence* pFences)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkResetFences(device, fenceCount, pFences)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdTraceRaysNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdTraceRaysNV(commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateRayTracingPipelinesNV(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateRayTracingPipelinesNV(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyFence(ApiDumpInstance& dump_inst, VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyFence(device, fence, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdCopyImageToBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdCopyImageToBuffer(commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkSetDebugUtilsObjectNameEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkSetDebugUtilsObjectNameEXT(device, pNameInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateShaderModule(ApiDumpInstance& dump_inst, VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateShaderModule(device, pCreateInfo, pAllocator, pShaderModule)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateBufferView(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateBufferView(device, pCreateInfo, pAllocator, pView)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetViewportShadingRatePaletteNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetViewportShadingRatePaletteNV(commandBuffer, firstViewport, viewportCount, pShadingRatePalettes)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkSetDebugUtilsObjectTagEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkSetDebugUtilsObjectTagEXT(device, pTagInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreatePipelineCache(ApiDumpInstance& dump_inst, VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreatePipelineCache(device, pCreateInfo, pAllocator, pPipelineCache)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkQueueInsertDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkQueueInsertDebugUtilsLabelEXT(queue, pLabelInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkQueueBeginDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkQueueBeginDebugUtilsLabelEXT(queue, pLabelInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkQueueEndDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkQueueEndDebugUtilsLabelEXT(queue)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBindShadingRateImageNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBindShadingRateImageNV(commandBuffer, imageView, imageLayout)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyBuffer(ApiDumpInstance& dump_inst, VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyBuffer(device, buffer, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyShaderModule(ApiDumpInstance& dump_inst, VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyShaderModule(device, shaderModule, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBeginDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBeginDebugUtilsLabelEXT(commandBuffer, pLabelInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetCoarseSampleOrderNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetCoarseSampleOrderNV(commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdEndDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdEndDebugUtilsLabelEXT(commandBuffer)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdInsertDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdInsertDebugUtilsLabelEXT(commandBuffer, pLabelInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkImportSemaphoreWin32HandleKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkImportSemaphoreWin32HandleKHR(device, pImportSemaphoreWin32HandleInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkCreateDebugUtilsMessengerEXT(ApiDumpInstance& dump_inst, VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDebugUtilsMessengerEXT(instance, pCreateInfo, pAllocator, pMessenger)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateImage(ApiDumpInstance& dump_inst, VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateImage(device, pCreateInfo, pAllocator, pImage)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPipelineCacheData(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPipelineCacheData(device, pipelineCache, pDataSize, pData)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkSubmitDebugUtilsMessageEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, pCallbackData)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyBufferView(ApiDumpInstance& dump_inst, VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyBufferView(device, bufferView, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdNextSubpass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSubpassBeginInfoKHR*      pSubpassBeginInfo, const VkSubpassEndInfoKHR*        pSubpassEndInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdNextSubpass2KHR(commandBuffer, pSubpassBeginInfo, pSubpassEndInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyPipelineCache(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyPipelineCache(device, pipelineCache, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyImage(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyImage(device, image, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyDebugUtilsMessengerEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyDebugUtilsMessengerEXT(instance, messenger, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkMergePipelineCaches(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkMergePipelineCaches(device, dstCache, srcCacheCount, pSrcCaches)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateGraphicsPipelines(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateGraphicsPipelines(device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkGetSemaphoreWin32HandleKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetSemaphoreWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkImportSemaphoreFdKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkImportSemaphoreFdKHR(device, pImportSemaphoreFdInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBeginRenderPass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo*      pRenderPassBegin, const VkSubpassBeginInfoKHR*      pSubpassBeginInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBeginRenderPass2KHR(commandBuffer, pRenderPassBegin, pSubpassBeginInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetSemaphoreFdKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetSemaphoreFdKHR(device, pGetFdInfo, pFd)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_MACOS_MVK)
std::ostream& dump_html_head_vkCreateMacOSSurfaceMVK(ApiDumpInstance& dump_inst, VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateMacOSSurfaceMVK(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_MACOS_MVK
std::ostream& dump_html_head_vkCreateSampler(ApiDumpInstance& dump_inst, VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateSampler(device, pCreateInfo, pAllocator, pSampler)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdEndRenderPass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSubpassEndInfoKHR*        pSubpassEndInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdEndRenderPass2KHR(commandBuffer, pSubpassEndInfo)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroySamplerYcbcrConversionKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroySamplerYcbcrConversionKHR(device, ycbcrConversion, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageSubresourceLayout(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageSubresourceLayout(device, image, pSubresource, pLayout)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkBindBufferMemory2KHR(ApiDumpInstance& dump_inst, VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkBindBufferMemory2KHR(device, bindInfoCount, pBindInfos)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDeviceGroupPeerMemoryFeatures(ApiDumpInstance& dump_inst, VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDeviceGroupPeerMemoryFeatures(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkBindImageMemory2KHR(ApiDumpInstance& dump_inst, VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkBindImageMemory2KHR(device, bindInfoCount, pBindInfos)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateImageView(ApiDumpInstance& dump_inst, VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateImageView(device, pCreateInfo, pAllocator, pView)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetSwapchainStatusKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetSwapchainStatusKHR(device, swapchain)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkGetMemoryWin32HandlePropertiesKHR(ApiDumpInstance& dump_inst, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetMemoryWin32HandlePropertiesKHR(device, handleType, handle, pMemoryWin32HandleProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_head_vkGetAndroidHardwareBufferPropertiesANDROID(ApiDumpInstance& dump_inst, VkDevice device, const struct AHardwareBuffer* buffer, VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetAndroidHardwareBufferPropertiesANDROID(device, buffer, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_head_vkGetPhysicalDeviceExternalFencePropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_head_vkGetMemoryAndroidHardwareBufferANDROID(ApiDumpInstance& dump_inst, VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetMemoryAndroidHardwareBufferANDROID(device, pInfo, pBuffer)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkGetMemoryWin32HandleKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetMemoryWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkCreateDescriptorPool(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDescriptorPool(device, pCreateInfo, pAllocator, pDescriptorPool)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetDeviceMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetDeviceMask(commandBuffer, deviceMask)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDispatchBase(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDispatchBase(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkImportFenceWin32HandleKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkImportFenceWin32HandleKHR(device, pImportFenceWin32HandleInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkFreeDescriptorSets(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkFreeDescriptorSets(device, descriptorPool, descriptorSetCount, pDescriptorSets)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceExternalSemaphoreProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceExternalSemaphoreProperties(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetMemoryFdPropertiesKHR(ApiDumpInstance& dump_inst, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetMemoryFdPropertiesKHR(device, handleType, fd, pMemoryFdProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyDescriptorPool(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyDescriptorPool(device, descriptorPool, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetImageDrmFormatModifierPropertiesEXT(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetImageDrmFormatModifierPropertiesEXT(device, image, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateDescriptorSetLayout(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDescriptorSetLayout(device, pCreateInfo, pAllocator, pSetLayout)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkResetDescriptorPool(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkResetDescriptorPool(device, descriptorPool, flags)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkEnumeratePhysicalDeviceGroups(ApiDumpInstance& dump_inst, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkEnumeratePhysicalDeviceGroups(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetMemoryFdKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetMemoryFdKHR(device, pGetFdInfo, pFd)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkAllocateDescriptorSets(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkAllocateDescriptorSets(device, pAllocateInfo, pDescriptorSets)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroySampler(ApiDumpInstance& dump_inst, VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroySampler(device, sampler, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_head_vkGetFenceWin32HandleKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetFenceWin32HandleKHR(device, pGetWin32HandleInfo, pHandle)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_head_vkGetDescriptorSetLayoutSupport(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDescriptorSetLayoutSupport(device, pCreateInfo, pSupport)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroySurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroySurfaceKHR(instance, surface, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateSamplerYcbcrConversionKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateSamplerYcbcrConversionKHR(device, pCreateInfo, pAllocator, pYcbcrConversion)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyDescriptorSetLayout(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyDescriptorSetLayout(device, descriptorSetLayout, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyImageView(ApiDumpInstance& dump_inst, VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyImageView(device, imageView, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBindDescriptorSets(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBindDescriptorSets(commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkImportFenceFdKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkImportFenceFdKHR(device, pImportFenceFdInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkMergeValidationCachesEXT(ApiDumpInstance& dump_inst, VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkMergeValidationCachesEXT(device, dstCache, srcCacheCount, pSrcCaches)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateValidationCacheEXT(ApiDumpInstance& dump_inst, VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateValidationCacheEXT(device, pCreateInfo, pAllocator, pValidationCache)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetDepthBounds(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetDepthBounds(commandBuffer, minDepthBounds, maxDepthBounds)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetValidationCacheDataEXT(ApiDumpInstance& dump_inst, VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetValidationCacheDataEXT(device, validationCache, pDataSize, pData)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetStencilCompareMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetStencilCompareMask(commandBuffer, faceMask, compareMask)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkBeginCommandBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkBeginCommandBuffer(commandBuffer, pBeginInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyValidationCacheEXT(ApiDumpInstance& dump_inst, VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyValidationCacheEXT(device, validationCache, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateSwapchainKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateSwapchainKHR(device, pCreateInfo, pAllocator, pSwapchain)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetFenceFdKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetFenceFdKHR(device, pGetFdInfo, pFd)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateDescriptorUpdateTemplate(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDescriptorUpdateTemplate(device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkEndCommandBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkEndCommandBuffer(commandBuffer)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetQueryPoolResults(ApiDumpInstance& dump_inst, VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetQueryPoolResults(device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyQueryPool(ApiDumpInstance& dump_inst, VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyQueryPool(device, queryPool, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetStencilWriteMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetStencilWriteMask(commandBuffer, faceMask, writeMask)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateDevice(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetStencilReference(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetStencilReference(commandBuffer, faceMask, reference)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkUpdateDescriptorSetWithTemplate(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkUpdateDescriptorSetWithTemplate(device, descriptorSet, descriptorUpdateTemplate, pData)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateBuffer(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateBuffer(device, pCreateInfo, pAllocator, pBuffer)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBindIndexBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBindIndexBuffer(commandBuffer, buffer, offset, indexType)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceExternalBufferProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceExternalBufferProperties(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyDescriptorUpdateTemplate(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyDescriptorUpdateTemplate(device, descriptorUpdateTemplate, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyDevice(ApiDumpInstance& dump_inst, VkDevice device, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyDevice(device, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBindVertexBuffers(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBindVertexBuffers(commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetSwapchainImagesKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetSwapchainImagesKHR(device, swapchain, pSwapchainImageCount, pSwapchainImages)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkResetCommandBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkResetCommandBuffer(commandBuffer, flags)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetViewport(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetViewport(commandBuffer, firstViewport, viewportCount, pViewports)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdBindPipeline(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBindPipeline(commandBuffer, pipelineBindPoint, pipeline)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDraw(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDraw(commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawIndexed(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawIndexed(commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetLineWidth(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float lineWidth)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetLineWidth(commandBuffer, lineWidth)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceFeatures(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceFeatures(physicalDevice, pFeatures)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetScissor(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetScissor(commandBuffer, firstScissor, scissorCount, pScissors)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkEnumeratePhysicalDevices(ApiDumpInstance& dump_inst, VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetDepthBias(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetDepthBias(commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceImageFormatProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceImageFormatProperties(physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateDebugReportCallbackEXT(ApiDumpInstance& dump_inst, VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateDebugReportCallbackEXT(instance, pCreateInfo, pAllocator, pCallback)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawIndirect(commandBuffer, buffer, offset, drawCount, stride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceExternalFenceProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceExternalFenceProperties(physicalDevice, pExternalFenceInfo, pExternalFenceProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkEnumerateDeviceExtensionProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkEnumerateDeviceExtensionProperties(physicalDevice, pLayerName, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkEnumerateInstanceExtensionProperties(ApiDumpInstance& dump_inst, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkEnumerateInstanceExtensionProperties(pLayerName, pPropertyCount, pProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawIndexedIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawIndexedIndirect(commandBuffer, buffer, offset, drawCount, stride)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroySwapchainKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroySwapchainKHR(device, swapchain, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetBlendConstants(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const float blendConstants[4])
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetBlendConstants(commandBuffer, blendConstants)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkAcquireNextImageKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, pImageIndex)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetFenceStatus(ApiDumpInstance& dump_inst, VkDevice device, VkFence fence)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetFenceStatus(device, fence)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDevicePresentRectanglesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDevicePresentRectanglesKHR(physicalDevice, surface, pRectCount, pRects)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkRegisterObjectsNVX(ApiDumpInstance& dump_inst, VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectTableEntryNVX* const*    ppObjectTableEntries, const uint32_t* pObjectIndices)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkRegisterObjectsNVX(device, objectTable, objectCount, ppObjectTableEntries, pObjectIndices)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkWaitForFences(ApiDumpInstance& dump_inst, VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkWaitForFences(device, fenceCount, pFences, waitAll, timeout)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateObjectTableNVX(ApiDumpInstance& dump_inst, VkDevice device, const VkObjectTableCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkObjectTableNVX* pObjectTable)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateObjectTableNVX(device, pCreateInfo, pAllocator, pObjectTable)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDeviceGroupSurfacePresentModesKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDeviceGroupSurfacePresentModesKHR(device, surface, pModes)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateSemaphore(ApiDumpInstance& dump_inst, VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateSemaphore(device, pCreateInfo, pAllocator, pSemaphore)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_XCB_KHR)
std::ostream& dump_html_head_vkCreateXcbSurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateXcbSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_XCB_KHR
std::ostream& dump_html_head_vkCmdResetQueryPool(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdResetQueryPool(commandBuffer, queryPool, firstQuery, queryCount)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdUpdateBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdUpdateBuffer(commandBuffer, dstBuffer, dstOffset, dataSize, pData)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdEndQuery(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdEndQuery(commandBuffer, queryPool, query)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkUnregisterObjectsNVX(ApiDumpInstance& dump_inst, VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX* pObjectEntryTypes, const uint32_t* pObjectIndices)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkUnregisterObjectsNVX(device, objectTable, objectCount, pObjectEntryTypes, pObjectIndices)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateEvent(ApiDumpInstance& dump_inst, VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateEvent(device, pCreateInfo, pAllocator, pEvent)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDeviceQueue2(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDeviceQueue2(device, pQueueInfo, pQueue)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkAcquireNextImage2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkAcquireNextImage2KHR(device, pAcquireInfo, pImageIndex)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_VI_NN)
std::ostream& dump_html_head_vkCreateViSurfaceNN(ApiDumpInstance& dump_inst, VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateViSurfaceNN(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_VI_NN
std::ostream& dump_html_head_vkDestroyObjectTableNVX(ApiDumpInstance& dump_inst, VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyObjectTableNVX(device, objectTable, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdWriteTimestamp(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdWriteTimestamp(commandBuffer, pipelineStage, queryPool, query)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdFillBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdFillBuffer(commandBuffer, dstBuffer, dstOffset, size, data)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdClearColorImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdClearColorImage(commandBuffer, image, imageLayout, pColor, rangeCount, pRanges)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_XCB_KHR)
std::ostream& dump_html_head_vkGetPhysicalDeviceXcbPresentationSupportKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice, queueFamilyIndex, connection, visual_id)", "VkBool32");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_XCB_KHR
std::ostream& dump_html_head_vkCmdPushConstants(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdPushConstants(commandBuffer, layout, stageFlags, offset, size, pValues)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdCopyQueryPoolResults(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdCopyQueryPoolResults(commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceFeatures2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceFeatures2KHR(physicalDevice, pFeatures)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroySemaphore(ApiDumpInstance& dump_inst, VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroySemaphore(device, semaphore, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX* pFeatures, VkDeviceGeneratedCommandsLimitsNVX* pLimits)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice, pFeatures, pLimits)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdClearDepthStencilImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdClearDepthStencilImage(commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkSignalSemaphoreKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkSemaphoreSignalInfoKHR* pSignalInfo)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkSignalSemaphoreKHR(device, pSignalInfo)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceProperties2KHR(physicalDevice, pProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetEventStatus(ApiDumpInstance& dump_inst, VkDevice device, VkEvent event)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetEventStatus(device, event)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdNextSubpass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkSubpassContents contents)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdNextSubpass(commandBuffer, contents)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceMemoryProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice, pMemoryProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdSetViewportWScalingNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetViewportWScalingNV(commandBuffer, firstViewport, viewportCount, pViewportWScalings)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceFormatProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice, format, pFormatProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkSetEvent(ApiDumpInstance& dump_inst, VkDevice device, VkEvent event)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkSetEvent(device, event)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkReleaseDisplayEXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkDisplayKHR display)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkReleaseDisplayEXT(physicalDevice, display)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroyEvent(ApiDumpInstance& dump_inst, VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroyEvent(device, event, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceImageFormatProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice, pImageFormatInfo, pImageFormatProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdClearAttachments(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdClearAttachments(commandBuffer, attachmentCount, pAttachments, rectCount, pRects)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
std::ostream& dump_html_head_vkCreateWaylandSurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateWaylandSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
std::ostream& dump_html_head_vkCmdBeginRenderPass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdBeginRenderPass(commandBuffer, pRenderPassBegin, contents)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice, pFormatInfo, pPropertyCount, pProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetSemaphoreCounterValueKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSemaphore semaphore, uint64_t* pValue)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetSemaphoreCounterValueKHR(device, semaphore, pValue)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceQueueFamilyProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkResetEvent(ApiDumpInstance& dump_inst, VkDevice device, VkEvent event)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkResetEvent(device, event)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_head_vkCreateAndroidSurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateAndroidSurfaceKHR(instance, pCreateInfo, pAllocator, pSurface)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_head_vkWaitSemaphoresKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkSemaphoreWaitInfoKHR* pWaitInfo, uint64_t timeout)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkWaitSemaphoresKHR(device, pWaitInfo, timeout)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateQueryPool(ApiDumpInstance& dump_inst, VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateQueryPool(device, pCreateInfo, pAllocator, pQueryPool)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetDeviceGroupPeerMemoryFeaturesKHR(ApiDumpInstance& dump_inst, VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetDeviceGroupPeerMemoryFeaturesKHR(device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
std::ostream& dump_html_head_vkGetPhysicalDeviceWaylandPresentationSupportKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice, queueFamilyIndex, display)", "VkBool32");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
std::ostream& dump_html_head_vkCmdSetDeviceMaskKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t deviceMask)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdSetDeviceMaskKHR(commandBuffer, deviceMask)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
std::ostream& dump_html_head_vkGetRandROutputDisplayEXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetRandROutputDisplayEXT(physicalDevice, dpy, rrOutput, pDisplay)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
std::ostream& dump_html_head_vkTrimCommandPoolKHR(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkTrimCommandPoolKHR(device, commandPool, flags)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDrawMeshTasksNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDrawMeshTasksNV(commandBuffer, taskCount, firstTask)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCreateSamplerYcbcrConversion(ApiDumpInstance& dump_inst, VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCreateSamplerYcbcrConversion(device, pCreateInfo, pAllocator, pYcbcrConversion)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdEndRenderPass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdEndRenderPass(commandBuffer)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
std::ostream& dump_html_head_vkAcquireXlibDisplayEXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkAcquireXlibDisplayEXT(physicalDevice, dpy, display)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
std::ostream& dump_html_head_vkCmdExecuteCommands(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdExecuteCommands(commandBuffer, commandBufferCount, pCommandBuffers)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkEnumeratePhysicalDeviceGroupsKHR(ApiDumpInstance& dump_inst, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkEnumeratePhysicalDeviceGroupsKHR(instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)", "VkResult");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdResolveImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdResolveImage(commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkCmdDispatchBaseKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkCmdDispatchBaseKHR(commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkGetPhysicalDeviceExternalBufferPropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice, pExternalBufferInfo, pExternalBufferProperties)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}
std::ostream& dump_html_head_vkDestroySamplerYcbcrConversion(ApiDumpInstance& dump_inst, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator)
{
    const ApiDumpSettings& settings(dump_inst.settings());

    settings.stream() << "<div class='thd'>Thread " << dump_inst.threadID() << ":</div>";
    if(settings.showTimestamp())
        settings.stream() << "<div class='time'>Time: " << dump_inst.current_time_since_start().count() << " us</div>";
    settings.stream() << "<details class='fn'><summary>";
    dump_html_nametype(settings.stream(), settings.showType(), "vkDestroySamplerYcbcrConversion(device, ycbcrConversion, pAllocator)", "void");

    return settings.shouldFlush() ? settings.stream() << std::flush : settings.stream();
}


std::ostream& dump_html_body_vkGetBufferDeviceAddressEXT(ApiDumpInstance& dump_inst, VkDeviceAddress result, VkDevice device, const VkBufferDeviceAddressInfoEXT* pInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkDeviceAddress(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferDeviceAddressInfoEXT>(pInfo, settings, "const VkBufferDeviceAddressInfoEXT*", "pInfo", 1, dump_html_VkBufferDeviceAddressInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDebugReportMessageEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char* pLayerPrefix, const char* pMessage)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkDebugReportFlagsEXT>(flags, settings, "VkDebugReportFlagsEXT", "flags", 1, dump_html_VkDebugReportFlagsEXT);
        dump_html_value<const VkDebugReportObjectTypeEXT>(objectType, settings, "VkDebugReportObjectTypeEXT", "objectType", 1, dump_html_VkDebugReportObjectTypeEXT);
        dump_html_value<const uint64_t>(object, settings, "uint64_t", "object", 1, dump_html_uint64_t);
        dump_html_value<const size_t>(location, settings, "size_t", "location", 1, dump_html_size_t);
        dump_html_value<const int32_t>(messageCode, settings, "int32_t", "messageCode", 1, dump_html_int32_t);
        dump_html_value<const char*>(pLayerPrefix, settings, "const char*", "pLayerPrefix", 1, dump_html_cstring);
        dump_html_value<const char*>(pMessage, settings, "const char*", "pMessage", 1, dump_html_cstring);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkQueuePresentKHR(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue, const VkPresentInfoKHR* pPresentInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const VkPresentInfoKHR>(pPresentInfo, settings, "const VkPresentInfoKHR*", "pPresentInfo", 1, dump_html_VkPresentInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDebugMarkerSetObjectTagEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDebugMarkerObjectTagInfoEXT* pTagInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDebugMarkerObjectTagInfoEXT>(pTagInfo, settings, "const VkDebugMarkerObjectTagInfoEXT*", "pTagInfo", 1, dump_html_VkDebugMarkerObjectTagInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPastPresentationTimingGOOGLE(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, uint32_t* pPresentationTimingCount, VkPastPresentationTimingGOOGLE* pPresentationTimings)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const uint32_t>(pPresentationTimingCount, settings, "uint32_t*", "pPresentationTimingCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPastPresentationTimingGOOGLE>(pPresentationTimings, *pPresentationTimingCount, settings, "VkPastPresentationTimingGOOGLE*", "VkPastPresentationTimingGOOGLE", "pPresentationTimings", 1, dump_html_VkPastPresentationTimingGOOGLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageSparseMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements* pSparseMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const uint32_t>(pSparseMemoryRequirementCount, settings, "uint32_t*", "pSparseMemoryRequirementCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageMemoryRequirements>(pSparseMemoryRequirements, *pSparseMemoryRequirementCount, settings, "VkSparseImageMemoryRequirements*", "VkSparseImageMemoryRequirements", "pSparseMemoryRequirements", 1, dump_html_VkSparseImageMemoryRequirements);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkQueueWaitIdle(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkEnumerateInstanceLayerProperties(ApiDumpInstance& dump_inst, VkResult result, uint32_t* pPropertyCount, VkLayerProperties* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkLayerProperties>(pProperties, *pPropertyCount, settings, "VkLayerProperties*", "VkLayerProperties", "pProperties", 1, dump_html_VkLayerProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBindTransformFeedbackBuffersEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets, const VkDeviceSize* pSizes)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstBinding, settings, "uint32_t", "firstBinding", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(bindingCount, settings, "uint32_t", "bindingCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pBuffers, bindingCount, settings, "const VkBuffer*", "const VkBuffer", "pBuffers", 1, dump_html_VkBuffer);
        dump_html_array<const VkDeviceSize>(pOffsets, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pOffsets", 1, dump_html_VkDeviceSize);
        dump_html_array<const VkDeviceSize>(pSizes, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pSizes", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetBufferMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkBuffer buffer, VkMemoryRequirements* pMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_pointer<const VkMemoryRequirements>(pMemoryRequirements, settings, "VkMemoryRequirements*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyDebugReportCallbackEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkDebugReportCallbackEXT>(callback, settings, "VkDebugReportCallbackEXT", "callback", 1, dump_html_VkDebugReportCallbackEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDebugMarkerSetObjectNameEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDebugMarkerObjectNameInfoEXT* pNameInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDebugMarkerObjectNameInfoEXT>(pNameInfo, settings, "const VkDebugMarkerObjectNameInfoEXT*", "pNameInfo", 1, dump_html_VkDebugMarkerObjectNameInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDeviceQueue(ApiDumpInstance& dump_inst, VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue* pQueue)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queueIndex, settings, "uint32_t", "queueIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const VkQueue>(pQueue, settings, "VkQueue*", "pQueue", 1, dump_html_VkQueue);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDeviceWaitIdle(ApiDumpInstance& dump_inst, VkResult result, VkDevice device)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDebugMarkerBeginEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDebugMarkerMarkerInfoEXT>(pMarkerInfo, settings, "const VkDebugMarkerMarkerInfoEXT*", "pMarkerInfo", 1, dump_html_VkDebugMarkerMarkerInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageMemoryRequirements(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, VkMemoryRequirements* pMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkMemoryRequirements>(pMemoryRequirements, settings, "VkMemoryRequirements*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDebugMarkerEndEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetRefreshCycleDurationGOOGLE(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE* pDisplayTimingProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const VkRefreshCycleDurationGOOGLE>(pDisplayTimingProperties, settings, "VkRefreshCycleDurationGOOGLE*", "pDisplayTimingProperties", 1, dump_html_VkRefreshCycleDurationGOOGLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkAllocateMemory(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo, const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryAllocateInfo>(pAllocateInfo, settings, "const VkMemoryAllocateInfo*", "pAllocateInfo", 1, dump_html_VkMemoryAllocateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDeviceMemory>(pMemory, settings, "VkDeviceMemory*", "pMemory", 1, dump_html_VkDeviceMemory);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDebugMarkerInsertEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT* pMarkerInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDebugMarkerMarkerInfoEXT>(pMarkerInfo, settings, "const VkDebugMarkerMarkerInfoEXT*", "pMarkerInfo", 1, dump_html_VkDebugMarkerMarkerInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkEnumerateDeviceLayerProperties(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkLayerProperties* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkLayerProperties>(pProperties, *pPropertyCount, settings, "VkLayerProperties*", "VkLayerProperties", "pProperties", 1, dump_html_VkLayerProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetCalibratedTimestampsEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoEXT* pTimestampInfos, uint64_t* pTimestamps, uint64_t* pMaxDeviation)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(timestampCount, settings, "uint32_t", "timestampCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCalibratedTimestampInfoEXT>(pTimestampInfos, timestampCount, settings, "const VkCalibratedTimestampInfoEXT*", "const VkCalibratedTimestampInfoEXT", "pTimestampInfos", 1, dump_html_VkCalibratedTimestampInfoEXT);
        dump_html_array<const uint64_t>(pTimestamps, timestampCount, settings, "uint64_t*", "uint64_t", "pTimestamps", 1, dump_html_uint64_t);
        dump_html_pointer<const uint64_t>(pMaxDeviation, settings, "uint64_t*", "pMaxDeviation", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkQueueSubmit(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits, VkFence fence)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_value<const uint32_t>(submitCount, settings, "uint32_t", "submitCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSubmitInfo>(pSubmits, submitCount, settings, "const VkSubmitInfo*", "const VkSubmitInfo", "pSubmits", 1, dump_html_VkSubmitInfo);
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkUnmapMemory(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceProperties>(pProperties, settings, "VkPhysicalDeviceProperties*", "pProperties", 1, dump_html_VkPhysicalDeviceProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkMapMemory(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void** ppData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(size, settings, "VkDeviceSize", "size", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkMemoryMapFlags>(flags, settings, "VkMemoryMapFlags", "flags", 1, dump_html_VkMemoryMapFlags);
        dump_html_pointer<const void*>(ppData, settings, "void**", "ppData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBeginTransformFeedbackEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstCounterBuffer, settings, "uint32_t", "firstCounterBuffer", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(counterBufferCount, settings, "uint32_t", "counterBufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pCounterBuffers, counterBufferCount, settings, "const VkBuffer*", "const VkBuffer", "pCounterBuffers", 1, dump_html_VkBuffer);
        dump_html_array<const VkDeviceSize>(pCounterBufferOffsets, counterBufferCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pCounterBufferOffsets", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkFreeMemory(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceMemoryProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceMemoryProperties>(pMemoryProperties, settings, "VkPhysicalDeviceMemoryProperties*", "pMemoryProperties", 1, dump_html_VkPhysicalDeviceMemoryProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pTimeDomainCount, VkTimeDomainEXT* pTimeDomains)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pTimeDomainCount, settings, "uint32_t*", "pTimeDomainCount", 1, dump_html_uint32_t);
        dump_html_array<const VkTimeDomainEXT>(pTimeDomains, *pTimeDomainCount, settings, "VkTimeDomainEXT*", "VkTimeDomainEXT", "pTimeDomains", 1, dump_html_VkTimeDomainEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdEndTransformFeedbackEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer* pCounterBuffers, const VkDeviceSize* pCounterBufferOffsets)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstCounterBuffer, settings, "uint32_t", "firstCounterBuffer", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(counterBufferCount, settings, "uint32_t", "counterBufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pCounterBuffers, counterBufferCount, settings, "const VkBuffer*", "const VkBuffer", "pCounterBuffers", 1, dump_html_VkBuffer);
        dump_html_array<const VkDeviceSize>(pCounterBufferOffsets, counterBufferCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pCounterBufferOffsets", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSurfaceFormats2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pSurfaceFormatCount, VkSurfaceFormat2KHR* pSurfaceFormats)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSurfaceInfo2KHR>(pSurfaceInfo, settings, "const VkPhysicalDeviceSurfaceInfo2KHR*", "pSurfaceInfo", 1, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        dump_html_pointer<const uint32_t>(pSurfaceFormatCount, settings, "uint32_t*", "pSurfaceFormatCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSurfaceFormat2KHR>(pSurfaceFormats, *pSurfaceFormatCount, settings, "VkSurfaceFormat2KHR*", "VkSurfaceFormat2KHR", "pSurfaceFormats", 1, dump_html_VkSurfaceFormat2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pCombinationCount, VkFramebufferMixedSamplesCombinationNV* pCombinations)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pCombinationCount, settings, "uint32_t*", "pCombinationCount", 1, dump_html_uint32_t);
        dump_html_array<const VkFramebufferMixedSamplesCombinationNV>(pCombinations, *pCombinationCount, settings, "VkFramebufferMixedSamplesCombinationNV*", "VkFramebufferMixedSamplesCombinationNV", "pCombinations", 1, dump_html_VkFramebufferMixedSamplesCombinationNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkBindBufferMemory(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const VkDeviceSize>(memoryOffset, settings, "VkDeviceSize", "memoryOffset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSparseImageFormatProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_value<const VkImageType>(type, settings, "VkImageType", "type", 1, dump_html_VkImageType);
        dump_html_value<const VkSampleCountFlagBits>(samples, settings, "VkSampleCountFlagBits", "samples", 1, dump_html_VkSampleCountFlagBits);
        dump_html_value<const VkImageUsageFlags>(usage, settings, "VkImageUsageFlags", "usage", 1, dump_html_VkImageUsageFlags);
        dump_html_value<const VkImageTiling>(tiling, settings, "VkImageTiling", "tiling", 1, dump_html_VkImageTiling);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageFormatProperties>(pProperties, *pPropertyCount, settings, "VkSparseImageFormatProperties*", "VkSparseImageFormatProperties", "pProperties", 1, dump_html_VkSparseImageFormatProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBeginQueryIndexedEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
        dump_html_value<const VkQueryControlFlags>(flags, settings, "VkQueryControlFlags", "flags", 1, dump_html_VkQueryControlFlags);
        dump_html_value<const uint32_t>(index, settings, "uint32_t", "index", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSurfaceCapabilities2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkSurfaceCapabilities2KHR* pSurfaceCapabilities)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSurfaceInfo2KHR>(pSurfaceInfo, settings, "const VkPhysicalDeviceSurfaceInfo2KHR*", "pSurfaceInfo", 1, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        dump_html_pointer<const VkSurfaceCapabilities2KHR>(pSurfaceCapabilities, settings, "VkSurfaceCapabilities2KHR*", "pSurfaceCapabilities", 1, dump_html_VkSurfaceCapabilities2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkFlushMappedMemoryRanges(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(memoryRangeCount, settings, "uint32_t", "memoryRangeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMappedMemoryRange>(pMemoryRanges, memoryRangeCount, settings, "const VkMappedMemoryRange*", "const VkMappedMemoryRange", "pMemoryRanges", 1, dump_html_VkMappedMemoryRange);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdEndQueryIndexedEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(index, settings, "uint32_t", "index", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceQueueFamilyProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties* pQueueFamilyProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pQueueFamilyPropertyCount, settings, "uint32_t*", "pQueueFamilyPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkQueueFamilyProperties>(pQueueFamilyProperties, *pQueueFamilyPropertyCount, settings, "VkQueueFamilyProperties*", "VkQueueFamilyProperties", "pQueueFamilyProperties", 1, dump_html_VkQueueFamilyProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawIndirectByteCountEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(instanceCount, settings, "uint32_t", "instanceCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstInstance, settings, "uint32_t", "firstInstance", 1, dump_html_uint32_t);
        dump_html_value<const VkBuffer>(counterBuffer, settings, "VkBuffer", "counterBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(counterBufferOffset, settings, "VkDeviceSize", "counterBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(counterOffset, settings, "uint32_t", "counterOffset", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(vertexStride, settings, "uint32_t", "vertexStride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkInitializePerformanceApiINTEL(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkInitializePerformanceApiInfoINTEL* pInitializeInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkInitializePerformanceApiInfoINTEL>(pInitializeInfo, settings, "const VkInitializePerformanceApiInfoINTEL*", "pInitializeInfo", 1, dump_html_VkInitializePerformanceApiInfoINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkUninitializePerformanceApiINTEL(ApiDumpInstance& dump_inst, VkDevice device)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkQueueBindSparse(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo, VkFence fence)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindSparseInfo>(pBindInfo, bindInfoCount, settings, "const VkBindSparseInfo*", "const VkBindSparseInfo", "pBindInfo", 1, dump_html_VkBindSparseInfo);
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetMemoryHostPointerPropertiesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void* pHostPointer, VkMemoryHostPointerPropertiesEXT* pMemoryHostPointerProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
        dump_html_value<const void*>(pHostPointer, settings, "const void*", "pHostPointer", 1, dump_html_void);
        dump_html_pointer<const VkMemoryHostPointerPropertiesEXT>(pMemoryHostPointerProperties, settings, "VkMemoryHostPointerPropertiesEXT*", "pMemoryHostPointerProperties", 1, dump_html_VkMemoryHostPointerPropertiesEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetPerformanceMarkerINTEL(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL* pMarkerInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPerformanceMarkerInfoINTEL>(pMarkerInfo, settings, "const VkPerformanceMarkerInfoINTEL*", "pMarkerInfo", 1, dump_html_VkPerformanceMarkerInfoINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkInvalidateMappedMemoryRanges(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange* pMemoryRanges)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(memoryRangeCount, settings, "uint32_t", "memoryRangeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMappedMemoryRange>(pMemoryRanges, memoryRangeCount, settings, "const VkMappedMemoryRange*", "const VkMappedMemoryRange", "pMemoryRanges", 1, dump_html_VkMappedMemoryRange);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetPerformanceStreamMarkerINTEL(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL* pMarkerInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPerformanceStreamMarkerInfoINTEL>(pMarkerInfo, settings, "const VkPerformanceStreamMarkerInfoINTEL*", "pMarkerInfo", 1, dump_html_VkPerformanceStreamMarkerInfoINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdWriteBufferMarkerAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlagBits>(pipelineStage, settings, "VkPipelineStageFlagBits", "pipelineStage", 1, dump_html_VkPipelineStageFlagBits);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(marker, settings, "uint32_t", "marker", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDeviceMemoryCommitment(ApiDumpInstance& dump_inst, VkDevice device, VkDeviceMemory memory, VkDeviceSize* pCommittedMemoryInBytes)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_pointer<const VkDeviceSize>(pCommittedMemoryInBytes, settings, "VkDeviceSize*", "pCommittedMemoryInBytes", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetPerformanceOverrideINTEL(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL* pOverrideInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkPerformanceOverrideInfoINTEL>(pOverrideInfo, settings, "const VkPerformanceOverrideInfoINTEL*", "pOverrideInfo", 1, dump_html_VkPerformanceOverrideInfoINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkReleasePerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPerformanceConfigurationINTEL configuration)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPerformanceConfigurationINTEL>(configuration, settings, "VkPerformanceConfigurationINTEL", "configuration", 1, dump_html_VkPerformanceConfigurationINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDeviceGroupPresentCapabilitiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeviceGroupPresentCapabilitiesKHR* pDeviceGroupPresentCapabilities)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceGroupPresentCapabilitiesKHR>(pDeviceGroupPresentCapabilities, settings, "VkDeviceGroupPresentCapabilitiesKHR*", "pDeviceGroupPresentCapabilities", 1, dump_html_VkDeviceGroupPresentCapabilitiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkBindImageMemory(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const VkDeviceSize>(memoryOffset, settings, "VkDeviceSize", "memoryOffset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkCooperativeMatrixPropertiesNV* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCooperativeMatrixPropertiesNV>(pProperties, *pPropertyCount, settings, "VkCooperativeMatrixPropertiesNV*", "VkCooperativeMatrixPropertiesNV", "pProperties", 1, dump_html_VkCooperativeMatrixPropertiesNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkAcquirePerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL* pAcquireInfo, VkPerformanceConfigurationINTEL* pConfiguration)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPerformanceConfigurationAcquireInfoINTEL>(pAcquireInfo, settings, "const VkPerformanceConfigurationAcquireInfoINTEL*", "pAcquireInfo", 1, dump_html_VkPerformanceConfigurationAcquireInfoINTEL);
        dump_html_pointer<const VkPerformanceConfigurationINTEL>(pConfiguration, settings, "VkPerformanceConfigurationINTEL*", "pConfiguration", 1, dump_html_VkPerformanceConfigurationINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkGetPhysicalDeviceSurfacePresentModes2EXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSurfaceInfo2KHR>(pSurfaceInfo, settings, "const VkPhysicalDeviceSurfaceInfo2KHR*", "pSurfaceInfo", 1, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        dump_html_pointer<const uint32_t>(pPresentModeCount, settings, "uint32_t*", "pPresentModeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPresentModeKHR>(pPresentModes, *pPresentModeCount, settings, "VkPresentModeKHR*", "VkPresentModeKHR", "pPresentModes", 1, dump_html_VkPresentModeKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkUpdateDescriptorSets(ApiDumpInstance& dump_inst, VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet* pDescriptorCopies)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(descriptorWriteCount, settings, "uint32_t", "descriptorWriteCount", 1, dump_html_uint32_t);
        dump_html_array<const VkWriteDescriptorSet>(pDescriptorWrites, descriptorWriteCount, settings, "const VkWriteDescriptorSet*", "const VkWriteDescriptorSet", "pDescriptorWrites", 1, dump_html_VkWriteDescriptorSet);
        dump_html_value<const uint32_t>(descriptorCopyCount, settings, "uint32_t", "descriptorCopyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCopyDescriptorSet>(pDescriptorCopies, descriptorCopyCount, settings, "const VkCopyDescriptorSet*", "const VkCopyDescriptorSet", "pDescriptorCopies", 1, dump_html_VkCopyDescriptorSet);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdPushDescriptorSetKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet* pDescriptorWrites)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const uint32_t>(set, settings, "uint32_t", "set", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(descriptorWriteCount, settings, "uint32_t", "descriptorWriteCount", 1, dump_html_uint32_t);
        dump_html_array<const VkWriteDescriptorSet>(pDescriptorWrites, descriptorWriteCount, settings, "const VkWriteDescriptorSet*", "const VkWriteDescriptorSet", "pDescriptorWrites", 1, dump_html_VkWriteDescriptorSet);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkQueueSetPerformanceConfigurationINTEL(ApiDumpInstance& dump_inst, VkResult result, VkQueue queue, VkPerformanceConfigurationINTEL configuration)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_value<const VkPerformanceConfigurationINTEL>(configuration, settings, "VkPerformanceConfigurationINTEL", "configuration", 1, dump_html_VkPerformanceConfigurationINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDisplayPlaneSupportedDisplaysKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t* pDisplayCount, VkDisplayKHR* pDisplays)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(planeIndex, settings, "uint32_t", "planeIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const uint32_t>(pDisplayCount, settings, "uint32_t*", "pDisplayCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayKHR>(pDisplays, *pDisplayCount, settings, "VkDisplayKHR*", "VkDisplayKHR", "pDisplays", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawMeshTasksIndirectCountNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawMeshTasksIndirectNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkCreateWin32SurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkWin32SurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkWin32SurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkWin32SurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkWin32SurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkGetPerformanceParameterINTEL(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL* pValue)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPerformanceParameterTypeINTEL>(parameter, settings, "VkPerformanceParameterTypeINTEL", "parameter", 1, dump_html_VkPerformanceParameterTypeINTEL);
        dump_html_pointer<const VkPerformanceValueINTEL>(pValue, settings, "VkPerformanceValueINTEL*", "pValue", 1, dump_html_VkPerformanceValueINTEL);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetRayTracingShaderGroupHandlesNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void* pData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const uint32_t>(firstGroup, settings, "uint32_t", "firstGroup", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCount, settings, "uint32_t", "groupCount", 1, dump_html_uint32_t);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkGetPhysicalDeviceWin32PresentationSupportKHR(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkGetAccelerationStructureHandleNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void* pData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkAccelerationStructureNV>(accelerationStructure, settings, "VkAccelerationStructureNV", "accelerationStructure", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdPushDescriptorSetWithTemplateKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void* pData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const uint32_t>(set, settings, "uint32_t", "set", 1, dump_html_uint32_t);
        dump_html_value<const void*>(pData, settings, "const void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceDisplayPropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPropertiesKHR* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayPropertiesKHR>(pProperties, *pPropertyCount, settings, "VkDisplayPropertiesKHR*", "VkDisplayPropertiesKHR", "pProperties", 1, dump_html_VkDisplayPropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdWriteAccelerationStructuresPropertiesNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV* pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(accelerationStructureCount, settings, "uint32_t", "accelerationStructureCount", 1, dump_html_uint32_t);
        dump_html_array<const VkAccelerationStructureNV>(pAccelerationStructures, accelerationStructureCount, settings, "const VkAccelerationStructureNV*", "const VkAccelerationStructureNV", "pAccelerationStructures", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkQueryType>(queryType, settings, "VkQueryType", "queryType", 1, dump_html_VkQueryType);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlanePropertiesKHR* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayPlanePropertiesKHR>(pProperties, *pPropertyCount, settings, "VkDisplayPlanePropertiesKHR*", "VkDisplayPlanePropertiesKHR", "pProperties", 1, dump_html_VkDisplayPlanePropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSurfaceCapabilities2EXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT* pSurfaceCapabilities)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkSurfaceCapabilities2EXT>(pSurfaceCapabilities, settings, "VkSurfaceCapabilities2EXT*", "pSurfaceCapabilities", 1, dump_html_VkSurfaceCapabilities2EXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDisplayModePropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModePropertiesKHR* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayModePropertiesKHR>(pProperties, *pPropertyCount, settings, "VkDisplayModePropertiesKHR*", "VkDisplayModePropertiesKHR", "pProperties", 1, dump_html_VkDisplayModePropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateDisplayModeKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDisplayModeKHR* pMode)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const VkDisplayModeCreateInfoKHR>(pCreateInfo, settings, "const VkDisplayModeCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkDisplayModeCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDisplayModeKHR>(pMode, settings, "VkDisplayModeKHR*", "pMode", 1, dump_html_VkDisplayModeKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateFramebuffer(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkFramebufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFramebuffer* pFramebuffer)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkFramebufferCreateInfo>(pCreateInfo, settings, "const VkFramebufferCreateInfo*", "pCreateInfo", 1, dump_html_VkFramebufferCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkFramebuffer>(pFramebuffer, settings, "VkFramebuffer*", "pFramebuffer", 1, dump_html_VkFramebuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageSparseMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageSparseMemoryRequirementsInfo2>(pInfo, settings, "const VkImageSparseMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkImageSparseMemoryRequirementsInfo2);
        dump_html_pointer<const uint32_t>(pSparseMemoryRequirementCount, settings, "uint32_t*", "pSparseMemoryRequirementCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageMemoryRequirements2>(pSparseMemoryRequirements, *pSparseMemoryRequirementCount, settings, "VkSparseImageMemoryRequirements2*", "VkSparseImageMemoryRequirements2", "pSparseMemoryRequirements", 1, dump_html_VkSparseImageMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetDiscardRectangleEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D* pDiscardRectangles)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstDiscardRectangle, settings, "uint32_t", "firstDiscardRectangle", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(discardRectangleCount, settings, "uint32_t", "discardRectangleCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pDiscardRectangles, discardRectangleCount, settings, "const VkRect2D*", "const VkRect2D", "pDiscardRectangles", 1, dump_html_VkRect2D);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDisplayPlaneCapabilitiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR* pCapabilities)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayModeKHR>(mode, settings, "VkDisplayModeKHR", "mode", 1, dump_html_VkDisplayModeKHR);
        dump_html_value<const uint32_t>(planeIndex, settings, "uint32_t", "planeIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const VkDisplayPlaneCapabilitiesKHR>(pCapabilities, settings, "VkDisplayPlaneCapabilitiesKHR*", "pCapabilities", 1, dump_html_VkDisplayPlaneCapabilitiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageMemoryRequirementsInfo2>(pInfo, settings, "const VkImageMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkImageMemoryRequirementsInfo2);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetExclusiveScissorNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D* pExclusiveScissors)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstExclusiveScissor, settings, "uint32_t", "firstExclusiveScissor", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(exclusiveScissorCount, settings, "uint32_t", "exclusiveScissorCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pExclusiveScissors, exclusiveScissorCount, settings, "const VkRect2D*", "const VkRect2D", "pExclusiveScissors", 1, dump_html_VkRect2D);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateDisplayPlaneSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkDisplaySurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkDisplaySurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkDisplaySurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkDisplaySurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetBufferMemoryRequirements2(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferMemoryRequirementsInfo2>(pInfo, settings, "const VkBufferMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkBufferMemoryRequirementsInfo2);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkSetLocalDimmingAMD(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapChain, settings, "VkSwapchainKHR", "swapChain", 1, dump_html_VkSwapchainKHR);
        dump_html_value<const VkBool32>(localDimmingEnable, settings, "VkBool32", "localDimmingEnable", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCompileDeferredNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipeline pipeline, uint32_t shader)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const uint32_t>(shader, settings, "uint32_t", "shader", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_FUCHSIA)
std::ostream& dump_html_body_vkCreateImagePipeSurfaceFUCHSIA(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkImagePipeSurfaceCreateInfoFUCHSIA>(pCreateInfo, settings, "const VkImagePipeSurfaceCreateInfoFUCHSIA*", "pCreateInfo", 1, dump_html_VkImagePipeSurfaceCreateInfoFUCHSIA);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_FUCHSIA
std::ostream& dump_html_body_vkCmdBeginConditionalRenderingEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT* pConditionalRenderingBegin)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkConditionalRenderingBeginInfoEXT>(pConditionalRenderingBegin, settings, "const VkConditionalRenderingBeginInfoEXT*", "pConditionalRenderingBegin", 1, dump_html_VkConditionalRenderingBeginInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetCheckpointNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const void* pCheckpointMarker)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const void*>(pCheckpointMarker, settings, "const void*", "pCheckpointMarker", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageViewHandleNVX(ApiDumpInstance& dump_inst, uint32_t result, VkDevice device, const VkImageViewHandleInfoNVX* pInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_uint32_t(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageViewHandleInfoNVX>(pInfo, settings, "const VkImageViewHandleInfoNVX*", "pInfo", 1, dump_html_VkImageViewHandleInfoNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkRegisterDeviceEventEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDeviceEventInfoEXT* pDeviceEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceEventInfoEXT>(pDeviceEventInfo, settings, "const VkDeviceEventInfoEXT*", "pDeviceEventInfo", 1, dump_html_VkDeviceEventInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkFence>(pFence, settings, "VkFence*", "pFence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetSampleLocationsEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT* pSampleLocationsInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSampleLocationsInfoEXT>(pSampleLocationsInfo, settings, "const VkSampleLocationsInfoEXT*", "pSampleLocationsInfo", 1, dump_html_VkSampleLocationsInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdEndConditionalRenderingEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawIndirectCountKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDisplayPowerControlEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT* pDisplayPowerInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const VkDisplayPowerInfoEXT>(pDisplayPowerInfo, settings, "const VkDisplayPowerInfoEXT*", "pDisplayPowerInfo", 1, dump_html_VkDisplayPowerInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageSparseMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImageSparseMemoryRequirementsInfo2* pInfo, uint32_t* pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2* pSparseMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageSparseMemoryRequirementsInfo2>(pInfo, settings, "const VkImageSparseMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkImageSparseMemoryRequirementsInfo2);
        dump_html_pointer<const uint32_t>(pSparseMemoryRequirementCount, settings, "uint32_t*", "pSparseMemoryRequirementCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageMemoryRequirements2>(pSparseMemoryRequirements, *pSparseMemoryRequirementCount, settings, "VkSparseImageMemoryRequirements2*", "VkSparseImageMemoryRequirements2", "pSparseMemoryRequirements", 1, dump_html_VkSparseImageMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateDescriptorUpdateTemplateKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorUpdateTemplateCreateInfo>(pCreateInfo, settings, "const VkDescriptorUpdateTemplateCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorUpdateTemplateCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDescriptorUpdateTemplate>(pDescriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate*", "pDescriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDescriptorSetLayoutSupportKHR(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetLayoutCreateInfo>(pCreateInfo, settings, "const VkDescriptorSetLayoutCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorSetLayoutCreateInfo);
        dump_html_pointer<const VkDescriptorSetLayoutSupport>(pSupport, settings, "VkDescriptorSetLayoutSupport*", "pSupport", 1, dump_html_VkDescriptorSetLayoutSupport);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkRegisterDisplayEventEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT* pDisplayEventInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const VkDisplayEventInfoEXT>(pDisplayEventInfo, settings, "const VkDisplayEventInfoEXT*", "pDisplayEventInfo", 1, dump_html_VkDisplayEventInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkFence>(pFence, settings, "VkFence*", "pFence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_METAL_EXT)
std::ostream& dump_html_body_vkCreateMetalSurfaceEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkMetalSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkMetalSurfaceCreateInfoEXT>(pCreateInfo, settings, "const VkMetalSurfaceCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkMetalSurfaceCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_METAL_EXT
std::ostream& dump_html_body_vkCmdDrawIndirectCountAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetSwapchainCounterEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t* pCounterValue)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_value<const VkSurfaceCounterFlagBitsEXT>(counter, settings, "VkSurfaceCounterFlagBitsEXT", "counter", 1, dump_html_VkSurfaceCounterFlagBitsEXT);
        dump_html_pointer<const uint64_t>(pCounterValue, settings, "uint64_t*", "pCounterValue", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateRenderPass(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkRenderPassCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkRenderPassCreateInfo>(pCreateInfo, settings, "const VkRenderPassCreateInfo*", "pCreateInfo", 1, dump_html_VkRenderPassCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkRenderPass>(pRenderPass, settings, "VkRenderPass*", "pRenderPass", 1, dump_html_VkRenderPass);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceMultisamplePropertiesEXT(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT* pMultisampleProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSampleCountFlagBits>(samples, settings, "VkSampleCountFlagBits", "samples", 1, dump_html_VkSampleCountFlagBits);
        dump_html_pointer<const VkMultisamplePropertiesEXT>(pMultisampleProperties, settings, "VkMultisamplePropertiesEXT*", "pMultisampleProperties", 1, dump_html_VkMultisamplePropertiesEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawIndexedIndirectCountAMD(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawIndexedIndirectCountKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(countBuffer, settings, "VkBuffer", "countBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(countBufferOffset, settings, "VkDeviceSize", "countBufferOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(maxDrawCount, settings, "uint32_t", "maxDrawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyFramebuffer(ApiDumpInstance& dump_inst, VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkFramebuffer>(framebuffer, settings, "VkFramebuffer", "framebuffer", 1, dump_html_VkFramebuffer);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkImageMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageMemoryRequirementsInfo2>(pInfo, settings, "const VkImageMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkImageMemoryRequirementsInfo2);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetBufferMemoryRequirements2KHR(ApiDumpInstance& dump_inst, VkDevice device, const VkBufferMemoryRequirementsInfo2* pInfo, VkMemoryRequirements2* pMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferMemoryRequirementsInfo2>(pInfo, settings, "const VkBufferMemoryRequirementsInfo2*", "pInfo", 1, dump_html_VkBufferMemoryRequirementsInfo2);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetQueueCheckpointDataNV(ApiDumpInstance& dump_inst, VkQueue queue, uint32_t* pCheckpointDataCount, VkCheckpointDataNV* pCheckpointData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const uint32_t>(pCheckpointDataCount, settings, "uint32_t*", "pCheckpointDataCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCheckpointDataNV>(pCheckpointData, *pCheckpointDataCount, settings, "VkCheckpointDataNV*", "VkCheckpointDataNV", "pCheckpointData", 1, dump_html_VkCheckpointDataNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdWaitEvents(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent* pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(eventCount, settings, "uint32_t", "eventCount", 1, dump_html_uint32_t);
        dump_html_array<const VkEvent>(pEvents, eventCount, settings, "const VkEvent*", "const VkEvent", "pEvents", 1, dump_html_VkEvent);
        dump_html_value<const VkPipelineStageFlags>(srcStageMask, settings, "VkPipelineStageFlags", "srcStageMask", 1, dump_html_VkPipelineStageFlags);
        dump_html_value<const VkPipelineStageFlags>(dstStageMask, settings, "VkPipelineStageFlags", "dstStageMask", 1, dump_html_VkPipelineStageFlags);
        dump_html_value<const uint32_t>(memoryBarrierCount, settings, "uint32_t", "memoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMemoryBarrier>(pMemoryBarriers, memoryBarrierCount, settings, "const VkMemoryBarrier*", "const VkMemoryBarrier", "pMemoryBarriers", 1, dump_html_VkMemoryBarrier);
        dump_html_value<const uint32_t>(bufferMemoryBarrierCount, settings, "uint32_t", "bufferMemoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferMemoryBarrier>(pBufferMemoryBarriers, bufferMemoryBarrierCount, settings, "const VkBufferMemoryBarrier*", "const VkBufferMemoryBarrier", "pBufferMemoryBarriers", 1, dump_html_VkBufferMemoryBarrier);
        dump_html_value<const uint32_t>(imageMemoryBarrierCount, settings, "uint32_t", "imageMemoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageMemoryBarrier>(pImageMemoryBarriers, imageMemoryBarrierCount, settings, "const VkImageMemoryBarrier*", "const VkImageMemoryBarrier", "pImageMemoryBarriers", 1, dump_html_VkImageMemoryBarrier);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSurfaceSupportKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32* pSupported)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkBool32>(pSupported, settings, "VkBool32*", "pSupported", 1, dump_html_VkBool32);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateSharedSwapchainsKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchains)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(swapchainCount, settings, "uint32_t", "swapchainCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSwapchainCreateInfoKHR>(pCreateInfos, swapchainCount, settings, "const VkSwapchainCreateInfoKHR*", "const VkSwapchainCreateInfoKHR", "pCreateInfos", 1, dump_html_VkSwapchainCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkSwapchainKHR>(pSwapchains, swapchainCount, settings, "VkSwapchainKHR*", "VkSwapchainKHR", "pSwapchains", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateComputePipelines(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkComputePipelineCreateInfo>(pCreateInfos, createInfoCount, settings, "const VkComputePipelineCreateInfo*", "const VkComputePipelineCreateInfo", "pCreateInfos", 1, dump_html_VkComputePipelineCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkPipeline>(pPipelines, createInfoCount, settings, "VkPipeline*", "VkPipeline", "pPipelines", 1, dump_html_VkPipeline);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkAcquireFullScreenExclusiveModeEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkGetPhysicalDeviceSurfaceFormatsKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pSurfaceFormatCount, VkSurfaceFormatKHR* pSurfaceFormats)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const uint32_t>(pSurfaceFormatCount, settings, "uint32_t*", "pSurfaceFormatCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSurfaceFormatKHR>(pSurfaceFormats, *pSurfaceFormatCount, settings, "VkSurfaceFormatKHR*", "VkSurfaceFormatKHR", "pSurfaceFormats", 1, dump_html_VkSurfaceFormatKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkReleaseFullScreenExclusiveModeEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkCreateCommandPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCommandPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkCommandPool* pCommandPool)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCommandPoolCreateInfo>(pCreateInfo, settings, "const VkCommandPoolCreateInfo*", "pCreateInfo", 1, dump_html_VkCommandPoolCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkCommandPool>(pCommandPool, settings, "VkCommandPool*", "pCommandPool", 1, dump_html_VkCommandPool);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR* pSurfaceCapabilities)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkSurfaceCapabilitiesKHR>(pSurfaceCapabilities, settings, "VkSurfaceCapabilitiesKHR*", "pSurfaceCapabilities", 1, dump_html_VkSurfaceCapabilitiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetEvent(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_value<const VkPipelineStageFlags>(stageMask, settings, "VkPipelineStageFlags", "stageMask", 1, dump_html_VkPipelineStageFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkSetHdrMetadataEXT(ApiDumpInstance& dump_inst, VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR* pSwapchains, const VkHdrMetadataEXT* pMetadata)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(swapchainCount, settings, "uint32_t", "swapchainCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSwapchainKHR>(pSwapchains, swapchainCount, settings, "const VkSwapchainKHR*", "const VkSwapchainKHR", "pSwapchains", 1, dump_html_VkSwapchainKHR);
        dump_html_array<const VkHdrMetadataEXT>(pMetadata, swapchainCount, settings, "const VkHdrMetadataEXT*", "const VkHdrMetadataEXT", "pMetadata", 1, dump_html_VkHdrMetadataEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPipelineExecutablePropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice                        device, const VkPipelineInfoKHR*        pPipelineInfo, uint32_t* pExecutableCount, VkPipelineExecutablePropertiesKHR* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineInfoKHR>(pPipelineInfo, settings, "const VkPipelineInfoKHR*", "pPipelineInfo", 1, dump_html_VkPipelineInfoKHR);
        dump_html_pointer<const uint32_t>(pExecutableCount, settings, "uint32_t*", "pExecutableCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPipelineExecutablePropertiesKHR>(pProperties, *pExecutableCount, settings, "VkPipelineExecutablePropertiesKHR*", "VkPipelineExecutablePropertiesKHR", "pProperties", 1, dump_html_VkPipelineExecutablePropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdResetEvent(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_value<const VkPipelineStageFlags>(stageMask, settings, "VkPipelineStageFlags", "stageMask", 1, dump_html_VkPipelineStageFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkGetDeviceGroupSurfacePresentModes2EXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR* pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR* pModes)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPhysicalDeviceSurfaceInfo2KHR>(pSurfaceInfo, settings, "const VkPhysicalDeviceSurfaceInfo2KHR*", "pSurfaceInfo", 1, dump_html_VkPhysicalDeviceSurfaceInfo2KHR);
        dump_html_pointer<const VkDeviceGroupPresentModeFlagsKHR>(pModes, settings, "VkDeviceGroupPresentModeFlagsKHR*", "pModes", 1, dump_html_VkDeviceGroupPresentModeFlagsKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkGetPhysicalDeviceFeatures2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceFeatures2>(pFeatures, settings, "VkPhysicalDeviceFeatures2*", "pFeatures", 1, dump_html_VkPhysicalDeviceFeatures2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateHeadlessSurfaceEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkHeadlessSurfaceCreateInfoEXT>(pCreateInfo, settings, "const VkHeadlessSurfaceCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkHeadlessSurfaceCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetRenderAreaGranularity(ApiDumpInstance& dump_inst, VkDevice device, VkRenderPass renderPass, VkExtent2D* pGranularity)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkRenderPass>(renderPass, settings, "VkRenderPass", "renderPass", 1, dump_html_VkRenderPass);
        dump_html_pointer<const VkExtent2D>(pGranularity, settings, "VkExtent2D*", "pGranularity", 1, dump_html_VkExtent2D);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDisplayModeProperties2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t* pPropertyCount, VkDisplayModeProperties2KHR* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayModeProperties2KHR>(pProperties, *pPropertyCount, settings, "VkDisplayModeProperties2KHR*", "VkDisplayModeProperties2KHR", "pProperties", 1, dump_html_VkDisplayModeProperties2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetShaderInfoAMD(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t* pInfoSize, void* pInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_value<const VkShaderStageFlagBits>(shaderStage, settings, "VkShaderStageFlagBits", "shaderStage", 1, dump_html_VkShaderStageFlagBits);
        dump_html_value<const VkShaderInfoTypeAMD>(infoType, settings, "VkShaderInfoTypeAMD", "infoType", 1, dump_html_VkShaderInfoTypeAMD);
        dump_html_pointer<const size_t>(pInfoSize, settings, "size_t*", "pInfoSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pInfo, settings, "void*", "pInfo", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPipelineExecutableStatisticsKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice                        device, const VkPipelineExecutableInfoKHR*  pExecutableInfo, uint32_t* pStatisticCount, VkPipelineExecutableStatisticKHR* pStatistics)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineExecutableInfoKHR>(pExecutableInfo, settings, "const VkPipelineExecutableInfoKHR*", "pExecutableInfo", 1, dump_html_VkPipelineExecutableInfoKHR);
        dump_html_pointer<const uint32_t>(pStatisticCount, settings, "uint32_t*", "pStatisticCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPipelineExecutableStatisticKHR>(pStatistics, *pStatisticCount, settings, "VkPipelineExecutableStatisticKHR*", "VkPipelineExecutableStatisticKHR", "pStatistics", 1, dump_html_VkPipelineExecutableStatisticKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreatePipelineLayout(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPipelineLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineLayout* pPipelineLayout)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineLayoutCreateInfo>(pCreateInfo, settings, "const VkPipelineLayoutCreateInfo*", "pCreateInfo", 1, dump_html_VkPipelineLayoutCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkPipelineLayout>(pPipelineLayout, settings, "VkPipelineLayout*", "pPipelineLayout", 1, dump_html_VkPipelineLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyRenderPass(ApiDumpInstance& dump_inst, VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkRenderPass>(renderPass, settings, "VkRenderPass", "renderPass", 1, dump_html_VkRenderPass);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceProperties2>(pProperties, settings, "VkPhysicalDeviceProperties2*", "pProperties", 1, dump_html_VkPhysicalDeviceProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPipelineExecutableInternalRepresentationsKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice                        device, const VkPipelineExecutableInfoKHR*  pExecutableInfo, uint32_t* pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR* pInternalRepresentations)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineExecutableInfoKHR>(pExecutableInfo, settings, "const VkPipelineExecutableInfoKHR*", "pExecutableInfo", 1, dump_html_VkPipelineExecutableInfoKHR);
        dump_html_pointer<const uint32_t>(pInternalRepresentationCount, settings, "uint32_t*", "pInternalRepresentationCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPipelineExecutableInternalRepresentationKHR>(pInternalRepresentations, *pInternalRepresentationCount, settings, "VkPipelineExecutableInternalRepresentationKHR*", "VkPipelineExecutableInternalRepresentationKHR", "pInternalRepresentations", 1, dump_html_VkPipelineExecutableInternalRepresentationKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceMemoryProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceMemoryProperties2>(pMemoryProperties, settings, "VkPhysicalDeviceMemoryProperties2*", "pMemoryProperties", 1, dump_html_VkPhysicalDeviceMemoryProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceFormatProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_pointer<const VkFormatProperties2>(pFormatProperties, settings, "VkFormatProperties2*", "pFormatProperties", 1, dump_html_VkFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSurfacePresentModesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pPresentModeCount, VkPresentModeKHR* pPresentModes)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const uint32_t>(pPresentModeCount, settings, "uint32_t*", "pPresentModeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPresentModeKHR>(pPresentModes, *pPresentModeCount, settings, "VkPresentModeKHR*", "VkPresentModeKHR", "pPresentModes", 1, dump_html_VkPresentModeKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdPipelineBarrier(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier* pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier* pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier* pImageMemoryBarriers)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlags>(srcStageMask, settings, "VkPipelineStageFlags", "srcStageMask", 1, dump_html_VkPipelineStageFlags);
        dump_html_value<const VkPipelineStageFlags>(dstStageMask, settings, "VkPipelineStageFlags", "dstStageMask", 1, dump_html_VkPipelineStageFlags);
        dump_html_value<const VkDependencyFlags>(dependencyFlags, settings, "VkDependencyFlags", "dependencyFlags", 1, dump_html_VkDependencyFlags);
        dump_html_value<const uint32_t>(memoryBarrierCount, settings, "uint32_t", "memoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkMemoryBarrier>(pMemoryBarriers, memoryBarrierCount, settings, "const VkMemoryBarrier*", "const VkMemoryBarrier", "pMemoryBarriers", 1, dump_html_VkMemoryBarrier);
        dump_html_value<const uint32_t>(bufferMemoryBarrierCount, settings, "uint32_t", "bufferMemoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferMemoryBarrier>(pBufferMemoryBarriers, bufferMemoryBarrierCount, settings, "const VkBufferMemoryBarrier*", "const VkBufferMemoryBarrier", "pBufferMemoryBarriers", 1, dump_html_VkBufferMemoryBarrier);
        dump_html_value<const uint32_t>(imageMemoryBarrierCount, settings, "uint32_t", "imageMemoryBarrierCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageMemoryBarrier>(pImageMemoryBarriers, imageMemoryBarrierCount, settings, "const VkImageMemoryBarrier*", "const VkImageMemoryBarrier", "pImageMemoryBarriers", 1, dump_html_VkImageMemoryBarrier);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceDisplayProperties2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayProperties2KHR* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayProperties2KHR>(pProperties, *pPropertyCount, settings, "VkDisplayProperties2KHR*", "VkDisplayProperties2KHR", "pProperties", 1, dump_html_VkDisplayProperties2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceImageFormatProperties2(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceImageFormatInfo2>(pImageFormatInfo, settings, "const VkPhysicalDeviceImageFormatInfo2*", "pImageFormatInfo", 1, dump_html_VkPhysicalDeviceImageFormatInfo2);
        dump_html_pointer<const VkImageFormatProperties2>(pImageFormatProperties, settings, "VkImageFormatProperties2*", "pImageFormatProperties", 1, dump_html_VkImageFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateRenderPass2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkRenderPassCreateInfo2KHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkRenderPass* pRenderPass)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkRenderPassCreateInfo2KHR>(pCreateInfo, settings, "const VkRenderPassCreateInfo2KHR*", "pCreateInfo", 1, dump_html_VkRenderPassCreateInfo2KHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkRenderPass>(pRenderPass, settings, "VkRenderPass*", "pRenderPass", 1, dump_html_VkRenderPass);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyPipeline(ApiDumpInstance& dump_inst, VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, uint32_t* pPropertyCount, VkDisplayPlaneProperties2KHR* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDisplayPlaneProperties2KHR>(pProperties, *pPropertyCount, settings, "VkDisplayPlaneProperties2KHR*", "VkDisplayPlaneProperties2KHR", "pProperties", 1, dump_html_VkDisplayPlaneProperties2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSparseImageFormatProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSparseImageFormatInfo2>(pFormatInfo, settings, "const VkPhysicalDeviceSparseImageFormatInfo2*", "pFormatInfo", 1, dump_html_VkPhysicalDeviceSparseImageFormatInfo2);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageFormatProperties2>(pProperties, *pPropertyCount, settings, "VkSparseImageFormatProperties2*", "VkSparseImageFormatProperties2", "pProperties", 1, dump_html_VkSparseImageFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdProcessCommandsNVX(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCmdProcessCommandsInfoNVX* pProcessCommandsInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCmdProcessCommandsInfoNVX>(pProcessCommandsInfo, settings, "const VkCmdProcessCommandsInfoNVX*", "pProcessCommandsInfo", 1, dump_html_VkCmdProcessCommandsInfoNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceQueueFamilyProperties2(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pQueueFamilyPropertyCount, settings, "uint32_t*", "pQueueFamilyPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkQueueFamilyProperties2>(pQueueFamilyProperties, *pQueueFamilyPropertyCount, settings, "VkQueueFamilyProperties2*", "VkQueueFamilyProperties2", "pQueueFamilyProperties", 1, dump_html_VkQueueFamilyProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
std::ostream& dump_html_body_vkCreateXlibSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkXlibSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkXlibSurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkXlibSurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkXlibSurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
std::ostream& dump_html_body_vkFreeCommandBuffers(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_value<const uint32_t>(commandBufferCount, settings, "uint32_t", "commandBufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCommandBuffer>(pCommandBuffers, commandBufferCount, settings, "const VkCommandBuffer*", "const VkCommandBuffer", "pCommandBuffers", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyPipelineLayout(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineLayout>(pipelineLayout, settings, "VkPipelineLayout", "pipelineLayout", 1, dump_html_VkPipelineLayout);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkTrimCommandPool(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_value<const VkCommandPoolTrimFlags>(flags, settings, "VkCommandPoolTrimFlags", "flags", 1, dump_html_VkCommandPoolTrimFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDisplayPlaneCapabilities2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR* pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR* pCapabilities)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkDisplayPlaneInfo2KHR>(pDisplayPlaneInfo, settings, "const VkDisplayPlaneInfo2KHR*", "pDisplayPlaneInfo", 1, dump_html_VkDisplayPlaneInfo2KHR);
        dump_html_pointer<const VkDisplayPlaneCapabilities2KHR>(pCapabilities, settings, "VkDisplayPlaneCapabilities2KHR*", "pCapabilities", 1, dump_html_VkDisplayPlaneCapabilities2KHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_XLIB_KHR)
std::ostream& dump_html_body_vkGetPhysicalDeviceXlibPresentationSupportKHR(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display* dpy, VisualID visualID)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const Display*>(dpy, settings, "Display*", "dpy", 1, dump_html_Display);
        dump_html_value<const VisualID>(visualID, settings, "VisualID", "visualID", 1, dump_html_VisualID);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XLIB_KHR
std::ostream& dump_html_body_vkDestroyCommandPool(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkResetCommandPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_value<const VkCommandPoolResetFlags>(flags, settings, "VkCommandPoolResetFlags", "flags", 1, dump_html_VkCommandPoolResetFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_IOS_MVK)
std::ostream& dump_html_body_vkCreateIOSSurfaceMVK(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkIOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkIOSSurfaceCreateInfoMVK>(pCreateInfo, settings, "const VkIOSSurfaceCreateInfoMVK*", "pCreateInfo", 1, dump_html_VkIOSSurfaceCreateInfoMVK);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_IOS_MVK
std::ostream& dump_html_body_vkCmdReserveSpaceForCommandsNVX(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkCmdReserveSpaceForCommandsInfoNVX* pReserveSpaceInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCmdReserveSpaceForCommandsInfoNVX>(pReserveSpaceInfo, settings, "const VkCmdReserveSpaceForCommandsInfoNVX*", "pReserveSpaceInfo", 1, dump_html_VkCmdReserveSpaceForCommandsInfoNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBeginQuery(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
        dump_html_value<const VkQueryControlFlags>(flags, settings, "VkQueryControlFlags", "flags", 1, dump_html_VkQueryControlFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetLineStippleEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(lineStippleFactor, settings, "uint32_t", "lineStippleFactor", 1, dump_html_uint32_t);
        dump_html_value<const uint16_t>(lineStipplePattern, settings, "uint16_t", "lineStipplePattern", 1, dump_html_uint16_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateIndirectCommandsLayoutNVX(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkIndirectCommandsLayoutCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkIndirectCommandsLayoutNVX* pIndirectCommandsLayout)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkIndirectCommandsLayoutCreateInfoNVX>(pCreateInfo, settings, "const VkIndirectCommandsLayoutCreateInfoNVX*", "pCreateInfo", 1, dump_html_VkIndirectCommandsLayoutCreateInfoNVX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkIndirectCommandsLayoutNVX>(pIndirectCommandsLayout, settings, "VkIndirectCommandsLayoutNVX*", "pIndirectCommandsLayout", 1, dump_html_VkIndirectCommandsLayoutNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkResetQueryPoolEXT(ApiDumpInstance& dump_inst, VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkAllocateCommandBuffers(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkCommandBufferAllocateInfo* pAllocateInfo, VkCommandBuffer* pCommandBuffers)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkCommandBufferAllocateInfo>(pAllocateInfo, settings, "const VkCommandBufferAllocateInfo*", "pAllocateInfo", 1, dump_html_VkCommandBufferAllocateInfo);
        dump_html_array<const VkCommandBuffer>(pCommandBuffers, pAllocateInfo->commandBufferCount, settings, "VkCommandBuffer*", "VkCommandBuffer", "pCommandBuffers", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyIndirectCommandsLayoutNVX(ApiDumpInstance& dump_inst, VkDevice device, VkIndirectCommandsLayoutNVX indirectCommandsLayout, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkIndirectCommandsLayoutNVX>(indirectCommandsLayout, settings, "VkIndirectCommandsLayoutNVX", "indirectCommandsLayout", 1, dump_html_VkIndirectCommandsLayoutNVX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_GGP)
std::ostream& dump_html_body_vkCreateStreamDescriptorSurfaceGGP(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkStreamDescriptorSurfaceCreateInfoGGP>(pCreateInfo, settings, "const VkStreamDescriptorSurfaceCreateInfoGGP*", "pCreateInfo", 1, dump_html_VkStreamDescriptorSurfaceCreateInfoGGP);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_GGP
std::ostream& dump_html_body_vkUpdateDescriptorSetWithTemplateKHR(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSet>(descriptorSet, settings, "VkDescriptorSet", "descriptorSet", 1, dump_html_VkDescriptorSet);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_value<const void*>(pData, settings, "const void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDispatch(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(groupCountX, settings, "uint32_t", "groupCountX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountY, settings, "uint32_t", "groupCountY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountZ, settings, "uint32_t", "groupCountZ", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyInstance(ApiDumpInstance& dump_inst, VkInstance instance, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyDescriptorUpdateTemplateKHR(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdCopyBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy* pRegions)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(srcBuffer, settings, "VkBuffer", "srcBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferCopy>(pRegions, regionCount, settings, "const VkBufferCopy*", "const VkBufferCopy", "pRegions", 1, dump_html_VkBufferCopy);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateInstance(ApiDumpInstance& dump_inst, VkResult result, const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_pointer<const VkInstanceCreateInfo>(pCreateInfo, settings, "const VkInstanceCreateInfo*", "pCreateInfo", 1, dump_html_VkInstanceCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkInstance>(pInstance, settings, "VkInstance*", "pInstance", 1, dump_html_VkInstance);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateAccelerationStructureNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkAccelerationStructureCreateInfoNV* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkAccelerationStructureNV* pAccelerationStructure)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAccelerationStructureCreateInfoNV>(pCreateInfo, settings, "const VkAccelerationStructureCreateInfoNV*", "pCreateInfo", 1, dump_html_VkAccelerationStructureCreateInfoNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkAccelerationStructureNV>(pAccelerationStructure, settings, "VkAccelerationStructureNV*", "pAccelerationStructure", 1, dump_html_VkAccelerationStructureNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDispatchIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdCopyImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy* pRegions)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(srcImage, settings, "VkImage", "srcImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(srcImageLayout, settings, "VkImageLayout", "srcImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageCopy>(pRegions, regionCount, settings, "const VkImageCopy*", "const VkImageCopy", "pRegions", 1, dump_html_VkImageCopy);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateFence(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkFenceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkFence* pFence)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkFenceCreateInfo>(pCreateInfo, settings, "const VkFenceCreateInfo*", "pCreateInfo", 1, dump_html_VkFenceCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkFence>(pFence, settings, "VkFence*", "pFence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBlitImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit* pRegions, VkFilter filter)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(srcImage, settings, "VkImage", "srcImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(srcImageLayout, settings, "VkImageLayout", "srcImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageBlit>(pRegions, regionCount, settings, "const VkImageBlit*", "const VkImageBlit", "pRegions", 1, dump_html_VkImageBlit);
        dump_html_value<const VkFilter>(filter, settings, "VkFilter", "filter", 1, dump_html_VkFilter);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkBindBufferMemory2(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindBufferMemoryInfo>(pBindInfos, bindInfoCount, settings, "const VkBindBufferMemoryInfo*", "const VkBindBufferMemoryInfo", "pBindInfos", 1, dump_html_VkBindBufferMemoryInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV* pExternalImageFormatProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_value<const VkImageType>(type, settings, "VkImageType", "type", 1, dump_html_VkImageType);
        dump_html_value<const VkImageTiling>(tiling, settings, "VkImageTiling", "tiling", 1, dump_html_VkImageTiling);
        dump_html_value<const VkImageUsageFlags>(usage, settings, "VkImageUsageFlags", "usage", 1, dump_html_VkImageUsageFlags);
        dump_html_value<const VkImageCreateFlags>(flags, settings, "VkImageCreateFlags", "flags", 1, dump_html_VkImageCreateFlags);
        dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(externalHandleType, settings, "VkExternalMemoryHandleTypeFlagsNV", "externalHandleType", 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
        dump_html_pointer<const VkExternalImageFormatPropertiesNV>(pExternalImageFormatProperties, settings, "VkExternalImageFormatPropertiesNV*", "pExternalImageFormatProperties", 1, dump_html_VkExternalImageFormatPropertiesNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkBindImageMemory2(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindImageMemoryInfo>(pBindInfos, bindInfoCount, settings, "const VkBindImageMemoryInfo*", "const VkBindImageMemoryInfo", "pBindInfos", 1, dump_html_VkBindImageMemoryInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBuildAccelerationStructureNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV* pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkAccelerationStructureInfoNV>(pInfo, settings, "const VkAccelerationStructureInfoNV*", "pInfo", 1, dump_html_VkAccelerationStructureInfoNV);
        dump_html_value<const VkBuffer>(instanceData, settings, "VkBuffer", "instanceData", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(instanceOffset, settings, "VkDeviceSize", "instanceOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBool32>(update, settings, "VkBool32", "update", 1, dump_html_VkBool32);
        dump_html_value<const VkAccelerationStructureNV>(dst, settings, "VkAccelerationStructureNV", "dst", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkAccelerationStructureNV>(src, settings, "VkAccelerationStructureNV", "src", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkBuffer>(scratch, settings, "VkBuffer", "scratch", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(scratchOffset, settings, "VkDeviceSize", "scratchOffset", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetAccelerationStructureMemoryRequirementsNV(ApiDumpInstance& dump_inst, VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV* pInfo, VkMemoryRequirements2KHR* pMemoryRequirements)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAccelerationStructureMemoryRequirementsInfoNV>(pInfo, settings, "const VkAccelerationStructureMemoryRequirementsInfoNV*", "pInfo", 1, dump_html_VkAccelerationStructureMemoryRequirementsInfoNV);
        dump_html_pointer<const VkMemoryRequirements2>(pMemoryRequirements, settings, "VkMemoryRequirements2KHR*", "pMemoryRequirements", 1, dump_html_VkMemoryRequirements2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyAccelerationStructureNV(ApiDumpInstance& dump_inst, VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkAccelerationStructureNV>(accelerationStructure, settings, "VkAccelerationStructureNV", "accelerationStructure", 1, dump_html_VkAccelerationStructureNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkBindAccelerationStructureMemoryNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV* pBindInfos)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindAccelerationStructureMemoryInfoNV>(pBindInfos, bindInfoCount, settings, "const VkBindAccelerationStructureMemoryInfoNV*", "const VkBindAccelerationStructureMemoryInfoNV", "pBindInfos", 1, dump_html_VkBindAccelerationStructureMemoryInfoNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdCopyBufferToImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy* pRegions)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(srcBuffer, settings, "VkBuffer", "srcBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferImageCopy>(pRegions, regionCount, settings, "const VkBufferImageCopy*", "const VkBufferImageCopy", "pRegions", 1, dump_html_VkBufferImageCopy);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdCopyAccelerationStructureNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeNV mode)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkAccelerationStructureNV>(dst, settings, "VkAccelerationStructureNV", "dst", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkAccelerationStructureNV>(src, settings, "VkAccelerationStructureNV", "src", 1, dump_html_VkAccelerationStructureNV);
        dump_html_value<const VkCopyAccelerationStructureModeNV>(mode, settings, "VkCopyAccelerationStructureModeNV", "mode", 1, dump_html_VkCopyAccelerationStructureModeNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkGetMemoryWin32HandleNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE* pHandle)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDeviceMemory>(memory, settings, "VkDeviceMemory", "memory", 1, dump_html_VkDeviceMemory);
        dump_html_value<const VkExternalMemoryHandleTypeFlagsNV>(handleType, settings, "VkExternalMemoryHandleTypeFlagsNV", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagsNV);
        dump_html_pointer<const HANDLE>(pHandle, settings, "HANDLE*", "pHandle", 1, dump_html_HANDLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkGetPhysicalDeviceFormatProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties* pFormatProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_pointer<const VkFormatProperties>(pFormatProperties, settings, "VkFormatProperties*", "pFormatProperties", 1, dump_html_VkFormatProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkResetFences(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t fenceCount, const VkFence* pFences)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(fenceCount, settings, "uint32_t", "fenceCount", 1, dump_html_uint32_t);
        dump_html_array<const VkFence>(pFences, fenceCount, settings, "const VkFence*", "const VkFence", "pFences", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdTraceRaysNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(raygenShaderBindingTableBuffer, settings, "VkBuffer", "raygenShaderBindingTableBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(raygenShaderBindingOffset, settings, "VkDeviceSize", "raygenShaderBindingOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(missShaderBindingTableBuffer, settings, "VkBuffer", "missShaderBindingTableBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(missShaderBindingOffset, settings, "VkDeviceSize", "missShaderBindingOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(missShaderBindingStride, settings, "VkDeviceSize", "missShaderBindingStride", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(hitShaderBindingTableBuffer, settings, "VkBuffer", "hitShaderBindingTableBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(hitShaderBindingOffset, settings, "VkDeviceSize", "hitShaderBindingOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(hitShaderBindingStride, settings, "VkDeviceSize", "hitShaderBindingStride", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkBuffer>(callableShaderBindingTableBuffer, settings, "VkBuffer", "callableShaderBindingTableBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(callableShaderBindingOffset, settings, "VkDeviceSize", "callableShaderBindingOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(callableShaderBindingStride, settings, "VkDeviceSize", "callableShaderBindingStride", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(width, settings, "uint32_t", "width", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(height, settings, "uint32_t", "height", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(depth, settings, "uint32_t", "depth", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateRayTracingPipelinesNV(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRayTracingPipelineCreateInfoNV>(pCreateInfos, createInfoCount, settings, "const VkRayTracingPipelineCreateInfoNV*", "const VkRayTracingPipelineCreateInfoNV", "pCreateInfos", 1, dump_html_VkRayTracingPipelineCreateInfoNV);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkPipeline>(pPipelines, createInfoCount, settings, "VkPipeline*", "VkPipeline", "pPipelines", 1, dump_html_VkPipeline);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyFence(ApiDumpInstance& dump_inst, VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdCopyImageToBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy* pRegions)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(srcImage, settings, "VkImage", "srcImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(srcImageLayout, settings, "VkImageLayout", "srcImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBufferImageCopy>(pRegions, regionCount, settings, "const VkBufferImageCopy*", "const VkBufferImageCopy", "pRegions", 1, dump_html_VkBufferImageCopy);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkSetDebugUtilsObjectNameEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDebugUtilsObjectNameInfoEXT* pNameInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDebugUtilsObjectNameInfoEXT>(pNameInfo, settings, "const VkDebugUtilsObjectNameInfoEXT*", "pNameInfo", 1, dump_html_VkDebugUtilsObjectNameInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateShaderModule(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkShaderModuleCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkShaderModule* pShaderModule)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkShaderModuleCreateInfo>(pCreateInfo, settings, "const VkShaderModuleCreateInfo*", "pCreateInfo", 1, dump_html_VkShaderModuleCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkShaderModule>(pShaderModule, settings, "VkShaderModule*", "pShaderModule", 1, dump_html_VkShaderModule);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateBufferView(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkBufferViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBufferView* pView)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferViewCreateInfo>(pCreateInfo, settings, "const VkBufferViewCreateInfo*", "pCreateInfo", 1, dump_html_VkBufferViewCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkBufferView>(pView, settings, "VkBufferView*", "pView", 1, dump_html_VkBufferView);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetViewportShadingRatePaletteNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV* pShadingRatePalettes)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstViewport, settings, "uint32_t", "firstViewport", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkShadingRatePaletteNV>(pShadingRatePalettes, viewportCount, settings, "const VkShadingRatePaletteNV*", "const VkShadingRatePaletteNV", "pShadingRatePalettes", 1, dump_html_VkShadingRatePaletteNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkSetDebugUtilsObjectTagEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDebugUtilsObjectTagInfoEXT* pTagInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDebugUtilsObjectTagInfoEXT>(pTagInfo, settings, "const VkDebugUtilsObjectTagInfoEXT*", "pTagInfo", 1, dump_html_VkDebugUtilsObjectTagInfoEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreatePipelineCache(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkPipelineCacheCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkPipelineCache* pPipelineCache)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkPipelineCacheCreateInfo>(pCreateInfo, settings, "const VkPipelineCacheCreateInfo*", "pCreateInfo", 1, dump_html_VkPipelineCacheCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkPipelineCache>(pPipelineCache, settings, "VkPipelineCache*", "pPipelineCache", 1, dump_html_VkPipelineCache);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkQueueInsertDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const VkDebugUtilsLabelEXT>(pLabelInfo, settings, "const VkDebugUtilsLabelEXT*", "pLabelInfo", 1, dump_html_VkDebugUtilsLabelEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkQueueBeginDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue, const VkDebugUtilsLabelEXT* pLabelInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
        dump_html_pointer<const VkDebugUtilsLabelEXT>(pLabelInfo, settings, "const VkDebugUtilsLabelEXT*", "pLabelInfo", 1, dump_html_VkDebugUtilsLabelEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkQueueEndDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkQueue queue)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkQueue>(queue, settings, "VkQueue", "queue", 1, dump_html_VkQueue);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBindShadingRateImageNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImageView>(imageView, settings, "VkImageView", "imageView", 1, dump_html_VkImageView);
        dump_html_value<const VkImageLayout>(imageLayout, settings, "VkImageLayout", "imageLayout", 1, dump_html_VkImageLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyBuffer(ApiDumpInstance& dump_inst, VkDevice device, VkBuffer buffer, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyShaderModule(ApiDumpInstance& dump_inst, VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkShaderModule>(shaderModule, settings, "VkShaderModule", "shaderModule", 1, dump_html_VkShaderModule);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBeginDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDebugUtilsLabelEXT>(pLabelInfo, settings, "const VkDebugUtilsLabelEXT*", "pLabelInfo", 1, dump_html_VkDebugUtilsLabelEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetCoarseSampleOrderNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV* pCustomSampleOrders)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCoarseSampleOrderTypeNV>(sampleOrderType, settings, "VkCoarseSampleOrderTypeNV", "sampleOrderType", 1, dump_html_VkCoarseSampleOrderTypeNV);
        dump_html_value<const uint32_t>(customSampleOrderCount, settings, "uint32_t", "customSampleOrderCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCoarseSampleOrderCustomNV>(pCustomSampleOrders, customSampleOrderCount, settings, "const VkCoarseSampleOrderCustomNV*", "const VkCoarseSampleOrderCustomNV", "pCustomSampleOrders", 1, dump_html_VkCoarseSampleOrderCustomNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdEndDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdInsertDebugUtilsLabelEXT(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT* pLabelInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkDebugUtilsLabelEXT>(pLabelInfo, settings, "const VkDebugUtilsLabelEXT*", "pLabelInfo", 1, dump_html_VkDebugUtilsLabelEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkImportSemaphoreWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR* pImportSemaphoreWin32HandleInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportSemaphoreWin32HandleInfoKHR>(pImportSemaphoreWin32HandleInfo, settings, "const VkImportSemaphoreWin32HandleInfoKHR*", "pImportSemaphoreWin32HandleInfo", 1, dump_html_VkImportSemaphoreWin32HandleInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkCreateDebugUtilsMessengerEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugUtilsMessengerEXT* pMessenger)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkDebugUtilsMessengerCreateInfoEXT>(pCreateInfo, settings, "const VkDebugUtilsMessengerCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkDebugUtilsMessengerCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDebugUtilsMessengerEXT>(pMessenger, settings, "VkDebugUtilsMessengerEXT*", "pMessenger", 1, dump_html_VkDebugUtilsMessengerEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateImage(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImage* pImage)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageCreateInfo>(pCreateInfo, settings, "const VkImageCreateInfo*", "pCreateInfo", 1, dump_html_VkImageCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkImage>(pImage, settings, "VkImage*", "pImage", 1, dump_html_VkImage);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPipelineCacheData(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache pipelineCache, size_t* pDataSize, void* pData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_pointer<const size_t>(pDataSize, settings, "size_t*", "pDataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkSubmitDebugUtilsMessageEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT* pCallbackData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkDebugUtilsMessageSeverityFlagBitsEXT>(messageSeverity, settings, "VkDebugUtilsMessageSeverityFlagBitsEXT", "messageSeverity", 1, dump_html_VkDebugUtilsMessageSeverityFlagBitsEXT);
        dump_html_value<const VkDebugUtilsMessageTypeFlagsEXT>(messageTypes, settings, "VkDebugUtilsMessageTypeFlagsEXT", "messageTypes", 1, dump_html_VkDebugUtilsMessageTypeFlagsEXT);
        dump_html_pointer<const VkDebugUtilsMessengerCallbackDataEXT>(pCallbackData, settings, "const VkDebugUtilsMessengerCallbackDataEXT*", "pCallbackData", 1, dump_html_VkDebugUtilsMessengerCallbackDataEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyBufferView(ApiDumpInstance& dump_inst, VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkBufferView>(bufferView, settings, "VkBufferView", "bufferView", 1, dump_html_VkBufferView);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdNextSubpass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSubpassBeginInfoKHR*      pSubpassBeginInfo, const VkSubpassEndInfoKHR*        pSubpassEndInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSubpassBeginInfoKHR>(pSubpassBeginInfo, settings, "const VkSubpassBeginInfoKHR*", "pSubpassBeginInfo", 1, dump_html_VkSubpassBeginInfoKHR);
        dump_html_pointer<const VkSubpassEndInfoKHR>(pSubpassEndInfo, settings, "const VkSubpassEndInfoKHR*", "pSubpassEndInfo", 1, dump_html_VkSubpassEndInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyPipelineCache(ApiDumpInstance& dump_inst, VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyImage(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyDebugUtilsMessengerEXT(ApiDumpInstance& dump_inst, VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkDebugUtilsMessengerEXT>(messenger, settings, "VkDebugUtilsMessengerEXT", "messenger", 1, dump_html_VkDebugUtilsMessengerEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkMergePipelineCaches(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache* pSrcCaches)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(dstCache, settings, "VkPipelineCache", "dstCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(srcCacheCount, settings, "uint32_t", "srcCacheCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPipelineCache>(pSrcCaches, srcCacheCount, settings, "const VkPipelineCache*", "const VkPipelineCache", "pSrcCaches", 1, dump_html_VkPipelineCache);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateGraphicsPipelines(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo* pCreateInfos, const VkAllocationCallbacks* pAllocator, VkPipeline* pPipelines)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkPipelineCache>(pipelineCache, settings, "VkPipelineCache", "pipelineCache", 1, dump_html_VkPipelineCache);
        dump_html_value<const uint32_t>(createInfoCount, settings, "uint32_t", "createInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkGraphicsPipelineCreateInfo>(pCreateInfos, createInfoCount, settings, "const VkGraphicsPipelineCreateInfo*", "const VkGraphicsPipelineCreateInfo", "pCreateInfos", 1, dump_html_VkGraphicsPipelineCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_array<const VkPipeline>(pPipelines, createInfoCount, settings, "VkPipeline*", "VkPipeline", "pPipelines", 1, dump_html_VkPipeline);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkGetSemaphoreWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreGetWin32HandleInfoKHR>(pGetWin32HandleInfo, settings, "const VkSemaphoreGetWin32HandleInfoKHR*", "pGetWin32HandleInfo", 1, dump_html_VkSemaphoreGetWin32HandleInfoKHR);
        dump_html_pointer<const HANDLE>(pHandle, settings, "HANDLE*", "pHandle", 1, dump_html_HANDLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkImportSemaphoreFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportSemaphoreFdInfoKHR>(pImportSemaphoreFdInfo, settings, "const VkImportSemaphoreFdInfoKHR*", "pImportSemaphoreFdInfo", 1, dump_html_VkImportSemaphoreFdInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBeginRenderPass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo*      pRenderPassBegin, const VkSubpassBeginInfoKHR*      pSubpassBeginInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderPassBeginInfo>(pRenderPassBegin, settings, "const VkRenderPassBeginInfo*", "pRenderPassBegin", 1, dump_html_VkRenderPassBeginInfo);
        dump_html_pointer<const VkSubpassBeginInfoKHR>(pSubpassBeginInfo, settings, "const VkSubpassBeginInfoKHR*", "pSubpassBeginInfo", 1, dump_html_VkSubpassBeginInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetSemaphoreFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreGetFdInfoKHR>(pGetFdInfo, settings, "const VkSemaphoreGetFdInfoKHR*", "pGetFdInfo", 1, dump_html_VkSemaphoreGetFdInfoKHR);
        dump_html_pointer<const int>(pFd, settings, "int*", "pFd", 1, dump_html_int);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_MACOS_MVK)
std::ostream& dump_html_body_vkCreateMacOSSurfaceMVK(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkMacOSSurfaceCreateInfoMVK* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkMacOSSurfaceCreateInfoMVK>(pCreateInfo, settings, "const VkMacOSSurfaceCreateInfoMVK*", "pCreateInfo", 1, dump_html_VkMacOSSurfaceCreateInfoMVK);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_MACOS_MVK
std::ostream& dump_html_body_vkCreateSampler(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSamplerCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSampler* pSampler)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSamplerCreateInfo>(pCreateInfo, settings, "const VkSamplerCreateInfo*", "pCreateInfo", 1, dump_html_VkSamplerCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSampler>(pSampler, settings, "VkSampler*", "pSampler", 1, dump_html_VkSampler);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdEndRenderPass2KHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkSubpassEndInfoKHR*        pSubpassEndInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkSubpassEndInfoKHR>(pSubpassEndInfo, settings, "const VkSubpassEndInfoKHR*", "pSubpassEndInfo", 1, dump_html_VkSubpassEndInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroySamplerYcbcrConversionKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSamplerYcbcrConversion>(ycbcrConversion, settings, "VkSamplerYcbcrConversion", "ycbcrConversion", 1, dump_html_VkSamplerYcbcrConversion);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageSubresourceLayout(ApiDumpInstance& dump_inst, VkDevice device, VkImage image, const VkImageSubresource* pSubresource, VkSubresourceLayout* pLayout)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkImageSubresource>(pSubresource, settings, "const VkImageSubresource*", "pSubresource", 1, dump_html_VkImageSubresource);
        dump_html_pointer<const VkSubresourceLayout>(pLayout, settings, "VkSubresourceLayout*", "pLayout", 1, dump_html_VkSubresourceLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkBindBufferMemory2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo* pBindInfos)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindBufferMemoryInfo>(pBindInfos, bindInfoCount, settings, "const VkBindBufferMemoryInfo*", "const VkBindBufferMemoryInfo", "pBindInfos", 1, dump_html_VkBindBufferMemoryInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDeviceGroupPeerMemoryFeatures(ApiDumpInstance& dump_inst, VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(heapIndex, settings, "uint32_t", "heapIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(localDeviceIndex, settings, "uint32_t", "localDeviceIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(remoteDeviceIndex, settings, "uint32_t", "remoteDeviceIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const VkPeerMemoryFeatureFlags>(pPeerMemoryFeatures, settings, "VkPeerMemoryFeatureFlags*", "pPeerMemoryFeatures", 1, dump_html_VkPeerMemoryFeatureFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkBindImageMemory2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(bindInfoCount, settings, "uint32_t", "bindInfoCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBindImageMemoryInfo>(pBindInfos, bindInfoCount, settings, "const VkBindImageMemoryInfo*", "const VkBindImageMemoryInfo", "pBindInfos", 1, dump_html_VkBindImageMemoryInfo);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateImageView(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImageViewCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkImageView* pView)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImageViewCreateInfo>(pCreateInfo, settings, "const VkImageViewCreateInfo*", "pCreateInfo", 1, dump_html_VkImageViewCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkImageView>(pView, settings, "VkImageView*", "pView", 1, dump_html_VkImageView);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetSwapchainStatusKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkGetMemoryWin32HandlePropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR* pMemoryWin32HandleProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
        dump_html_value<const HANDLE>(handle, settings, "HANDLE", "handle", 1, dump_html_HANDLE);
        dump_html_pointer<const VkMemoryWin32HandlePropertiesKHR>(pMemoryWin32HandleProperties, settings, "VkMemoryWin32HandlePropertiesKHR*", "pMemoryWin32HandleProperties", 1, dump_html_VkMemoryWin32HandlePropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_body_vkGetAndroidHardwareBufferPropertiesANDROID(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const struct AHardwareBuffer* buffer, VkAndroidHardwareBufferPropertiesANDROID* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const AHardwareBuffer*>(buffer, settings, "const struct AHardwareBuffer*", "buffer", 1, dump_html_AHardwareBuffer);
        dump_html_pointer<const VkAndroidHardwareBufferPropertiesANDROID>(pProperties, settings, "VkAndroidHardwareBufferPropertiesANDROID*", "pProperties", 1, dump_html_VkAndroidHardwareBufferPropertiesANDROID);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_body_vkGetPhysicalDeviceExternalFencePropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalFenceInfo>(pExternalFenceInfo, settings, "const VkPhysicalDeviceExternalFenceInfo*", "pExternalFenceInfo", 1, dump_html_VkPhysicalDeviceExternalFenceInfo);
        dump_html_pointer<const VkExternalFenceProperties>(pExternalFenceProperties, settings, "VkExternalFenceProperties*", "pExternalFenceProperties", 1, dump_html_VkExternalFenceProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_body_vkGetMemoryAndroidHardwareBufferANDROID(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID* pInfo, struct AHardwareBuffer** pBuffer)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryGetAndroidHardwareBufferInfoANDROID>(pInfo, settings, "const VkMemoryGetAndroidHardwareBufferInfoANDROID*", "pInfo", 1, dump_html_VkMemoryGetAndroidHardwareBufferInfoANDROID);
        dump_html_pointer<const AHardwareBuffer*>(pBuffer, settings, "struct AHardwareBuffer**", "pBuffer", 1, dump_html_AHardwareBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkGetMemoryWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryGetWin32HandleInfoKHR>(pGetWin32HandleInfo, settings, "const VkMemoryGetWin32HandleInfoKHR*", "pGetWin32HandleInfo", 1, dump_html_VkMemoryGetWin32HandleInfoKHR);
        dump_html_pointer<const HANDLE>(pHandle, settings, "HANDLE*", "pHandle", 1, dump_html_HANDLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkCreateDescriptorPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorPool* pDescriptorPool)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorPoolCreateInfo>(pCreateInfo, settings, "const VkDescriptorPoolCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorPoolCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDescriptorPool>(pDescriptorPool, settings, "VkDescriptorPool*", "pDescriptorPool", 1, dump_html_VkDescriptorPool);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetDeviceMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t deviceMask)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(deviceMask, settings, "uint32_t", "deviceMask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDispatchBase(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(baseGroupX, settings, "uint32_t", "baseGroupX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(baseGroupY, settings, "uint32_t", "baseGroupY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(baseGroupZ, settings, "uint32_t", "baseGroupZ", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountX, settings, "uint32_t", "groupCountX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountY, settings, "uint32_t", "groupCountY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountZ, settings, "uint32_t", "groupCountZ", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkImportFenceWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportFenceWin32HandleInfoKHR* pImportFenceWin32HandleInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportFenceWin32HandleInfoKHR>(pImportFenceWin32HandleInfo, settings, "const VkImportFenceWin32HandleInfoKHR*", "pImportFenceWin32HandleInfo", 1, dump_html_VkImportFenceWin32HandleInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkFreeDescriptorSets(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorPool>(descriptorPool, settings, "VkDescriptorPool", "descriptorPool", 1, dump_html_VkDescriptorPool);
        dump_html_value<const uint32_t>(descriptorSetCount, settings, "uint32_t", "descriptorSetCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDescriptorSet>(pDescriptorSets, descriptorSetCount, settings, "const VkDescriptorSet*", "const VkDescriptorSet", "pDescriptorSets", 1, dump_html_VkDescriptorSet);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceExternalSemaphoreProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalSemaphoreInfo>(pExternalSemaphoreInfo, settings, "const VkPhysicalDeviceExternalSemaphoreInfo*", "pExternalSemaphoreInfo", 1, dump_html_VkPhysicalDeviceExternalSemaphoreInfo);
        dump_html_pointer<const VkExternalSemaphoreProperties>(pExternalSemaphoreProperties, settings, "VkExternalSemaphoreProperties*", "pExternalSemaphoreProperties", 1, dump_html_VkExternalSemaphoreProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetMemoryFdPropertiesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR* pMemoryFdProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkExternalMemoryHandleTypeFlagBits>(handleType, settings, "VkExternalMemoryHandleTypeFlagBits", "handleType", 1, dump_html_VkExternalMemoryHandleTypeFlagBits);
        dump_html_value<const int>(fd, settings, "int", "fd", 1, dump_html_int);
        dump_html_pointer<const VkMemoryFdPropertiesKHR>(pMemoryFdProperties, settings, "VkMemoryFdPropertiesKHR*", "pMemoryFdProperties", 1, dump_html_VkMemoryFdPropertiesKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyDescriptorPool(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorPool>(descriptorPool, settings, "VkDescriptorPool", "descriptorPool", 1, dump_html_VkDescriptorPool);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetImageDrmFormatModifierPropertiesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_pointer<const VkImageDrmFormatModifierPropertiesEXT>(pProperties, settings, "VkImageDrmFormatModifierPropertiesEXT*", "pProperties", 1, dump_html_VkImageDrmFormatModifierPropertiesEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateDescriptorSetLayout(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorSetLayout* pSetLayout)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetLayoutCreateInfo>(pCreateInfo, settings, "const VkDescriptorSetLayoutCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorSetLayoutCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDescriptorSetLayout>(pSetLayout, settings, "VkDescriptorSetLayout*", "pSetLayout", 1, dump_html_VkDescriptorSetLayout);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkResetDescriptorPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorPool>(descriptorPool, settings, "VkDescriptorPool", "descriptorPool", 1, dump_html_VkDescriptorPool);
        dump_html_value<const VkDescriptorPoolResetFlags>(flags, settings, "VkDescriptorPoolResetFlags", "flags", 1, dump_html_VkDescriptorPoolResetFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkEnumeratePhysicalDeviceGroups(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const uint32_t>(pPhysicalDeviceGroupCount, settings, "uint32_t*", "pPhysicalDeviceGroupCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDeviceGroupProperties>(pPhysicalDeviceGroupProperties, *pPhysicalDeviceGroupCount, settings, "VkPhysicalDeviceGroupProperties*", "VkPhysicalDeviceGroupProperties", "pPhysicalDeviceGroupProperties", 1, dump_html_VkPhysicalDeviceGroupProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetMemoryFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkMemoryGetFdInfoKHR* pGetFdInfo, int* pFd)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkMemoryGetFdInfoKHR>(pGetFdInfo, settings, "const VkMemoryGetFdInfoKHR*", "pGetFdInfo", 1, dump_html_VkMemoryGetFdInfoKHR);
        dump_html_pointer<const int>(pFd, settings, "int*", "pFd", 1, dump_html_int);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkAllocateDescriptorSets(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorSetAllocateInfo* pAllocateInfo, VkDescriptorSet* pDescriptorSets)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetAllocateInfo>(pAllocateInfo, settings, "const VkDescriptorSetAllocateInfo*", "pAllocateInfo", 1, dump_html_VkDescriptorSetAllocateInfo);
        dump_html_array<const VkDescriptorSet>(pDescriptorSets, pAllocateInfo->descriptorSetCount, settings, "VkDescriptorSet*", "VkDescriptorSet", "pDescriptorSets", 1, dump_html_VkDescriptorSet);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroySampler(ApiDumpInstance& dump_inst, VkDevice device, VkSampler sampler, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSampler>(sampler, settings, "VkSampler", "sampler", 1, dump_html_VkSampler);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WIN32_KHR)
std::ostream& dump_html_body_vkGetFenceWin32HandleKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkFenceGetWin32HandleInfoKHR* pGetWin32HandleInfo, HANDLE* pHandle)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkFenceGetWin32HandleInfoKHR>(pGetWin32HandleInfo, settings, "const VkFenceGetWin32HandleInfoKHR*", "pGetWin32HandleInfo", 1, dump_html_VkFenceGetWin32HandleInfoKHR);
        dump_html_pointer<const HANDLE>(pHandle, settings, "HANDLE*", "pHandle", 1, dump_html_HANDLE);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WIN32_KHR
std::ostream& dump_html_body_vkGetDescriptorSetLayoutSupport(ApiDumpInstance& dump_inst, VkDevice device, const VkDescriptorSetLayoutCreateInfo* pCreateInfo, VkDescriptorSetLayoutSupport* pSupport)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorSetLayoutCreateInfo>(pCreateInfo, settings, "const VkDescriptorSetLayoutCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorSetLayoutCreateInfo);
        dump_html_pointer<const VkDescriptorSetLayoutSupport>(pSupport, settings, "VkDescriptorSetLayoutSupport*", "pSupport", 1, dump_html_VkDescriptorSetLayoutSupport);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroySurfaceKHR(ApiDumpInstance& dump_inst, VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateSamplerYcbcrConversionKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSamplerYcbcrConversionCreateInfo>(pCreateInfo, settings, "const VkSamplerYcbcrConversionCreateInfo*", "pCreateInfo", 1, dump_html_VkSamplerYcbcrConversionCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSamplerYcbcrConversion>(pYcbcrConversion, settings, "VkSamplerYcbcrConversion*", "pYcbcrConversion", 1, dump_html_VkSamplerYcbcrConversion);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyDescriptorSetLayout(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSetLayout>(descriptorSetLayout, settings, "VkDescriptorSetLayout", "descriptorSetLayout", 1, dump_html_VkDescriptorSetLayout);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo, VkExternalSemaphoreProperties* pExternalSemaphoreProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalSemaphoreInfo>(pExternalSemaphoreInfo, settings, "const VkPhysicalDeviceExternalSemaphoreInfo*", "pExternalSemaphoreInfo", 1, dump_html_VkPhysicalDeviceExternalSemaphoreInfo);
        dump_html_pointer<const VkExternalSemaphoreProperties>(pExternalSemaphoreProperties, settings, "VkExternalSemaphoreProperties*", "pExternalSemaphoreProperties", 1, dump_html_VkExternalSemaphoreProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyImageView(ApiDumpInstance& dump_inst, VkDevice device, VkImageView imageView, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkImageView>(imageView, settings, "VkImageView", "imageView", 1, dump_html_VkImageView);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBindDescriptorSets(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet* pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const uint32_t>(firstSet, settings, "uint32_t", "firstSet", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(descriptorSetCount, settings, "uint32_t", "descriptorSetCount", 1, dump_html_uint32_t);
        dump_html_array<const VkDescriptorSet>(pDescriptorSets, descriptorSetCount, settings, "const VkDescriptorSet*", "const VkDescriptorSet", "pDescriptorSets", 1, dump_html_VkDescriptorSet);
        dump_html_value<const uint32_t>(dynamicOffsetCount, settings, "uint32_t", "dynamicOffsetCount", 1, dump_html_uint32_t);
        dump_html_array<const uint32_t>(pDynamicOffsets, dynamicOffsetCount, settings, "const uint32_t*", "const uint32_t", "pDynamicOffsets", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkImportFenceFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkImportFenceFdInfoKHR* pImportFenceFdInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkImportFenceFdInfoKHR>(pImportFenceFdInfo, settings, "const VkImportFenceFdInfoKHR*", "pImportFenceFdInfo", 1, dump_html_VkImportFenceFdInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkMergeValidationCachesEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT* pSrcCaches)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkValidationCacheEXT>(dstCache, settings, "VkValidationCacheEXT", "dstCache", 1, dump_html_VkValidationCacheEXT);
        dump_html_value<const uint32_t>(srcCacheCount, settings, "uint32_t", "srcCacheCount", 1, dump_html_uint32_t);
        dump_html_array<const VkValidationCacheEXT>(pSrcCaches, srcCacheCount, settings, "const VkValidationCacheEXT*", "const VkValidationCacheEXT", "pSrcCaches", 1, dump_html_VkValidationCacheEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateValidationCacheEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkValidationCacheCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkValidationCacheEXT* pValidationCache)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkValidationCacheCreateInfoEXT>(pCreateInfo, settings, "const VkValidationCacheCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkValidationCacheCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkValidationCacheEXT>(pValidationCache, settings, "VkValidationCacheEXT*", "pValidationCache", 1, dump_html_VkValidationCacheEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetDepthBounds(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const float>(minDepthBounds, settings, "float", "minDepthBounds", 1, dump_html_float);
        dump_html_value<const float>(maxDepthBounds, settings, "float", "maxDepthBounds", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetValidationCacheDataEXT(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkValidationCacheEXT validationCache, size_t* pDataSize, void* pData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkValidationCacheEXT>(validationCache, settings, "VkValidationCacheEXT", "validationCache", 1, dump_html_VkValidationCacheEXT);
        dump_html_pointer<const size_t>(pDataSize, settings, "size_t*", "pDataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetStencilCompareMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkStencilFaceFlags>(faceMask, settings, "VkStencilFaceFlags", "faceMask", 1, dump_html_VkStencilFaceFlags);
        dump_html_value<const uint32_t>(compareMask, settings, "uint32_t", "compareMask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkBeginCommandBuffer(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo* pBeginInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkCommandBufferBeginInfo>(pBeginInfo, settings, "const VkCommandBufferBeginInfo*", "pBeginInfo", 1, dump_html_VkCommandBufferBeginInfo, commandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyValidationCacheEXT(ApiDumpInstance& dump_inst, VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkValidationCacheEXT>(validationCache, settings, "VkValidationCacheEXT", "validationCache", 1, dump_html_VkValidationCacheEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateSwapchainKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSwapchainCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSwapchainKHR* pSwapchain)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSwapchainCreateInfoKHR>(pCreateInfo, settings, "const VkSwapchainCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkSwapchainCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSwapchainKHR>(pSwapchain, settings, "VkSwapchainKHR*", "pSwapchain", 1, dump_html_VkSwapchainKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetFenceFdKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkFenceGetFdInfoKHR* pGetFdInfo, int* pFd)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkFenceGetFdInfoKHR>(pGetFdInfo, settings, "const VkFenceGetFdInfoKHR*", "pGetFdInfo", 1, dump_html_VkFenceGetFdInfoKHR);
        dump_html_pointer<const int>(pFd, settings, "int*", "pFd", 1, dump_html_int);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateDescriptorUpdateTemplate(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDescriptorUpdateTemplateCreateInfo>(pCreateInfo, settings, "const VkDescriptorUpdateTemplateCreateInfo*", "pCreateInfo", 1, dump_html_VkDescriptorUpdateTemplateCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDescriptorUpdateTemplate>(pDescriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate*", "pDescriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkEndCommandBuffer(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetQueryPoolResults(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void* pData, VkDeviceSize stride, VkQueryResultFlags flags)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
        dump_html_value<const size_t>(dataSize, settings, "size_t", "dataSize", 1, dump_html_size_t);
        dump_html_value<const void*>(pData, settings, "void*", "pData", 1, dump_html_void);
        dump_html_value<const VkDeviceSize>(stride, settings, "VkDeviceSize", "stride", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkQueryResultFlags>(flags, settings, "VkQueryResultFlags", "flags", 1, dump_html_VkQueryResultFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyQueryPool(ApiDumpInstance& dump_inst, VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetStencilWriteMask(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkStencilFaceFlags>(faceMask, settings, "VkStencilFaceFlags", "faceMask", 1, dump_html_VkStencilFaceFlags);
        dump_html_value<const uint32_t>(writeMask, settings, "uint32_t", "writeMask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateDevice(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkDeviceCreateInfo>(pCreateInfo, settings, "const VkDeviceCreateInfo*", "pCreateInfo", 1, dump_html_VkDeviceCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDevice>(pDevice, settings, "VkDevice*", "pDevice", 1, dump_html_VkDevice);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetStencilReference(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkStencilFaceFlags>(faceMask, settings, "VkStencilFaceFlags", "faceMask", 1, dump_html_VkStencilFaceFlags);
        dump_html_value<const uint32_t>(reference, settings, "uint32_t", "reference", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkUpdateDescriptorSetWithTemplate(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void* pData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorSet>(descriptorSet, settings, "VkDescriptorSet", "descriptorSet", 1, dump_html_VkDescriptorSet);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_value<const void*>(pData, settings, "const void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateBuffer(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkBufferCreateInfo>(pCreateInfo, settings, "const VkBufferCreateInfo*", "pCreateInfo", 1, dump_html_VkBufferCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkBuffer>(pBuffer, settings, "VkBuffer*", "pBuffer", 1, dump_html_VkBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBindIndexBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkIndexType>(indexType, settings, "VkIndexType", "indexType", 1, dump_html_VkIndexType);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceExternalBufferProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalBufferInfo>(pExternalBufferInfo, settings, "const VkPhysicalDeviceExternalBufferInfo*", "pExternalBufferInfo", 1, dump_html_VkPhysicalDeviceExternalBufferInfo);
        dump_html_pointer<const VkExternalBufferProperties>(pExternalBufferProperties, settings, "VkExternalBufferProperties*", "pExternalBufferProperties", 1, dump_html_VkExternalBufferProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyDescriptorUpdateTemplate(ApiDumpInstance& dump_inst, VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkDescriptorUpdateTemplate>(descriptorUpdateTemplate, settings, "VkDescriptorUpdateTemplate", "descriptorUpdateTemplate", 1, dump_html_VkDescriptorUpdateTemplate);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyDevice(ApiDumpInstance& dump_inst, VkDevice device, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBindVertexBuffers(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer* pBuffers, const VkDeviceSize* pOffsets)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstBinding, settings, "uint32_t", "firstBinding", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(bindingCount, settings, "uint32_t", "bindingCount", 1, dump_html_uint32_t);
        dump_html_array<const VkBuffer>(pBuffers, bindingCount, settings, "const VkBuffer*", "const VkBuffer", "pBuffers", 1, dump_html_VkBuffer);
        dump_html_array<const VkDeviceSize>(pOffsets, bindingCount, settings, "const VkDeviceSize*", "const VkDeviceSize", "pOffsets", 1, dump_html_VkDeviceSize);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetSwapchainImagesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, uint32_t* pSwapchainImageCount, VkImage* pSwapchainImages)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const uint32_t>(pSwapchainImageCount, settings, "uint32_t*", "pSwapchainImageCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImage>(pSwapchainImages, *pSwapchainImageCount, settings, "VkImage*", "VkImage", "pSwapchainImages", 1, dump_html_VkImage);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkResetCommandBuffer(ApiDumpInstance& dump_inst, VkResult result, VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkCommandBufferResetFlags>(flags, settings, "VkCommandBufferResetFlags", "flags", 1, dump_html_VkCommandBufferResetFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetViewport(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport* pViewports)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstViewport, settings, "uint32_t", "firstViewport", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkViewport>(pViewports, viewportCount, settings, "const VkViewport*", "const VkViewport", "pViewports", 1, dump_html_VkViewport);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdBindPipeline(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineBindPoint>(pipelineBindPoint, settings, "VkPipelineBindPoint", "pipelineBindPoint", 1, dump_html_VkPipelineBindPoint);
        dump_html_value<const VkPipeline>(pipeline, settings, "VkPipeline", "pipeline", 1, dump_html_VkPipeline);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDraw(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(vertexCount, settings, "uint32_t", "vertexCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(instanceCount, settings, "uint32_t", "instanceCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstVertex, settings, "uint32_t", "firstVertex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstInstance, settings, "uint32_t", "firstInstance", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawIndexed(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(indexCount, settings, "uint32_t", "indexCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(instanceCount, settings, "uint32_t", "instanceCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstIndex, settings, "uint32_t", "firstIndex", 1, dump_html_uint32_t);
        dump_html_value<const int32_t>(vertexOffset, settings, "int32_t", "vertexOffset", 1, dump_html_int32_t);
        dump_html_value<const uint32_t>(firstInstance, settings, "uint32_t", "firstInstance", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetLineWidth(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float lineWidth)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const float>(lineWidth, settings, "float", "lineWidth", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceFeatures(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures* pFeatures)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceFeatures>(pFeatures, settings, "VkPhysicalDeviceFeatures*", "pFeatures", 1, dump_html_VkPhysicalDeviceFeatures);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetScissor(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D* pScissors)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstScissor, settings, "uint32_t", "firstScissor", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(scissorCount, settings, "uint32_t", "scissorCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pScissors, scissorCount, settings, "const VkRect2D*", "const VkRect2D", "pScissors", 1, dump_html_VkRect2D);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkEnumeratePhysicalDevices(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, uint32_t* pPhysicalDeviceCount, VkPhysicalDevice* pPhysicalDevices)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const uint32_t>(pPhysicalDeviceCount, settings, "uint32_t*", "pPhysicalDeviceCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDevice>(pPhysicalDevices, *pPhysicalDeviceCount, settings, "VkPhysicalDevice*", "VkPhysicalDevice", "pPhysicalDevices", 1, dump_html_VkPhysicalDevice);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetDepthBias(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const float>(depthBiasConstantFactor, settings, "float", "depthBiasConstantFactor", 1, dump_html_float);
        dump_html_value<const float>(depthBiasClamp, settings, "float", "depthBiasClamp", 1, dump_html_float);
        dump_html_value<const float>(depthBiasSlopeFactor, settings, "float", "depthBiasSlopeFactor", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceImageFormatProperties(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties* pImageFormatProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_value<const VkImageType>(type, settings, "VkImageType", "type", 1, dump_html_VkImageType);
        dump_html_value<const VkImageTiling>(tiling, settings, "VkImageTiling", "tiling", 1, dump_html_VkImageTiling);
        dump_html_value<const VkImageUsageFlags>(usage, settings, "VkImageUsageFlags", "usage", 1, dump_html_VkImageUsageFlags);
        dump_html_value<const VkImageCreateFlags>(flags, settings, "VkImageCreateFlags", "flags", 1, dump_html_VkImageCreateFlags);
        dump_html_pointer<const VkImageFormatProperties>(pImageFormatProperties, settings, "VkImageFormatProperties*", "pImageFormatProperties", 1, dump_html_VkImageFormatProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateDebugReportCallbackEXT(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkDebugReportCallbackCreateInfoEXT* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDebugReportCallbackEXT* pCallback)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkDebugReportCallbackCreateInfoEXT>(pCreateInfo, settings, "const VkDebugReportCallbackCreateInfoEXT*", "pCreateInfo", 1, dump_html_VkDebugReportCallbackCreateInfoEXT);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkDebugReportCallbackEXT>(pCallback, settings, "VkDebugReportCallbackEXT*", "pCallback", 1, dump_html_VkDebugReportCallbackEXT);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceExternalFenceProperties(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo* pExternalFenceInfo, VkExternalFenceProperties* pExternalFenceProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalFenceInfo>(pExternalFenceInfo, settings, "const VkPhysicalDeviceExternalFenceInfo*", "pExternalFenceInfo", 1, dump_html_VkPhysicalDeviceExternalFenceInfo);
        dump_html_pointer<const VkExternalFenceProperties>(pExternalFenceProperties, settings, "VkExternalFenceProperties*", "pExternalFenceProperties", 1, dump_html_VkExternalFenceProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkEnumerateDeviceExtensionProperties(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const char*>(pLayerName, settings, "const char*", "pLayerName", 1, dump_html_cstring);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkExtensionProperties>(pProperties, *pPropertyCount, settings, "VkExtensionProperties*", "VkExtensionProperties", "pProperties", 1, dump_html_VkExtensionProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkEnumerateInstanceExtensionProperties(ApiDumpInstance& dump_inst, VkResult result, const char* pLayerName, uint32_t* pPropertyCount, VkExtensionProperties* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const char*>(pLayerName, settings, "const char*", "pLayerName", 1, dump_html_cstring);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkExtensionProperties>(pProperties, *pPropertyCount, settings, "VkExtensionProperties*", "VkExtensionProperties", "pProperties", 1, dump_html_VkExtensionProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawIndexedIndirect(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(buffer, settings, "VkBuffer", "buffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(offset, settings, "VkDeviceSize", "offset", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(drawCount, settings, "uint32_t", "drawCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(stride, settings, "uint32_t", "stride", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroySwapchainKHR(ApiDumpInstance& dump_inst, VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetBlendConstants(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const float blendConstants[4])
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_array<const float>(blendConstants, 4, settings, "const float[4]", "const float", "blendConstants", 1, dump_html_float);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkAcquireNextImageKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t* pImageIndex)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSwapchainKHR>(swapchain, settings, "VkSwapchainKHR", "swapchain", 1, dump_html_VkSwapchainKHR);
        dump_html_value<const uint64_t>(timeout, settings, "uint64_t", "timeout", 1, dump_html_uint64_t);
        dump_html_value<const VkSemaphore>(semaphore, settings, "VkSemaphore", "semaphore", 1, dump_html_VkSemaphore);
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
        dump_html_pointer<const uint32_t>(pImageIndex, settings, "uint32_t*", "pImageIndex", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetFenceStatus(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkFence fence)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkFence>(fence, settings, "VkFence", "fence", 1, dump_html_VkFence);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDevicePresentRectanglesKHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t* pRectCount, VkRect2D* pRects)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const uint32_t>(pRectCount, settings, "uint32_t*", "pRectCount", 1, dump_html_uint32_t);
        dump_html_array<const VkRect2D>(pRects, *pRectCount, settings, "VkRect2D*", "VkRect2D", "pRects", 1, dump_html_VkRect2D);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkRegisterObjectsNVX(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectTableEntryNVX* const*    ppObjectTableEntries, const uint32_t* pObjectIndices)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkObjectTableNVX>(objectTable, settings, "VkObjectTableNVX", "objectTable", 1, dump_html_VkObjectTableNVX);
        dump_html_value<const uint32_t>(objectCount, settings, "uint32_t", "objectCount", 1, dump_html_uint32_t);
        dump_html_array<const uint32_t>(pObjectIndices, objectCount, settings, "const uint32_t*", "const uint32_t", "pObjectIndices", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkWaitForFences(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, uint32_t fenceCount, const VkFence* pFences, VkBool32 waitAll, uint64_t timeout)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(fenceCount, settings, "uint32_t", "fenceCount", 1, dump_html_uint32_t);
        dump_html_array<const VkFence>(pFences, fenceCount, settings, "const VkFence*", "const VkFence", "pFences", 1, dump_html_VkFence);
        dump_html_value<const VkBool32>(waitAll, settings, "VkBool32", "waitAll", 1, dump_html_VkBool32);
        dump_html_value<const uint64_t>(timeout, settings, "uint64_t", "timeout", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateObjectTableNVX(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkObjectTableCreateInfoNVX* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkObjectTableNVX* pObjectTable)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkObjectTableCreateInfoNVX>(pCreateInfo, settings, "const VkObjectTableCreateInfoNVX*", "pCreateInfo", 1, dump_html_VkObjectTableCreateInfoNVX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkObjectTableNVX>(pObjectTable, settings, "VkObjectTableNVX*", "pObjectTable", 1, dump_html_VkObjectTableNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDeviceGroupSurfacePresentModesKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR* pModes)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSurfaceKHR>(surface, settings, "VkSurfaceKHR", "surface", 1, dump_html_VkSurfaceKHR);
        dump_html_pointer<const VkDeviceGroupPresentModeFlagsKHR>(pModes, settings, "VkDeviceGroupPresentModeFlagsKHR*", "pModes", 1, dump_html_VkDeviceGroupPresentModeFlagsKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateSemaphore(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreCreateInfo>(pCreateInfo, settings, "const VkSemaphoreCreateInfo*", "pCreateInfo", 1, dump_html_VkSemaphoreCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSemaphore>(pSemaphore, settings, "VkSemaphore*", "pSemaphore", 1, dump_html_VkSemaphore);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_XCB_KHR)
std::ostream& dump_html_body_vkCreateXcbSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkXcbSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkXcbSurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkXcbSurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkXcbSurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
std::ostream& dump_html_body_vkCmdResetQueryPool(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdUpdateBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void* pData)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(dataSize, settings, "VkDeviceSize", "dataSize", 1, dump_html_VkDeviceSize);
        dump_html_value<const void*>(pData, settings, "const void*", "pData", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdEndQuery(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkUnregisterObjectsNVX(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkObjectTableNVX objectTable, uint32_t objectCount, const VkObjectEntryTypeNVX* pObjectEntryTypes, const uint32_t* pObjectIndices)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkObjectTableNVX>(objectTable, settings, "VkObjectTableNVX", "objectTable", 1, dump_html_VkObjectTableNVX);
        dump_html_value<const uint32_t>(objectCount, settings, "uint32_t", "objectCount", 1, dump_html_uint32_t);
        dump_html_array<const VkObjectEntryTypeNVX>(pObjectEntryTypes, objectCount, settings, "const VkObjectEntryTypeNVX*", "const VkObjectEntryTypeNVX", "pObjectEntryTypes", 1, dump_html_VkObjectEntryTypeNVX);
        dump_html_array<const uint32_t>(pObjectIndices, objectCount, settings, "const uint32_t*", "const uint32_t", "pObjectIndices", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateEvent(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkEventCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkEvent* pEvent)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkEventCreateInfo>(pCreateInfo, settings, "const VkEventCreateInfo*", "pCreateInfo", 1, dump_html_VkEventCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkEvent>(pEvent, settings, "VkEvent*", "pEvent", 1, dump_html_VkEvent);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDeviceQueue2(ApiDumpInstance& dump_inst, VkDevice device, const VkDeviceQueueInfo2* pQueueInfo, VkQueue* pQueue)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkDeviceQueueInfo2>(pQueueInfo, settings, "const VkDeviceQueueInfo2*", "pQueueInfo", 1, dump_html_VkDeviceQueueInfo2);
        dump_html_pointer<const VkQueue>(pQueue, settings, "VkQueue*", "pQueue", 1, dump_html_VkQueue);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkAcquireNextImage2KHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkAcquireNextImageInfoKHR* pAcquireInfo, uint32_t* pImageIndex)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkAcquireNextImageInfoKHR>(pAcquireInfo, settings, "const VkAcquireNextImageInfoKHR*", "pAcquireInfo", 1, dump_html_VkAcquireNextImageInfoKHR);
        dump_html_pointer<const uint32_t>(pImageIndex, settings, "uint32_t*", "pImageIndex", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_VI_NN)
std::ostream& dump_html_body_vkCreateViSurfaceNN(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkViSurfaceCreateInfoNN* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkViSurfaceCreateInfoNN>(pCreateInfo, settings, "const VkViSurfaceCreateInfoNN*", "pCreateInfo", 1, dump_html_VkViSurfaceCreateInfoNN);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_VI_NN
std::ostream& dump_html_body_vkDestroyObjectTableNVX(ApiDumpInstance& dump_inst, VkDevice device, VkObjectTableNVX objectTable, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkObjectTableNVX>(objectTable, settings, "VkObjectTableNVX", "objectTable", 1, dump_html_VkObjectTableNVX);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdWriteTimestamp(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineStageFlagBits>(pipelineStage, settings, "VkPipelineStageFlagBits", "pipelineStage", 1, dump_html_VkPipelineStageFlagBits);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(query, settings, "uint32_t", "query", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdFillBuffer(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(size, settings, "VkDeviceSize", "size", 1, dump_html_VkDeviceSize);
        dump_html_value<const uint32_t>(data, settings, "uint32_t", "data", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdClearColorImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue* pColor, uint32_t rangeCount, const VkImageSubresourceRange* pRanges)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(imageLayout, settings, "VkImageLayout", "imageLayout", 1, dump_html_VkImageLayout);
        dump_html_pointer<const VkClearColorValue>(pColor, settings, "const VkClearColorValue*", "pColor", 1, dump_html_VkClearColorValue);
        dump_html_value<const uint32_t>(rangeCount, settings, "uint32_t", "rangeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageSubresourceRange>(pRanges, rangeCount, settings, "const VkImageSubresourceRange*", "const VkImageSubresourceRange", "pRanges", 1, dump_html_VkImageSubresourceRange);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_XCB_KHR)
std::ostream& dump_html_body_vkGetPhysicalDeviceXcbPresentationSupportKHR(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t* connection, xcb_visualid_t visual_id)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_value<const xcb_connection_t*>(connection, settings, "xcb_", "connection", 1, dump_html_xcb_connection_t);
        dump_html_value<const xcb_visualid_t>(visual_id, settings, "xcb_visualid_t", "visual_id", 1, dump_html_xcb_visualid_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XCB_KHR
std::ostream& dump_html_body_vkCmdPushConstants(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void* pValues)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkPipelineLayout>(layout, settings, "VkPipelineLayout", "layout", 1, dump_html_VkPipelineLayout);
        dump_html_value<const VkShaderStageFlags>(stageFlags, settings, "VkShaderStageFlags", "stageFlags", 1, dump_html_VkShaderStageFlags);
        dump_html_value<const uint32_t>(offset, settings, "uint32_t", "offset", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(size, settings, "uint32_t", "size", 1, dump_html_uint32_t);
        dump_html_value<const void*>(pValues, settings, "const void*", "pValues", 1, dump_html_void);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdCopyQueryPoolResults(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkQueryPool>(queryPool, settings, "VkQueryPool", "queryPool", 1, dump_html_VkQueryPool);
        dump_html_value<const uint32_t>(firstQuery, settings, "uint32_t", "firstQuery", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(queryCount, settings, "uint32_t", "queryCount", 1, dump_html_uint32_t);
        dump_html_value<const VkBuffer>(dstBuffer, settings, "VkBuffer", "dstBuffer", 1, dump_html_VkBuffer);
        dump_html_value<const VkDeviceSize>(dstOffset, settings, "VkDeviceSize", "dstOffset", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkDeviceSize>(stride, settings, "VkDeviceSize", "stride", 1, dump_html_VkDeviceSize);
        dump_html_value<const VkQueryResultFlags>(flags, settings, "VkQueryResultFlags", "flags", 1, dump_html_VkQueryResultFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceFeatures2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2* pFeatures)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceFeatures2>(pFeatures, settings, "VkPhysicalDeviceFeatures2*", "pFeatures", 1, dump_html_VkPhysicalDeviceFeatures2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroySemaphore(ApiDumpInstance& dump_inst, VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSemaphore>(semaphore, settings, "VkSemaphore", "semaphore", 1, dump_html_VkSemaphore);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkDeviceGeneratedCommandsFeaturesNVX* pFeatures, VkDeviceGeneratedCommandsLimitsNVX* pLimits)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkDeviceGeneratedCommandsFeaturesNVX>(pFeatures, settings, "VkDeviceGeneratedCommandsFeaturesNVX*", "pFeatures", 1, dump_html_VkDeviceGeneratedCommandsFeaturesNVX);
        dump_html_pointer<const VkDeviceGeneratedCommandsLimitsNVX>(pLimits, settings, "VkDeviceGeneratedCommandsLimitsNVX*", "pLimits", 1, dump_html_VkDeviceGeneratedCommandsLimitsNVX);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdClearDepthStencilImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue* pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange* pRanges)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(image, settings, "VkImage", "image", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(imageLayout, settings, "VkImageLayout", "imageLayout", 1, dump_html_VkImageLayout);
        dump_html_pointer<const VkClearDepthStencilValue>(pDepthStencil, settings, "const VkClearDepthStencilValue*", "pDepthStencil", 1, dump_html_VkClearDepthStencilValue);
        dump_html_value<const uint32_t>(rangeCount, settings, "uint32_t", "rangeCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageSubresourceRange>(pRanges, rangeCount, settings, "const VkImageSubresourceRange*", "const VkImageSubresourceRange", "pRanges", 1, dump_html_VkImageSubresourceRange);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkSignalSemaphoreKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreSignalInfoKHR* pSignalInfo)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreSignalInfoKHR>(pSignalInfo, settings, "const VkSemaphoreSignalInfoKHR*", "pSignalInfo", 1, dump_html_VkSemaphoreSignalInfoKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceProperties2>(pProperties, settings, "VkPhysicalDeviceProperties2*", "pProperties", 1, dump_html_VkPhysicalDeviceProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetEventStatus(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkEvent event)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdNextSubpass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkSubpassContents contents)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkSubpassContents>(contents, settings, "VkSubpassContents", "contents", 1, dump_html_VkSubpassContents);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceMemoryProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceMemoryProperties2>(pMemoryProperties, settings, "VkPhysicalDeviceMemoryProperties2*", "pMemoryProperties", 1, dump_html_VkPhysicalDeviceMemoryProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdSetViewportWScalingNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV* pViewportWScalings)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(firstViewport, settings, "uint32_t", "firstViewport", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(viewportCount, settings, "uint32_t", "viewportCount", 1, dump_html_uint32_t);
        dump_html_array<const VkViewportWScalingNV>(pViewportWScalings, viewportCount, settings, "const VkViewportWScalingNV*", "const VkViewportWScalingNV", "pViewportWScalings", 1, dump_html_VkViewportWScalingNV);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceFormatProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2* pFormatProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkFormat>(format, settings, "VkFormat", "format", 1, dump_html_VkFormat);
        dump_html_pointer<const VkFormatProperties2>(pFormatProperties, settings, "VkFormatProperties2*", "pFormatProperties", 1, dump_html_VkFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkSetEvent(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkEvent event)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkReleaseDisplayEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, VkDisplayKHR display)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroyEvent(ApiDumpInstance& dump_inst, VkDevice device, VkEvent event, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceImageFormatProperties2KHR(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo, VkImageFormatProperties2* pImageFormatProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceImageFormatInfo2>(pImageFormatInfo, settings, "const VkPhysicalDeviceImageFormatInfo2*", "pImageFormatInfo", 1, dump_html_VkPhysicalDeviceImageFormatInfo2);
        dump_html_pointer<const VkImageFormatProperties2>(pImageFormatProperties, settings, "VkImageFormatProperties2*", "pImageFormatProperties", 1, dump_html_VkImageFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdClearAttachments(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment* pAttachments, uint32_t rectCount, const VkClearRect* pRects)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(attachmentCount, settings, "uint32_t", "attachmentCount", 1, dump_html_uint32_t);
        dump_html_array<const VkClearAttachment>(pAttachments, attachmentCount, settings, "const VkClearAttachment*", "const VkClearAttachment", "pAttachments", 1, dump_html_VkClearAttachment);
        dump_html_value<const uint32_t>(rectCount, settings, "uint32_t", "rectCount", 1, dump_html_uint32_t);
        dump_html_array<const VkClearRect>(pRects, rectCount, settings, "const VkClearRect*", "const VkClearRect", "pRects", 1, dump_html_VkClearRect);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
std::ostream& dump_html_body_vkCreateWaylandSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkWaylandSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkWaylandSurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkWaylandSurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkWaylandSurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
std::ostream& dump_html_body_vkCmdBeginRenderPass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo* pRenderPassBegin, VkSubpassContents contents)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_pointer<const VkRenderPassBeginInfo>(pRenderPassBegin, settings, "const VkRenderPassBeginInfo*", "pRenderPassBegin", 1, dump_html_VkRenderPassBeginInfo);
        dump_html_value<const VkSubpassContents>(contents, settings, "VkSubpassContents", "contents", 1, dump_html_VkSubpassContents);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo, uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceSparseImageFormatInfo2>(pFormatInfo, settings, "const VkPhysicalDeviceSparseImageFormatInfo2*", "pFormatInfo", 1, dump_html_VkPhysicalDeviceSparseImageFormatInfo2);
        dump_html_pointer<const uint32_t>(pPropertyCount, settings, "uint32_t*", "pPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkSparseImageFormatProperties2>(pProperties, *pPropertyCount, settings, "VkSparseImageFormatProperties2*", "VkSparseImageFormatProperties2", "pProperties", 1, dump_html_VkSparseImageFormatProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetSemaphoreCounterValueKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkSemaphore semaphore, uint64_t* pValue)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSemaphore>(semaphore, settings, "VkSemaphore", "semaphore", 1, dump_html_VkSemaphore);
        dump_html_pointer<const uint64_t>(pValue, settings, "uint64_t*", "pValue", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceQueueFamilyProperties2KHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount, VkQueueFamilyProperties2* pQueueFamilyProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const uint32_t>(pQueueFamilyPropertyCount, settings, "uint32_t*", "pQueueFamilyPropertyCount", 1, dump_html_uint32_t);
        dump_html_array<const VkQueueFamilyProperties2>(pQueueFamilyProperties, *pQueueFamilyPropertyCount, settings, "VkQueueFamilyProperties2*", "VkQueueFamilyProperties2", "pQueueFamilyProperties", 1, dump_html_VkQueueFamilyProperties2);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkResetEvent(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, VkEvent event)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkEvent>(event, settings, "VkEvent", "event", 1, dump_html_VkEvent);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_ANDROID_KHR)
std::ostream& dump_html_body_vkCreateAndroidSurfaceKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, const VkAndroidSurfaceCreateInfoKHR* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSurfaceKHR* pSurface)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const VkAndroidSurfaceCreateInfoKHR>(pCreateInfo, settings, "const VkAndroidSurfaceCreateInfoKHR*", "pCreateInfo", 1, dump_html_VkAndroidSurfaceCreateInfoKHR);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSurfaceKHR>(pSurface, settings, "VkSurfaceKHR*", "pSurface", 1, dump_html_VkSurfaceKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_ANDROID_KHR
std::ostream& dump_html_body_vkWaitSemaphoresKHR(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSemaphoreWaitInfoKHR* pWaitInfo, uint64_t timeout)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSemaphoreWaitInfoKHR>(pWaitInfo, settings, "const VkSemaphoreWaitInfoKHR*", "pWaitInfo", 1, dump_html_VkSemaphoreWaitInfoKHR);
        dump_html_value<const uint64_t>(timeout, settings, "uint64_t", "timeout", 1, dump_html_uint64_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateQueryPool(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkQueryPoolCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkQueryPool* pQueryPool)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkQueryPoolCreateInfo>(pCreateInfo, settings, "const VkQueryPoolCreateInfo*", "pCreateInfo", 1, dump_html_VkQueryPoolCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkQueryPool>(pQueryPool, settings, "VkQueryPool*", "pQueryPool", 1, dump_html_VkQueryPool);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetDeviceGroupPeerMemoryFeaturesKHR(ApiDumpInstance& dump_inst, VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags* pPeerMemoryFeatures)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const uint32_t>(heapIndex, settings, "uint32_t", "heapIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(localDeviceIndex, settings, "uint32_t", "localDeviceIndex", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(remoteDeviceIndex, settings, "uint32_t", "remoteDeviceIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const VkPeerMemoryFeatureFlags>(pPeerMemoryFeatures, settings, "VkPeerMemoryFeatureFlags*", "pPeerMemoryFeatures", 1, dump_html_VkPeerMemoryFeatureFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_WAYLAND_KHR)
std::ostream& dump_html_body_vkGetPhysicalDeviceWaylandPresentationSupportKHR(ApiDumpInstance& dump_inst, VkBool32 result, VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display* display)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkBool32(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const uint32_t>(queueFamilyIndex, settings, "uint32_t", "queueFamilyIndex", 1, dump_html_uint32_t);
        dump_html_pointer<const wl_display>(display, settings, "struct wl_", "display", 1, dump_html_wl_display);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_WAYLAND_KHR
std::ostream& dump_html_body_vkCmdSetDeviceMaskKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t deviceMask)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(deviceMask, settings, "uint32_t", "deviceMask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
std::ostream& dump_html_body_vkGetRandROutputDisplayEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, Display* dpy, RROutput rrOutput, VkDisplayKHR* pDisplay)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const Display*>(dpy, settings, "Display*", "dpy", 1, dump_html_Display);
        dump_html_value<const RROutput>(rrOutput, settings, "RROutput", "rrOutput", 1, dump_html_RROutput);
        dump_html_pointer<const VkDisplayKHR>(pDisplay, settings, "VkDisplayKHR*", "pDisplay", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
std::ostream& dump_html_body_vkTrimCommandPoolKHR(ApiDumpInstance& dump_inst, VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkCommandPool>(commandPool, settings, "VkCommandPool", "commandPool", 1, dump_html_VkCommandPool);
        dump_html_value<const VkCommandPoolTrimFlags>(flags, settings, "VkCommandPoolTrimFlags", "flags", 1, dump_html_VkCommandPoolTrimFlags);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDrawMeshTasksNV(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(taskCount, settings, "uint32_t", "taskCount", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(firstTask, settings, "uint32_t", "firstTask", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCreateSamplerYcbcrConversion(ApiDumpInstance& dump_inst, VkResult result, VkDevice device, const VkSamplerYcbcrConversionCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_pointer<const VkSamplerYcbcrConversionCreateInfo>(pCreateInfo, settings, "const VkSamplerYcbcrConversionCreateInfo*", "pCreateInfo", 1, dump_html_VkSamplerYcbcrConversionCreateInfo);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
        dump_html_pointer<const VkSamplerYcbcrConversion>(pYcbcrConversion, settings, "VkSamplerYcbcrConversion*", "pYcbcrConversion", 1, dump_html_VkSamplerYcbcrConversion);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdEndRenderPass(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#if defined(VK_USE_PLATFORM_XLIB_XRANDR_EXT)
std::ostream& dump_html_body_vkAcquireXlibDisplayEXT(ApiDumpInstance& dump_inst, VkResult result, VkPhysicalDevice physicalDevice, Display* dpy, VkDisplayKHR display)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_value<const Display*>(dpy, settings, "Display*", "dpy", 1, dump_html_Display);
        dump_html_value<const VkDisplayKHR>(display, settings, "VkDisplayKHR", "display", 1, dump_html_VkDisplayKHR);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
#endif // VK_USE_PLATFORM_XLIB_XRANDR_EXT
std::ostream& dump_html_body_vkCmdExecuteCommands(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer* pCommandBuffers)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(commandBufferCount, settings, "uint32_t", "commandBufferCount", 1, dump_html_uint32_t);
        dump_html_array<const VkCommandBuffer>(pCommandBuffers, commandBufferCount, settings, "const VkCommandBuffer*", "const VkCommandBuffer", "pCommandBuffers", 1, dump_html_VkCommandBuffer);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkEnumeratePhysicalDeviceGroupsKHR(ApiDumpInstance& dump_inst, VkResult result, VkInstance instance, uint32_t* pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    dump_html_VkResult(result, settings, 0);
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkInstance>(instance, settings, "VkInstance", "instance", 1, dump_html_VkInstance);
        dump_html_pointer<const uint32_t>(pPhysicalDeviceGroupCount, settings, "uint32_t*", "pPhysicalDeviceGroupCount", 1, dump_html_uint32_t);
        dump_html_array<const VkPhysicalDeviceGroupProperties>(pPhysicalDeviceGroupProperties, *pPhysicalDeviceGroupCount, settings, "VkPhysicalDeviceGroupProperties*", "VkPhysicalDeviceGroupProperties", "pPhysicalDeviceGroupProperties", 1, dump_html_VkPhysicalDeviceGroupProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdResolveImage(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve* pRegions)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const VkImage>(srcImage, settings, "VkImage", "srcImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(srcImageLayout, settings, "VkImageLayout", "srcImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const VkImage>(dstImage, settings, "VkImage", "dstImage", 1, dump_html_VkImage);
        dump_html_value<const VkImageLayout>(dstImageLayout, settings, "VkImageLayout", "dstImageLayout", 1, dump_html_VkImageLayout);
        dump_html_value<const uint32_t>(regionCount, settings, "uint32_t", "regionCount", 1, dump_html_uint32_t);
        dump_html_array<const VkImageResolve>(pRegions, regionCount, settings, "const VkImageResolve*", "const VkImageResolve", "pRegions", 1, dump_html_VkImageResolve);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkCmdDispatchBaseKHR(ApiDumpInstance& dump_inst, VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkCommandBuffer>(commandBuffer, settings, "VkCommandBuffer", "commandBuffer", 1, dump_html_VkCommandBuffer);
        dump_html_value<const uint32_t>(baseGroupX, settings, "uint32_t", "baseGroupX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(baseGroupY, settings, "uint32_t", "baseGroupY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(baseGroupZ, settings, "uint32_t", "baseGroupZ", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountX, settings, "uint32_t", "groupCountX", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountY, settings, "uint32_t", "groupCountY", 1, dump_html_uint32_t);
        dump_html_value<const uint32_t>(groupCountZ, settings, "uint32_t", "groupCountZ", 1, dump_html_uint32_t);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkGetPhysicalDeviceExternalBufferPropertiesKHR(ApiDumpInstance& dump_inst, VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo* pExternalBufferInfo, VkExternalBufferProperties* pExternalBufferProperties)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkPhysicalDevice>(physicalDevice, settings, "VkPhysicalDevice", "physicalDevice", 1, dump_html_VkPhysicalDevice);
        dump_html_pointer<const VkPhysicalDeviceExternalBufferInfo>(pExternalBufferInfo, settings, "const VkPhysicalDeviceExternalBufferInfo*", "pExternalBufferInfo", 1, dump_html_VkPhysicalDeviceExternalBufferInfo);
        dump_html_pointer<const VkExternalBufferProperties>(pExternalBufferProperties, settings, "VkExternalBufferProperties*", "pExternalBufferProperties", 1, dump_html_VkExternalBufferProperties);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}
std::ostream& dump_html_body_vkDestroySamplerYcbcrConversion(ApiDumpInstance& dump_inst, VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks* pAllocator)
{ 
    const ApiDumpSettings& settings(dump_inst.settings());
    settings.stream() << "</summary>";

    if(settings.showParams())
    {
        dump_html_value<const VkDevice>(device, settings, "VkDevice", "device", 1, dump_html_VkDevice);
        dump_html_value<const VkSamplerYcbcrConversion>(ycbcrConversion, settings, "VkSamplerYcbcrConversion", "ycbcrConversion", 1, dump_html_VkSamplerYcbcrConversion);
        dump_html_pointer<const VkAllocationCallbacks>(pAllocator, settings, "const VkAllocationCallbacks*", "pAllocator", 1, dump_html_VkAllocationCallbacks);
    }
    settings.shouldFlush() ? settings.stream() << std::endl : settings.stream() << "\n";

    return settings.stream() << "</details>";
}


