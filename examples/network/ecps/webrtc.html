<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ECPS WebRTC Stream - Universal</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #000;
      color: white;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    canvas {
      width: 100%;
      max-width: 1280px;
      height: auto;
      background: #000;
      border: 1px solid #333;
    }

    video {
      width: 100%;
      max-width: 1280px;
      height: auto;
      background: #000;
      border: 1px solid #333;
      display: none;
    }

    .stats {
      margin: 10px 0;
      font-size: 14px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
    }

    .controls {
      margin: 10px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }

    button {
      padding: 10px 20px;
      background: #333;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      transition: background 0.2s;
    }

      button:hover {
        background: #555;
      }

      button:disabled {
        background: #222;
        color: #666;
        cursor: not-allowed;
      }

    .status-good {
      color: #0f0;
    }

    .status-warning {
      color: #ff0;
    }

    .status-error {
      color: #f00;
    }

    pre#debug {
      background: #111;
      color: lime;
      padding: 10px;
      font-size: 11px;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #333;
      border-radius: 4px;
    }

    .performance-info {
      background: #1a1a1a;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
      border-left: 3px solid #0f0;
    }

    .decoder-details {
      font-size: 12px;
      opacity: 0.8;
      margin-top: 5px;
    }

    .browser-warning {
      background: #ff6600;
      color: white;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <h1>ECPS WebRTC Stream - Universal Browser Support</h1>

  <div id="browser-warning" class="browser-warning" style="display: none;">
    <strong>Limited Browser Support Detected!</strong><br>
    For best performance, use Chrome 94+ or Edge 94+.<br>
    Current mode: Fallback rendering (software decoding)
  </div>

  <canvas id="video" width="1280" height="720"></canvas>
  <video id="video-element" controls muted></video>

  <div class="performance-info">
    <div id="status">Status: Checking browser compatibility...</div>
    <div class="decoder-details" id="decoder-info">Decoder: Initializing...</div>
    <div class="decoder-details" id="browser-info">Browser: Detecting...</div>
  </div>

  <div class="stats">
    <div id="fps">FPS: 0</div>
    <div id="bitrate">Bitrate: 0 kbps</div>
    <div id="frame-counter">Frames: 0</div>
    <div id="decode-mode">Mode: Unknown</div>
  </div>

  <div class="controls">
    <button id="connect-btn" onclick="connect()">Connect</button>
    <button id="disconnect-btn" onclick="disconnect()" disabled>Disconnect</button>
    <button id="request-keyframe-btn" onclick="requestKeyframe()" disabled>Request Keyframe</button>
    <button id="clear-debug" onclick="clearDebug()">Clear Log</button>
    <button id="toggle-mode" onclick="toggleDecodingMode()">Switch Mode</button>
  </div>

  <pre id="debug">Debug log:
</pre>

  <script>
    // Browser detection and compatibility
    const browserInfo = {
      isChrome: /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor),
      isEdge: /Edg/.test(navigator.userAgent),
      isFirefox: /Firefox/.test(navigator.userAgent),
      isSafari: /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent),
      hasWebCodecs: typeof VideoDecoder !== 'undefined',
      hasMediaSource: 'MediaSource' in window,
      hasWebRTC: 'RTCPeerConnection' in window
    };

    // Global state
    let ws = null;
    let decoder = null;
    let isConfigured = false;
    let frameCount = 0;
    let lastFrameTime = 0;
    let bytesReceived = 0;
    let lastBitrateTime = 0;
    let isFirstFrame = true;
    let decodingMode = 'auto'; // 'webcodecs', 'canvas', 'auto'
    let mediaSource = null;
    let sourceBuffer = null;

    // UI Elements
    const canvas = document.getElementById('video');
    const videoElement = document.getElementById('video-element');
    const ctx = canvas.getContext('2d');
    const statusEl = document.getElementById('status');
    const decoderEl = document.getElementById('decoder-info');
    const browserInfoEl = document.getElementById('browser-info');
    const debugEl = document.getElementById('debug');
    const connectBtn = document.getElementById('connect-btn');
    const disconnectBtn = document.getElementById('disconnect-btn');
    const keyframeBtn = document.getElementById('request-keyframe-btn');
    const fpsEl = document.getElementById('fps');
    const bitrateEl = document.getElementById('bitrate');
    const frameCounterEl = document.getElementById('frame-counter');
    const decodeModeEl = document.getElementById('decode-mode');
    const browserWarning = document.getElementById('browser-warning');

    function debug(msg) {
      const timestamp = new Date().toLocaleTimeString();
      debugEl.textContent += `[${timestamp}] ${msg}\n`;
      debugEl.scrollTop = debugEl.scrollHeight;
      console.log(`[WebRTC] ${msg}`);
    }

    function clearDebug() {
      debugEl.textContent = 'Debug log:\n';
    }

    function updateStatus(status, className = '') {
      statusEl.textContent = `Status: ${status}`;
      statusEl.className = className;
    }

    function detectBrowser() {
      let browserName = 'Unknown';
      let version = 'Unknown';

      if (browserInfo.isChrome) {
        browserName = 'Chrome';
        const match = navigator.userAgent.match(/Chrome\/(\d+)/);
        version = match ? match[1] : 'Unknown';
      } else if (browserInfo.isEdge) {
        browserName = 'Edge';
        const match = navigator.userAgent.match(/Edg\/(\d+)/);
        version = match ? match[1] : 'Unknown';
      } else if (browserInfo.isFirefox) {
        browserName = 'Firefox';
        const match = navigator.userAgent.match(/Firefox\/(\d+)/);
        version = match ? match[1] : 'Unknown';
      } else if (browserInfo.isSafari) {
        browserName = 'Safari';
        const match = navigator.userAgent.match(/Version\/(\d+)/);
        version = match ? match[1] : 'Unknown';
      }

      browserInfoEl.textContent = `Browser: ${browserName} ${version}`;

      // Show warning for unsupported browsers
      if (!browserInfo.hasWebCodecs) {
        browserWarning.style.display = 'block';
        debug(`Browser ${browserName} ${version} - WebCodecs: Not supported`);
      } else {
        debug(`Browser ${browserName} ${version} - WebCodecs: Supported`);
      }

      return { name: browserName, version: parseInt(version) };
    }

    function selectBestDecodingMode() {
      if (decodingMode === 'auto') {
        if (browserInfo.hasWebCodecs) {
          return 'webcodecs';
        } else if (browserInfo.hasMediaSource) {
          return 'mediasource';
        } else {
          return 'canvas';
        }
      }
      return decodingMode;
    }

    function toggleDecodingMode() {
      const modes = ['auto', 'webcodecs', 'canvas'];
      const currentIndex = modes.indexOf(decodingMode);
      decodingMode = modes[(currentIndex + 1) % modes.length];

      debug(`Switched to decoding mode: ${decodingMode}`);
      decodeModeEl.textContent = `Mode: ${decodingMode}`;

      // Reconfigure if connected
      if (ws && ws.readyState === WebSocket.OPEN) {
        configureDecoder();
      }
    }

    async function configureDecoder() {
      const mode = selectBestDecodingMode();
      decodeModeEl.textContent = `Mode: ${mode}`;

      try {
        // Clean up existing decoder
        if (decoder && decoder.state !== 'closed') {
          decoder.close();
          decoder = null;
        }

        if (mode === 'webcodecs' && browserInfo.hasWebCodecs) {
          await configureWebCodecsDecoder();
        } else if (mode === 'mediasource' && browserInfo.hasMediaSource) {
          configureMediaSourceDecoder();
        } else {
          configureCanvasDecoder();
        }

      } catch (e) {
        debug(`Decoder configuration failed: ${e.message}`);
        decoderEl.textContent = 'Decoder: Configuration failed';

        // Fallback to canvas mode
        if (mode !== 'canvas') {
          debug('Falling back to canvas decoding...');
          configureCanvasDecoder();
        }
      }
    }

    async function configureWebCodecsDecoder() {
      decoder = new VideoDecoder({
        output: frame => {
          try {
            ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
            updateFPS();
            frame.close();
          } catch (e) {
            debug(`Frame render error: ${e.message}`);
            frame.close();
          }
        },
        error: e => {
          debug(`WebCodecs decoder error: ${e.message}`);
          isConfigured = false;
          setTimeout(() => requestKeyframe(), 100);
        }
      });

      const config = {
        codec: 'avc1.42E01E',
        codedWidth: 1280,
        codedHeight: 720,
        hardwareAcceleration: 'prefer-hardware'
      };

      const support = await VideoDecoder.isConfigSupported(config);
      if (support.supported) {
        decoder.configure(config);
        isConfigured = true;
        decoderEl.textContent = `Decoder: WebCodecs (${config.codec})`;
        debug('WebCodecs decoder configured successfully');
      } else {
        throw new Error('WebCodecs configuration not supported');
      }
    }

    function configureMediaSourceDecoder() {
      // Skip MediaSource for now - it's complex to implement properly for raw H.264
      debug('MediaSource mode attempted, falling back to canvas mode');
      configureCanvasDecoder();
    }

    function configureCanvasDecoder() {
      // Fallback: display raw frame data or error message
      canvas.style.display = 'block';
      videoElement.style.display = 'none';

      isConfigured = true;
      decoderEl.textContent = 'Decoder: Canvas Fallback (Limited)';
      debug('Using canvas fallback - limited functionality');

      // Clear canvas and show message
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('Canvas Fallback Mode', canvas.width / 2, canvas.height / 2 - 20);
      ctx.font = '14px Arial';
      ctx.fillText('Limited decoding support - upgrade browser for full functionality', canvas.width / 2, canvas.height / 2 + 20);
    }

    function updateFPS() {
      const now = performance.now();
      if (lastFrameTime > 0) {
        const fps = 1000 / (now - lastFrameTime);
        fpsEl.textContent = `FPS: ${fps.toFixed(1)}`;
      }
      lastFrameTime = now;
      frameCount++;
      frameCounterEl.textContent = `Frames: ${frameCount}`;
    }

    function updateBitrate(bytes) {
      bytesReceived += bytes;
      const now = performance.now();
      if (lastBitrateTime > 0 && (now - lastBitrateTime) >= 1000) {
        const kbps = (bytesReceived * 8) / 1000;
        bitrateEl.textContent = `Bitrate: ${kbps.toFixed(0)} kbps`;
        bytesReceived = 0;
        lastBitrateTime = now;
      } else if (lastBitrateTime === 0) {
        lastBitrateTime = now;
      }
    }

    function requestKeyframe() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'request_keyframe' }));
        debug('Keyframe requested from server');
      }
    }

    function connect() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        debug('Already connected');
        return;
      }

      debug('Connecting to WebSocket server...');
      updateStatus('Connecting...', 'status-warning');

      try {
        ws = new WebSocket('ws://176.93.69.239:9091');
        ws.binaryType = 'arraybuffer';

        ws.onopen = async () => {
          updateStatus('Connected', 'status-good');
          connectBtn.disabled = true;
          disconnectBtn.disabled = false;
          keyframeBtn.disabled = false;
          debug('WebSocket connected successfully');

          await configureDecoder();
          setTimeout(() => requestKeyframe(), 500);
        };

        ws.onerror = e => {
          updateStatus('Connection Error', 'status-error');
          debug('WebSocket connection error');
        };

        ws.onclose = (e) => {
          updateStatus('Disconnected', 'status-error');
          connectBtn.disabled = false;
          disconnectBtn.disabled = true;
          keyframeBtn.disabled = true;
          debug(`WebSocket closed (code: ${e.code})`);

          if (decoder && typeof decoder.close === 'function') {
            decoder.close();
          }
          isConfigured = false;
          isFirstFrame = true;
        };

        ws.onmessage = async (e) => {
          try {
            if (e.data instanceof ArrayBuffer) {
              const data = new Uint8Array(e.data);

              // Handle different header formats for compatibility
              let frameData, isKeyframe, pts;

              if (data.length >= 13) {
                // New format: [1 byte flags][8 bytes pts][4 bytes frame_size][data...]
                const flags = data[0];
                isKeyframe = (flags & 0x01) !== 0;

                pts = 0;
                for (let i = 0; i < 8; i++) {
                  pts = (pts << 8) | data[1 + i];
                }

                let frameSize = 0;
                for (let i = 0; i < 4; i++) {
                  frameSize = (frameSize << 8) | data[9 + i];
                }

                frameData = data.slice(13);

                if (frameData.length !== frameSize) {
                  debug(`Frame size mismatch: expected ${frameSize}, got ${frameData.length}`);
                  requestKeyframe();
                  return;
                }
              } else if (data.length >= 5) {
                // Old format: [1 byte flags][4 bytes frame_size][data...]
                const flags = data[0];
                isKeyframe = (flags & 0x01) !== 0;
                pts = performance.now() * 1000;
                frameData = data.slice(5);
              } else {
                debug('Invalid frame: too small');
                return;
              }

              updateBitrate(frameData.length);

              if ((isFirstFrame || !isConfigured) && !isKeyframe) {
                debug('Waiting for keyframe...');
                requestKeyframe();
                return;
              }

              if (!isConfigured) {
                if (isKeyframe) {
                  await configureDecoder();
                  if (!isConfigured) {
                    requestKeyframe();
                    return;
                  }
                } else {
                  requestKeyframe();
                  return;
                }
              }

              // Decode based on current mode
              const mode = selectBestDecodingMode();

              if (mode === 'webcodecs' && decoder && decoder.decode) {
                try {
                  const chunk = new EncodedVideoChunk({
                    type: isKeyframe ? 'key' : 'delta',
                    timestamp: pts,
                    data: frameData
                  });
                  decoder.decode(chunk);

                  if (isFirstFrame && isKeyframe) {
                    isFirstFrame = false;
                    debug('First keyframe decoded');
                  }
                } catch (decodeError) {
                  debug(`Decode error: ${decodeError.message}`);
                  requestKeyframe();
                }
              } else if (mode === 'mediasource' && sourceBuffer) {
                try {
                  if (!sourceBuffer.updating) {
                    sourceBuffer.appendBuffer(frameData);
                    updateFPS();
                  }
                } catch (e) {
                  debug(`MediaSource append error: ${e.message}`);
                }
              } else {
                // Canvas fallback - just show we're receiving data
                updateFPS();
                debug(`Received ${frameData.length} bytes (canvas mode)`);
              }

            } else {
              const d = JSON.parse(e.data);
              if (d.type === 'request_keyframe') {
                debug('Server acknowledged keyframe request');
              }
            }
          } catch (err) {
            debug(`Message error: ${err.message}`);
          }
        };

      } catch (err) {
        debug(`Failed to create WebSocket: ${err.message}`);
        updateStatus('Connection Failed', 'status-error');
      }
    }

    function disconnect() {
      if (ws) {
        ws.close();
        debug('Disconnect requested');
      }
    }

    // Initialize on page load
    window.addEventListener('load', () => {
      const browser = detectBrowser();
      debug(`Browser detected: ${browser.name} ${browser.version}`);
      debug(`WebCodecs support: ${browserInfo.hasWebCodecs ? 'Yes' : 'No'}`);
      debug(`MediaSource support: ${browserInfo.hasMediaSource ? 'Yes' : 'No'}`);

      updateStatus('Ready to connect', 'status-good');
      decoderEl.textContent = 'Decoder: Ready';

      // Auto-select best mode
      const bestMode = selectBestDecodingMode();
      decodeModeEl.textContent = `Mode: ${bestMode}`;
      debug(`Selected decoding mode: ${bestMode}`);
    });

    debug('Universal WebRTC client loaded');
  </script>
</body>
</html>