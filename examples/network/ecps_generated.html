<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Screen Share Client</title>
    <link rel="stylesheet" href="client-styles.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">üé• ScreenShare Fixed</div>
            <div class="connection-status">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Disconnected</span>
            </div>
        </div>

        <div class="main-content">
            <div class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <h3>Connection</h3>
                </div>
                <div class="sidebar-content">
                    <div class="form-group">
                        <label class="form-label">Server IP</label>
                        <input type="text" class="form-input" id="serverIp" placeholder="localhost" value="localhost">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Port</label>
                        <input type="number" class="form-input" id="serverPort" placeholder="43255" value="43255">
                    </div>
                    <div class="form-group">
                        <button class="btn primary" id="connectBtn">Connect</button>
                        <button class="btn danger" id="disconnectBtn" disabled>Disconnect</button>
                    </div>

                    <div id="channelsSection" style="display: none;">
                        <h4>Channels</h4>
                        <div style="margin-bottom: 10px;">
                            <button class="btn" id="refreshChannels">Refresh</button>
                            <button class="btn" id="createChannel">Create</button>
                        </div>
                        <div class="channels-list" id="channelsList">
                            <div class="channel-item">Click Refresh to load channels...</div>
                        </div>
                        
                        <div class="stream-controls" id="streamControls" style="display: none;">
                            <h4>üé¨ Stream Controls</h4>
                            <button class="btn streaming" id="startStreamBtn">üì° Start Stream</button>
                            <button class="btn danger" id="stopStreamBtn" style="display: none;">‚èπÔ∏è Stop Stream</button>
                            <button class="btn" id="requestIDRBtn">üîÑ Request IDR Frame</button>
                            <div style="margin-top: 10px; font-size: 12px; opacity: 0.8;">
                                Stream from your C++ client to see video here
                            </div>
                        </div>
                    </div>

                    <div class="protocol-status">
                        <div>
                            <strong>Session ID:</strong>
                            <span id="sessionId">0</span>
                        </div>
                        <div>
                            <strong>Command ID:</strong>
                            <span id="commandId">0</span>
                        </div>
                        <div>
                            <strong>Channels:</strong>
                            <span id="channelCount">0</span>
                        </div>
                        <div>
                            <strong>Selected:</strong>
                            <span id="selectedChannel">None</span>
                        </div>
                    </div>

                    <div class="logs" id="logs">
                        <div class="log-entry info">Fixed client ready to connect...</div>
                    </div>
                </div>
            </div>

            <div class="video-container">
                <div class="video-wrapper">
                    <div class="video-overlay" id="videoOverlay">
                        <div class="placeholder-icon">üì∫</div>
                        <h3>No Stream Active</h3>
                        <p>Connect to a server and join a channel to view streams</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class FixedScreenShareClient {

            initializeEventListeners() {
                document.getElementById('connectBtn').addEventListener('click', () => this.connect());
                document.getElementById('disconnectBtn').addEventListener('click', () => this.disconnect());
                document.getElementById('refreshChannels').addEventListener('click', () => this.requestChannelList());
                document.getElementById('createChannel').addEventListener('click', () => this.createChannel());
            }

            updateUI() {
                document.getElementById('sessionId').textContent = this.sessionId;
                document.getElementById('commandId').textContent = this.commandId;
                document.getElementById('channelCount').textContent = this.channels.length;
                document.getElementById('selectedChannel').textContent = 
                    this.selectedChannelId !== null ? this.selectedChannelId : 'None';
            }

            async connect() {
                const serverIp = document.getElementById('serverIp').value;
                const serverPort = document.getElementById('serverPort').value;
                
                try {
                    this.log('Connecting to ' + serverIp + ':' + serverPort + '...', 'info');
                    
                    this.ws = new WebSocket('ws://' + serverIp + ':' + serverPort);
                    this.ws.binaryType = 'arraybuffer';
                    
                    this.ws.onopen = () => {
                        this.log('Connected to proxy server', 'success');
                        this.updateConnectionStatus(true);
                        this.startKeepAlive();
                        this.login();
                    };
                    
                    this.ws.onmessage = async (event) => {
                        let data;
                        if (event.data instanceof ArrayBuffer) {
                            data = event.data;
                        } else if (event.data instanceof Blob) {
                            data = await event.data.arrayBuffer();
                        } else {
                            this.log('Unexpected data type: ' + typeof event.data, 'error');
                            return;
                        }
                        this.handleMessage(data);
                    };
                    
                    this.ws.onclose = (event) => {
                        this.log('Connection closed: Code ' + event.code, 'error');
                        this.updateConnectionStatus(false);
                        this.stopKeepAlive();
                    };
                    
                    this.ws.onerror = (error) => {
                        this.log('Connection error. Is the proxy server running?', 'error');
                        this.updateConnectionStatus(false);
                        this.stopKeepAlive();
                    };
                    
                } catch (error) {
                    this.log('Connection failed: ' + error, 'error');
                }
            }

            disconnect() {
                this.stopKeepAlive();
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                this.updateConnectionStatus(false);
                this.log('Disconnected', 'info');
            }

            startKeepAlive() {
                // Send keepalive every 25 seconds to prevent timeout
                this.keepAliveInterval = setInterval(() => {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.sendTCPMessage(this.Protocol.C2S.KeepAlive, null);
                        this.log('üíì Sent keepalive', 'info');
                    }
                }, 25000);
            }

            stopKeepAlive() {
                if (this.keepAliveInterval) {
                    clearInterval(this.keepAliveInterval);
                    this.keepAliveInterval = null;
                }
            }

            updateConnectionStatus(connected) {
                this.isConnected = connected;
                const indicator = document.getElementById('statusIndicator');
                const statusText = document.getElementById('statusText');
                const connectBtn = document.getElementById('connectBtn');
                const disconnectBtn = document.getElementById('disconnectBtn');
                const channelsSection = document.getElementById('channelsSection');
                
                if (connected) {
                    indicator.classList.add('connected');
                    statusText.textContent = 'Connected';
                    connectBtn.disabled = true;
                    disconnectBtn.disabled = false;
                    channelsSection.style.display = 'block';
                } else {
                    indicator.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                    connectBtn.disabled = false;
                    disconnectBtn.disabled = true;
                    channelsSection.style.display = 'none';
                    
                    // Reset state
                    this.sessionId = 0;
                    this.selectedChannelId = null;
                    this.channels = [];
                    this.commandId = 0;
                    this.streamStats = null;
                }
                this.updateUI();
            }

            sendTCPMessage(command, data) {
                if (!data) {
                    data = new ArrayBuffer(0);
                }
                
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    this.log('Cannot send message: not connected', 'error');
                    return false;
                }

                // Create proper header
                const totalSize = 6 + data.byteLength;
                const message = new ArrayBuffer(totalSize);
                const messageView = new DataView(message);
                
                // Write header with correct byte order
                messageView.setUint32(0, this.commandId++, true); // ID - little endian
                messageView.setUint16(4, command, true); // Command - little endian
                
                // Copy payload if any
                if (data.byteLength > 0) {
                    const payloadView = new Uint8Array(message, 6);
                    payloadView.set(new Uint8Array(data));
                }

                this.ws.send(message);
                
                if (command !== 0) { // Don't log keepalives
                    const debugBytes = Array.from(new Uint8Array(message))
                        .slice(0, Math.min(20, message.byteLength))
                        .map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                    this.log('Sent command ' + command + ' (' + message.byteLength + ' bytes): ' + debugBytes + '...', 'info');
                }
                
                this.updateUI();
                return true;
            }

            login() {
                const data = new ArrayBuffer(1);
                const view = new DataView(data);
                view.setUint8(0, this.Protocol.LoginType.Anonymous);
                
                this.sendTCPMessage(this.Protocol.C2S.Request_Login, data);
                this.log('Sent login request', 'info');
            }

            requestChannelList() {
                const data = new ArrayBuffer(1); // Padding byte as required by server
                this.sendTCPMessage(this.Protocol.C2S.RequestChannelList, data);
                this.log('Requested channel list', 'info');
            }

            createChannel() {
                const data = new ArrayBuffer(1);
                const view = new DataView(data);
                view.setUint8(0, this.Protocol.ChannelType.ScreenShare);
                
                this.sendTCPMessage(this.Protocol.C2S.CreateChannel, data);
                this.log('Creating channel...', 'info');
            }

            joinChannel(channelId) {
                this.log('Attempting to join channel ' + channelId + '...', 'info');
                
                const data = new ArrayBuffer(2);
                const view = new DataView(data);
                view.setUint16(0, channelId, true);
                
                this.sendTCPMessage(this.Protocol.C2S.JoinChannel, data);
                this.selectedChannelId = channelId;
                this.updateUI();
                this.log('Sent join request for channel ' + channelId, 'info');
            }

            handleMessage(data) {
                if (data.byteLength < 50) { // Only log smaller packets to avoid spam
                    const bytes = Array.from(new Uint8Array(data, 0, Math.min(10, data.byteLength)))
                        .map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
                    this.log('Received ' + data.byteLength + ' bytes: ' + bytes + '...', 'info');
                }
                
                // Check if this is UDP stream data (starts with 0xFF marker from proxy)
                if (data.byteLength > 16) { // UDP packets should be reasonably large
                    const dataArray = new Uint8Array(data);
                    if (dataArray[0] === 0xFF) {
                        // This is UDP stream data - remove marker and process
                        const udpData = data.slice(1);
                        this.log('üé¨ UDP stream data detected: ' + udpData.byteLength + ' bytes', 'success');
                        this.handleUDPStreamData(udpData);
                        return;
                    }
                }
                
                // Regular TCP protocol data - add to buffer and process
                this.addToBuffer(data);
                this.processBuffer();
            }
            
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.sessionId = 0;
                this.selectedChannelId = null;
                this.channels = [];
                this.commandId = 0;
                this.streamStats = null;
                this.keepAliveInterval = null;
                this.isStreamActive = false;
                
                // Add message buffer for handling TCP stream
                this.messageBuffer = new Uint8Array(0);
                
                // Protocol constants - FIXED to match C++ backend exactly
                this.Protocol = {
                    C2S: {
                        KeepAlive: 0,
                        Request_Login: 1,
                        CreateChannel: 2,
                        JoinChannel: 3,
                        QuitChannel: 4,
                        Response_UDPIdentifySecret: 5,
                        RequestChannelList: 6,
                        RequestChannelSessionList: 7,
                        Channel_ScreenShare_ViewToShare: 8
                    },
                    S2C: {
                        KeepAlive: 0,
                        InformInvalidIdentify: 1,
                        Response_Login: 2,
                        CreateChannel_OK: 3,
                        CreateChannel_Error: 4,
                        JoinChannel_OK: 5,
                        JoinChannel_Error: 6,
                        KickedFromChannel: 7,
                        Request_UDPIdentifySecret: 8,
                        UseThisUDPIdentifySecret: 9,
                        ChannelList: 10,
                        ChannelSessionList: 11,
                        Channel_ScreenShare_ViewToShare: 12
                    },
                    ChannelType: {
                        ScreenShare: 0
                    },
                    LoginType: {
                        Anonymous: 0
                    }
                };

                this.initializeEventListeners();
                this.updateUI();
                this.log('Fixed client initialized with buffer handling', 'success');
            }
            
            
            startStream() {
                this.isStreamActive = true;
                this.updateStreamControls();
                this.log('Stream started - waiting for video data from C++ client', 'success');
                
                // Request IDR frame to start fresh
                this.requestIDRFrame();
                
                // Also send a test message to see if we get any stream data
                setTimeout(() => {
                    if (this.streamStats === null) {
                        this.log('‚ö†Ô∏è No stream data received yet. Make sure:', 'info');
                        this.log('1. C++ client is streaming to this channel', 'info');
                        this.log('2. Proxy server is running and handling UDP', 'info');
                        this.log('3. Try requesting IDR frame again', 'info');
                    }
                }, 5000);
            }
            
            stopStream() {
                this.isStreamActive = false;
                this.updateStreamControls();
                this.streamStats = null;
                
                // Hide stream visualization
                const streamViz = document.querySelector('.stream-visualization');
                if (streamViz) {
                    streamViz.remove();
                }
                
                // Show overlay again
                const videoOverlay = document.getElementById('videoOverlay');
                if (videoOverlay) {
                    videoOverlay.classList.remove('hidden');
                }
                
                this.log('Stream stopped', 'info');
            }
            
            requestIDRFrame() {
                if (this.selectedChannelId !== null && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const data = new ArrayBuffer(4);
                    const view = new DataView(data);
                    view.setUint16(0, this.selectedChannelId, true); // Channel ID
                    view.setUint16(2, 0x02, true); // ResetIDR flag
                    
                    this.sendTCPMessage(this.Protocol.C2S.Channel_ScreenShare_ViewToShare, data);
                    this.log('Requested IDR frame from server', 'info');
                } else {
                    this.log('Cannot request IDR frame: not connected to channel', 'error');
                }
            }
            
            updateStreamControls() {
                const startBtn = document.getElementById('startStreamBtn');
                const stopBtn = document.getElementById('stopStreamBtn');
                
                if (this.isStreamActive) {
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                } else {
                    startBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                }
            }

            addToBuffer(data) {
                // Append new data to buffer
                const newData = new Uint8Array(data);
                const combinedBuffer = new Uint8Array(this.messageBuffer.length + newData.length);
                combinedBuffer.set(this.messageBuffer);
                combinedBuffer.set(newData, this.messageBuffer.length);
                this.messageBuffer = combinedBuffer;
            }
            
            processBuffer() {
                while (this.messageBuffer.length >= 6) { // Minimum header size
                    // Read message header
                    const view = new DataView(this.messageBuffer.buffer, this.messageBuffer.byteOffset);
                    const id = view.getUint32(0, true);
                    const command = view.getUint16(4, true);
                    
                    // Validate command range first - be more permissive for unknown commands
                    if (command > 50) {
                        this.log('Potentially invalid command: ' + command + ', trying to resync...', 'error');
                        // Try to find next valid message start instead of clearing entire buffer
                        let found = false;
                        for (let i = 1; i < this.messageBuffer.length - 6; i++) {
                            const testView = new DataView(this.messageBuffer.buffer, this.messageBuffer.byteOffset + i);
                            const testCommand = testView.getUint16(4, true);
                            if (testCommand >= 0 && testCommand <= 20) {
                                this.log('Found potential message at offset ' + i, 'info');
                                this.messageBuffer = this.messageBuffer.slice(i);
                                found = true;
                                break;
                            }
                        }
                        if (!found) {
                            this.log('No valid message found, clearing buffer', 'error');
                            this.messageBuffer = new Uint8Array(0);
                        }
                        break;
                    }
                    
                    // Determine expected payload size
                    let payloadSize = this.getExpectedPayloadSize(command);
                    
                    if (payloadSize === -1) {
                        // Variable size message
                        payloadSize = this.getVariablePayloadSize(command);
                        if (payloadSize === -1) {
                            // Don't have enough data yet
                            break;
                        }
                    }
                    
                    const totalSize = 6 + payloadSize;
                    
                    if (this.messageBuffer.length < totalSize) {
                        // Don't have complete message yet
                        break;
                    }
                    
                    // Extract complete message
                    const messageData = this.messageBuffer.slice(0, totalSize);
                    const payload = this.messageBuffer.slice(6, totalSize);
                    
                    if (command !== 0 && totalSize < 100) { // Don't log keepalives and large messages
                        this.log('Parsed message: ID=' + id + ', Command=' + command + ', Payload=' + payload.length + ' bytes', 'info');
                    }
                    
                    // Process the message
                    this.processCompleteMessage(id, command, payload.buffer.slice(payload.byteOffset, payload.byteOffset + payload.byteLength));
                    
                    // Remove processed message from buffer
                    this.messageBuffer = this.messageBuffer.slice(totalSize);
                }
            }
            
            getExpectedPayloadSize(command) {
                switch (command) {
                    case 0: return 0;  // KeepAlive
                    case 1: return 16; // InformInvalidIdentify
                    case 2: return 8;  // Response_Login
                    case 3: return 7;  // CreateChannel_OK
                    case 4: return 1;  // CreateChannel_Error
                    case 5: return 7;  // JoinChannel_OK
                    case 6: return 1;  // JoinChannel_Error
                    case 7: return 3;  // KickedFromChannel
                    case 8: return 0;  // Request_UDPIdentifySecret
                    case 9: return 8;  // UseThisUDPIdentifySecret
                    case 12: return 4; // Channel_ScreenShare_ViewToShare
                    case 10: // ChannelList - variable
                    case 11: // ChannelSessionList - variable
                        return -1;
                    default:
                        this.log('Unknown command: ' + command + ', assuming no payload', 'error');
                        return 0;
                }
            }
            
            getVariablePayloadSize(command) {
                if (command === 10) { // ChannelList
                    if (this.messageBuffer.length < 8) return -1; // Need at least header + count
                    
                    const view = new DataView(this.messageBuffer.buffer, this.messageBuffer.byteOffset + 6);
                    const channelCount = view.getUint16(0, true);
                    const expectedSize = 2 + (channelCount * 76);
                    
                    if (this.messageBuffer.length < 6 + expectedSize) return -1;
                    return expectedSize;
                }
                
                if (command === 11) { // ChannelSessionList
                    if (this.messageBuffer.length < 10) return -1; // Need at least header + channelId + count
                    
                    const view = new DataView(this.messageBuffer.buffer, this.messageBuffer.byteOffset + 6);
                    const sessionCount = view.getUint16(2, true);
                    const expectedSize = 4 + (sessionCount * 48);
                    
                    if (this.messageBuffer.length < 6 + expectedSize) return -1;
                    return expectedSize;
                }
                
                return -1;
            }

            handleUDPStreamData(data) {
                // Handle incoming video stream data
                this.log('Processing stream data: ' + data.byteLength + ' bytes', 'info');
                
                try {
                    // Show live stream visualization
                    const videoOverlay = document.getElementById('videoOverlay');
                    if (videoOverlay) {
                        videoOverlay.classList.add('hidden');
                        
                        // Create or update stream visualization
                        let streamViz = document.querySelector('.stream-visualization');
                        if (!streamViz) {
                            streamViz = document.createElement('div');
                            streamViz.className = 'stream-visualization';
                            document.querySelector('.video-wrapper').appendChild(streamViz);
                        }
                        
                        // Update stream stats
                        if (!this.streamStats) {
                            this.streamStats = { 
                                totalBytes: 0, 
                                packets: 0, 
                                startTime: Date.now(),
                                lastUpdate: Date.now(),
                                largePackets: 0,
                                maxPacketSize: 0
                            };
                        }
                        
                        this.streamStats.totalBytes += data.byteLength;
                        this.streamStats.packets++;
                        this.streamStats.lastUpdate = Date.now();
                        
                        // Track packet sizes
                        if (data.byteLength > this.streamStats.maxPacketSize) {
                            this.streamStats.maxPacketSize = data.byteLength;
                        }
                        if (data.byteLength > 500) {
                            this.streamStats.largePackets++;
                        }
                        
                        const elapsed = (this.streamStats.lastUpdate - this.streamStats.startTime) / 1000;
                        const kbps = elapsed > 0 ? Math.round((this.streamStats.totalBytes * 8) / elapsed / 1000) : 0;
                        const mbReceived = (this.streamStats.totalBytes / (1024 * 1024)).toFixed(2);
                        
                        // Determine stream type based on packet characteristics
                        let statusText = 'Receiving Stream Data';
                        let sizeText = 'Data: ' + mbReceived + ' MB';
                        let streamColor = '#00ff00';
                        
                        if (this.streamStats.largePackets > 0) {
                            statusText = 'üé¨ Video Stream Active';
                            sizeText = 'Video Frames: ' + this.streamStats.largePackets + '/' + this.streamStats.packets;
                            streamColor = '#00ff88';
                        } else if (data.byteLength < 50) {
                            statusText = 'üì° Control Stream';
                            sizeText = 'Small packets (control/keepalive)';
                            streamColor = '#ffaa00';
                        } else if (data.byteLength > 100) {
                            statusText = 'üìπ Data Stream';
                            sizeText = 'Medium packets (video headers)';
                            streamColor = '#00aaff';
                        }
                        
                        streamViz.innerHTML = '<div class="stream-data">' +
                            '<div class="stream-indicator" style="background: ' + streamColor + ';"></div>' +
                            '<div style="font-size: 24px; margin-bottom: 10px;">üì° LIVE STREAM</div>' +
                            '<div style="font-size: 16px; color: ' + streamColor + ';">' + statusText + '</div>' +
                            '<div style="margin-top: 15px;">' +
                                '<div>Total Packets: ' + this.streamStats.packets + '</div>' +
                                '<div>' + sizeText + '</div>' +
                                '<div>Rate: ' + kbps + ' kbps</div>' +
                                '<div>Latest: ' + data.byteLength + ' bytes</div>' +
                                '<div>Max Packet: ' + this.streamStats.maxPacketSize + ' bytes</div>' +
                            '</div>' +
                            '<div style="margin-top: 15px; font-size: 12px; opacity: 0.7;">' +
                                (this.streamStats.largePackets > 0 ? 
                                    'Video frames detected! Stream is working.' : 
                                    'Waiting for video frames (currently receiving control data).'
                                ) +
                            '</div>' +
                        '</div>';
                    }
                    
                } catch (error) {
                    this.log('Error processing stream data: ' + error, 'error');
                }
            }

            handleBinaryMessage(data) {
                // This method is no longer used - replaced by buffer processing
                this.log('handleBinaryMessage called - this should not happen', 'error');
            }

            processCompleteMessage(id, command, payload) {
                switch (command) {
                    case this.Protocol.S2C.KeepAlive:
                        // Don't log keepalives to reduce spam
                        break;
                        
                    case this.Protocol.S2C.InformInvalidIdentify:
                        this.handleInvalidIdentify(payload);
                        break;
                        
                    case this.Protocol.S2C.Response_Login:
                        this.handleLoginResponse(payload);
                        break;
                        
                    case this.Protocol.S2C.CreateChannel_OK:
                        this.handleChannelCreated(payload);
                        break;
                        
                    case this.Protocol.S2C.JoinChannel_OK:
                        this.handleChannelJoined(payload);
                        break;
                        
                    case this.Protocol.S2C.JoinChannel_Error:
                        this.handleChannelJoinError(payload);
                        break;
                        
                    case this.Protocol.S2C.Request_UDPIdentifySecret:
                        this.handleUDPIdentifyRequest(payload);
                        break;
                        
                    case this.Protocol.S2C.UseThisUDPIdentifySecret:
                        this.handleUDPIdentifySecret(payload);
                        break;
                        
                    case this.Protocol.S2C.ChannelList:
                        this.handleChannelList(payload);
                        break;
                        
                    case this.Protocol.S2C.Channel_ScreenShare_ViewToShare:
                        this.handleStreamControl(payload);
                        break;
                        
                    default:
                        this.log('Unknown command: ' + command + ' (payload: ' + payload.byteLength + ' bytes)', 'error');
                }
            }

            handleInvalidIdentify(data) {
                if (data.byteLength >= 16) {
                    const view = new DataView(data);
                    const clientIdentify = view.getBigUint64(0, true);
                    const serverIdentify = view.getBigUint64(8, true);
                    this.log('Invalid identify - Client: ' + clientIdentify + ', Server: ' + serverIdentify, 'info');
                }
            }

            handleUDPIdentifyRequest(data) {
                this.log('Server requesting UDP identify secret', 'info');
            }

            handleUDPIdentifySecret(data) {
                if (data.byteLength >= 8) {
                    const view = new DataView(data);
                    const udpSecret = view.getBigUint64(0, true);
                    this.log('Received UDP identify secret: ' + udpSecret, 'info');
                }
            }

            handleLoginResponse(data) {
                if (data.byteLength < 8) {
                    this.log('Login response too small: ' + data.byteLength + ' bytes', 'error');
                    return;
                }
                
                const view = new DataView(data);
                const accountId = view.getUint32(0, true);
                this.sessionId = view.getUint32(4, true);
                
                this.log('Login successful! Account ID: ' + accountId + ', Session ID: ' + this.sessionId, 'success');
                this.updateUI();
                
                // Auto-request channel list after login
                setTimeout(() => this.requestChannelList(), 100);
            }

            handleChannelCreated(data) {
                if (data.byteLength < 7) {
                    this.log('Channel creation response too small: ' + data.byteLength + ' bytes', 'error');
                    return;
                }
                
                const view = new DataView(data);
                const type = view.getUint8(0);
                const channelId = view.getUint16(1, true);
                const channelSessionId = view.getUint32(3, true);
                
                this.log('Channel created: ID=' + channelId + ', Type=' + type + ', SessionID=' + channelSessionId, 'success');
                
                // Auto-join the created channel
                setTimeout(() => this.joinChannel(channelId), 100);
            }

            handleChannelJoined(data) {
                if (data.byteLength < 7) {
                    this.log('Channel join response too small: ' + data.byteLength + ' bytes', 'error');
                    return;
                }
                
                const view = new DataView(data);
                const type = view.getUint8(0);
                const channelId = view.getUint16(1, true);
                const channelSessionId = view.getUint32(3, true);
                
                this.log('Successfully joined channel ' + channelId + ' (Type: ' + type + ', SessionID: ' + channelSessionId + ')', 'success');
                
                // Show streaming interface
                this.showStreamingInterface();
                
                // Request updated channel list
                setTimeout(() => this.requestChannelList(), 100);
                
                this.log('Ready to receive stream data...', 'info');
            }

            handleChannelJoinError(data) {
                if (data.byteLength < 1) {
                    this.log('Channel join failed: unknown error', 'error');
                    return;
                }
                
                const view = new DataView(data);
                const reason = view.getUint8(0);
                
                const reasonText = reason === 0 ? 'Invalid Channel Type' : 
                                 reason === 1 ? 'Invalid Channel ID' : 
                                 'Unknown error';
                
                this.log('Channel join failed: ' + reasonText + ' (' + reason + ')', 'error');
            }

            handleChannelList(data) {
                if (data.byteLength < 2) {
                    this.log('Channel list payload too small: ' + data.byteLength + ' bytes', 'error');
                    return;
                }
                
                const view = new DataView(data);
                const channelCount = view.getUint16(0, true);
                
                this.log('Channel list: ' + channelCount + ' channels, payload size: ' + data.byteLength + ' bytes', 'info');
                
                if (channelCount === 0) {
                    this.channels = [];
                    this.updateChannelsList();
                    this.updateUI();
                    return;
                }
                
                // Each channel info is 76 bytes according to the C++ struct
                const expectedSize = 2 + (channelCount * 76);
                if (data.byteLength < expectedSize) {
                    this.log('Incomplete channel data: got ' + data.byteLength + ', expected ' + expectedSize + ' bytes', 'error');
                    return;
                }
                
                this.channels = [];
                let offset = 2;
                
                for (let i = 0; i < channelCount; i++) {
                    if (offset + 76 > data.byteLength) {
                        this.log('Not enough data for channel ' + i, 'error');
                        break;
                    }
                    
                    const channelId = view.getUint16(offset, true);
                    const type = view.getUint8(offset + 2);
                    const userCount = view.getUint32(offset + 3, true);
                    
                    // Read channel name (64 bytes)
                    const nameBytes = new Uint8Array(data, offset + 7, 64);
                    let nameLength = 0;
                    for (let j = 0; j < 64; j++) {
                        if (nameBytes[j] === 0) break;
                        nameLength++;
                    }
                    const name = new TextDecoder().decode(nameBytes.slice(0, nameLength));
                    
                    const isPasswordProtected = view.getUint8(offset + 71) !== 0;
                    const hostSessionId = view.getUint32(offset + 72, true);
                    
                    const channel = {
                        id: channelId,
                        type: type,
                        userCount: userCount,
                        name: name || ('Channel ' + channelId),
                        isPasswordProtected: isPasswordProtected,
                        hostSessionId: hostSessionId
                    };
                    
                    this.channels.push(channel);
                    this.log('Parsed channel ' + i + ': ' + JSON.stringify(channel), 'info');
                    
                    offset += 76;
                }
                
                this.log('Successfully parsed ' + this.channels.length + ' channels', 'success');
                this.updateChannelsList();
                this.updateUI();
            }

            handleStreamControl(data) {
                if (data.byteLength < 4) {
                    this.log('Stream control message too small', 'error');
                    return;
                }
                
                const view = new DataView(data);
                const channelId = view.getUint16(0, true);
                const flag = view.getUint16(2, true);
                
                this.log('Stream control: Channel=' + channelId + ', Flag=' + flag, 'info');
                
                if (flag & 0x02) { // ResetIDR flag
                    this.log('IDR frame requested by server', 'info');
                }
            }
            
            showStreamingInterface() {
                const videoOverlay = document.getElementById('videoOverlay');
                if (videoOverlay) {
                    videoOverlay.innerHTML = '<div class="placeholder-icon">üé¨</div>' +
                        '<h3>Connected to Channel ' + this.selectedChannelId + '</h3>' +
                        '<div style="margin-top: 15px;">' +
                            '<div style="color: #00ff00; font-size: 16px;">‚óè Ready to receive stream</div>' +
                            '<div style="color: #ffaa00; font-size: 14px; margin-top: 8px;">Start streaming from C++ client</div>' +
                        '</div>' +
                        '<p style="margin-top: 20px; font-size: 12px; opacity: 0.8;">' +
                            'Stream will automatically appear when video data arrives' +
                        '</p>';
                }
            }

            updateChannelsList() {
                const channelsList = document.getElementById('channelsList');
                
                if (this.channels.length === 0) {
                    channelsList.innerHTML = '<div class="channel-item">' +
                            '<div class="channel-name">No channels available</div>' +
                            '<div class="channel-users">Click "Create" to make a new channel</div>' +
                        '</div>';
                    return;
                }
                
                channelsList.innerHTML = '';
                
                for (let i = 0; i < this.channels.length; i++) {
                    const channel = this.channels[i];
                    const channelDiv = document.createElement('div');
                    channelDiv.className = 'channel-item';
                    if (channel.id === this.selectedChannelId) {
                        channelDiv.classList.add('selected');
                    }
                    
                    channelDiv.innerHTML = '<div class="channel-name">' + channel.name + (channel.isPasswordProtected ? ' üîí' : '') + '</div>' +
                        '<div class="channel-users">' + channel.userCount + ' users - ID: ' + channel.id + '</div>';
                    
                    channelDiv.addEventListener('click', () => {
                        this.log('Clicked channel: ' + channel.name + ' (' + channel.id + ')', 'info');
                        this.joinChannel(channel.id);
                    });
                    
                    channelsList.appendChild(channelDiv);
                }
                
                this.log('Updated channels list with ' + this.channels.length + ' channels', 'info');
            }

            log(message, type) {
                if (!type) {
                    type = 'info';
                }
                
                const logs = document.getElementById('logs');
                const entry = document.createElement('div');
                entry.className = 'log-entry ' + type;
                entry.textContent = new Date().toLocaleTimeString() + ': ' + message;
                
                logs.appendChild(entry);
                logs.scrollTop = logs.scrollHeight;
                
                // Keep only last 50 entries
                while (logs.children.length > 50) {
                    logs.removeChild(logs.firstChild);
                }
                
                console.log('[' + type.toUpperCase() + '] ' + message);
            }
        }

        // Initialize the fixed application
        const client = new FixedScreenShareClient();
        
        // Handle page unload
        window.addEventListener('beforeunload', () => {
            client.disconnect();
        });

        // Debug keyboard shortcut (Shift+D for debug info)
        document.addEventListener('keydown', (e) => {
            if (e.shiftKey && e.key === 'D') {
                client.log('=== DEBUG INFO ===', 'info');
                client.log('Connected: ' + client.isConnected, 'info');
                client.log('Session ID: ' + client.sessionId, 'info');
                client.log('Selected Channel: ' + client.selectedChannelId, 'info');
                client.log('Channels: ' + JSON.stringify(client.channels), 'info');
                client.log('Command ID: ' + client.commandId, 'info');
                client.log('WebSocket State: ' + (client.ws ? client.ws.readyState : 'null'), 'info');
                client.log('================', 'info');
            }
        });
    </script>
</body>
</html>