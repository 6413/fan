<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen Share Application</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="app-container">
        <!-- Main Header -->
        <header class="main-header">
            <div class="connection-status">
                <span class="status-indicator" id="connectionStatus"></span>
                <span class="status-text">User: <span id="username">Not Connected</span></span>
            </div>
            <div class="network-info">
                <div class="protocol-status">
                    <span class="protocol-label">WS:</span>
                    <span class="protocol-indicator" id="tcpStatus" title="Channel Control (WebSocket)"></span>
                </div>
                <div class="protocol-status">
                    <span class="protocol-label">RTC:</span>
                    <span class="protocol-indicator" id="udpStatus" title="Stream Data (WebRTC)"></span>
                </div>
                <div class="stats-info">
                    <span id="streamStats"></span>
                </div>
            </div>
        </header>

        <!-- Tab Navigation -->
        <nav class="tab-navigation">
            <button class="tab-button active" data-tab="channels">Channels</button>
            <button class="tab-button" data-tab="stream">Stream View</button>
        </nav>

        <!-- Tab Content -->
        <div class="tab-content">
            <!-- Channels Tab -->
            <div class="tab-pane active" id="channels-tab">
                <div class="split-view">
                    <!-- Channel List Panel -->
                    <div class="channel-list-panel">
                        <div class="panel-header">
                            <button class="btn btn-primary" onclick="app.refreshChannelList()">Refresh Channel List</button>
                            <div class="search-container">
                                <input type="text" class="search-input" placeholder="Search channels..." id="channelSearch" oninput="app.filterChannels()">
                            </div>
                        </div>
                        
                        <div class="channel-list" id="channelList">
                            <div class="empty-state">
                                <p>Click 'Refresh Channel List' to load channels</p>
                            </div>
                        </div>
                        
                        <div class="panel-footer">
                            <button class="btn btn-success" onclick="app.showCreateChannel()">Add New</button>
                            <button class="btn btn-secondary" onclick="app.showConnectDialog()">Connect</button>
                        </div>
                    </div>

                    <!-- Splitter -->
                    <div class="splitter" id="channelSplitter"></div>

                    <!-- Channel Details Panel -->
                    <div class="channel-details-panel">
                        <div class="panel-content">
                            <div id="channelDetails" class="channel-details">
                                <div class="empty-state">
                                    <p>Select a channel to view details</p>
                                    <p>Click on any channel in the left panel to see users and access stream settings.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Stream View Tab -->
            <div class="tab-pane" id="stream-tab">
                <div class="stream-controls">
                    <button class="btn btn-stream-toggle" id="streamToggle" onclick="app.toggleStream()">Start Stream</button>
                    <label class="checkbox-container">
                        <input type="checkbox" id="showOwnStream" onchange="app.toggleOwnStream()">
                        <span>Show Own Stream</span>
                    </label>
                    <button class="btn btn-secondary" id="settingsToggle" onclick="app.toggleStreamSettings()">Show Settings</button>
                    <button class="btn btn-secondary" onclick="app.toggleFullscreen()">Fullscreen</button>
                    <button class="btn btn-idr" onclick="app.requestIDR()">Request IDR</button>
                </div>

                <div class="stream-view-container">
                    <div class="stream-display" id="streamDisplay">
                        <div class="stream-placeholder" id="streamPlaceholder">
                            <p>No stream active</p>
                            <p>Start streaming or join a channel to view streams</p>
                        </div>
                        <video id="localStream" class="stream-video" style="display: none;" muted autoplay playsinline></video>
                        <video id="remoteStream" class="stream-video" style="display: none;" autoplay playsinline></video>
                        <div class="stream-info" id="streamInfo"></div>
                    </div>

                    <!-- Stream Settings Panel -->
                    <div class="stream-settings-panel" id="streamSettingsPanel" style="display: none;">
                        <div class="settings-content">
                            <h3>Stream Settings</h3>
                            
                            <div class="settings-section">
                                <h4>Video Settings</h4>
                                <div class="form-group">
                                    <label>Resolution:</label>
                                    <select id="resolution" onchange="app.updateStreamSettings()">
                                        <option value="1920x1080">1920x1080</option>
                                        <option value="1280x720" selected>1280x720</option>
                                        <option value="1024x768">1024x768</option>
                                        <option value="800x600">800x600</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label>Framerate: <span id="framerateValue">30</span> fps</label>
                                    <input type="range" id="framerate" min="15" max="120" value="30" step="5" oninput="app.updateFramerate()">
                                </div>
                                <div class="form-group">
                                    <label>Bitrate: <span id="bitrateValue">5.0</span> Mbps</label>
                                    <input type="range" id="bitrate" min="0.5" max="50" value="5" step="0.5" oninput="app.updateBitrate()">
                                </div>
                            </div>

                            <div class="settings-section">
                                <h4>Codec Settings</h4>
                                <div class="form-group">
                                    <label>Preferred Codec:</label>
                                    <select id="codec" onchange="app.updateCodec()">
                                        <option value="H264">H.264</option>
                                        <option value="VP8">VP8</option>
                                        <option value="VP9">VP9</option>
                                    </select>
                                </div>
                            </div>

                            <div class="settings-section">
                                <h4>Input Control</h4>
                                <div class="form-group">
                                    <select id="inputControl" onchange="app.updateInputControl()">
                                        <option value="none">None</option>
                                        <option value="keyboard">Keyboard Only</option>
                                        <option value="full">Keyboard + Mouse</option>
                                    </select>
                                </div>
                            </div>

                            <button class="btn btn-secondary" onclick="app.resetSettings()">Reset Settings</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modals -->
        <!-- Connect Dialog -->
        <div class="modal" id="connectModal">
            <div class="modal-content">
                <h2>Server Connection</h2>
                <div class="form-group">
                    <label>Server Address:</label>
                    <input type="text" id="serverAddress" placeholder="ws://localhost:8080" value="ws://localhost:8080">
                </div>
                <div class="form-group">
                    <label>Username (optional):</label>
                    <input type="text" id="connectUsername" placeholder="Anonymous">
                </div>
                <div class="modal-buttons">
                    <button class="btn btn-primary" onclick="app.connect()">Connect</button>
                    <button class="btn btn-secondary" onclick="app.closeModal('connectModal')">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Create Channel Dialog -->
        <div class="modal" id="createChannelModal">
            <div class="modal-content">
                <h2>Create Channel</h2>
                <div class="form-group">
                    <label>Channel Name:</label>
                    <input type="text" id="channelName" placeholder="My Channel">
                </div>
                <div class="form-group">
                    <label>Password (optional):</label>
                    <input type="password" id="channelPassword" placeholder="Leave empty for public">
                </div>
                <div class="modal-buttons">
                    <button class="btn btn-primary" onclick="app.createChannel()">Create</button>
                    <button class="btn btn-secondary" onclick="app.closeModal('createChannelModal')">Cancel</button>
                </div>
            </div>
        </div>

        <!-- Join Channel Dialog -->
        <div class="modal" id="joinChannelModal">
            <div class="modal-content">
                <h2>Join Channel</h2>
                <p id="joinChannelName"></p>
                <div class="form-group" id="channelPasswordGroup" style="display: none;">
                    <label>Password:</label>
                    <input type="password" id="joinChannelPassword">
                </div>
                <div class="modal-buttons">
                    <button class="btn btn-primary" onclick="app.joinChannel()">Join</button>
                    <button class="btn btn-secondary" onclick="app.closeModal('joinChannelModal')">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Main application logic
        class ScreenShareApp {
            constructor() {
                this.ws = null;
                this.rtcConnection = null;
                this.localStream = null;
                this.remoteStream = null;
                this.dataChannel = null;
                this.isStreaming = false;
                this.currentChannel = null;
                this.channels = [];
                this.sessionId = null;
                this.username = 'Anonymous';
                this.selectedChannelId = null;
                this.statsInterval = null;
                this.keepAliveInterval = null;
                this.streamSettings = {
                    resolution: '1280x720',
                    framerate: 30,
                    bitrate: 5000000,
                    codec: 'H264',
                    inputControl: 'none'
                };
                
                this.initializeEventListeners();
                this.initializeSplitter();
            }

            initializeEventListeners() {
                // Tab switching
                document.querySelectorAll('.tab-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        this.switchTab(e.target.dataset.tab);
                    });
                });

                // Modal close on background click
                document.querySelectorAll('.modal').forEach(modal => {
                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.style.display = 'none';
                        }
                    });
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isFullscreen) {
                        this.exitFullscreen();
                    }
                });
            }

            initializeSplitter() {
                const splitter = document.getElementById('channelSplitter');
                const leftPanel = document.querySelector('.channel-list-panel');
                const rightPanel = document.querySelector('.channel-details-panel');
                let isResizing = false;

                splitter.addEventListener('mousedown', (e) => {
                    isResizing = true;
                    document.body.style.cursor = 'ew-resize';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isResizing) return;
                    
                    const containerWidth = splitter.parentElement.offsetWidth;
                    const newLeftWidth = e.clientX - splitter.parentElement.offsetLeft;
                    const percentage = (newLeftWidth / containerWidth) * 100;
                    
                    if (percentage > 20 && percentage < 80) {
                        leftPanel.style.width = percentage + '%';
                        rightPanel.style.width = (100 - percentage - 1) + '%';
                    }
                });

                document.addEventListener('mouseup', () => {
                    isResizing = false;
                    document.body.style.cursor = 'default';
                });
            }

            // WebSocket connection
            async connect() {
                const address = document.getElementById('serverAddress').value;
                const username = document.getElementById('connectUsername').value || 'Anonymous_' + Math.floor(Math.random() * 10000);
                
                this.username = username;
                document.getElementById('username').textContent = username;
                
                try {
                    this.ws = new WebSocket(address);
                    
                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        this.updateConnectionStatus('connected');
                        this.closeModal('connectModal');
                        this.startKeepAlive();
                        
                        // Send login
                        this.sendMessage({
                            type: 'login',
                            username: this.username
                        });
                    };
                    
                    this.ws.onmessage = (event) => {
                        this.handleMessage(JSON.parse(event.data));
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.updateConnectionStatus('disconnected');
                        this.stopKeepAlive();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        alert('Connection failed. Make sure the server is running.');
                    };
                } catch (error) {
                    console.error('Connection error:', error);
                    alert('Failed to connect: ' + error.message);
                }
            }

            sendMessage(message) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify(message));
                }
            }

            handleMessage(message) {
                switch (message.type) {
                    case 'login_response':
                        this.sessionId = message.sessionId;
                        this.refreshChannelList();
                        break;
                        
                    case 'channel_list':
                        this.updateChannelList(message.channels);
                        break;
                        
                    case 'channel_created':
                        this.selectedChannelId = message.channelId;
                        this.joinChannelById(message.channelId);
                        this.refreshChannelList();
                        break;
                        
                    case 'joined_channel':
                        this.currentChannel = message.channelId;
                        this.updateChannelDetails(message);
                        break;
                        
                    case 'channel_users':
                        this.updateUserList(message.users);
                        break;
                        
                    case 'offer':
                        this.handleOffer(message);
                        break;
                        
                    case 'answer':
                        this.handleAnswer(message);
                        break;
                        
                    case 'ice_candidate':
                        this.handleIceCandidate(message);
                        break;
                        
                    case 'stream_started':
                        this.onRemoteStreamStarted(message);
                        break;
                        
                    case 'stream_stopped':
                        this.onRemoteStreamStopped(message);
                        break;
                        
                    case 'request_idr':
                        if (this.isStreaming) {
                            this.forceKeyFrame();
                        }
                        break;
                }
            }

            // Channel operations
            refreshChannelList() {
                this.sendMessage({ type: 'get_channels' });
            }

            updateChannelList(channels) {
                this.channels = channels;
                const channelList = document.getElementById('channelList');
                
                if (channels.length === 0) {
                    channelList.innerHTML = `
                        <div class="empty-state">
                            <p>No channels available</p>
                            <p>Create a new channel to get started!</p>
                        </div>
                    `;
                    return;
                }
                
                channelList.innerHTML = channels.map(channel => `
                    <div class="channel-item ${this.selectedChannelId === channel.id ? 'selected' : ''}" 
                         onclick="app.selectChannel('${channel.id}')">
                        <div class="channel-name">
                            ${channel.name} 
                            ${channel.isPasswordProtected ? 'ðŸ”’' : ''}
                            ${this.currentChannel === channel.id ? 'âœ“' : ''}
                        </div>
                        <div class="channel-info">
                            ${channel.userCount} user${channel.userCount !== 1 ? 's' : ''}
                        </div>
                    </div>
                `).join('');
            }

            selectChannel(channelId) {
                this.selectedChannelId = channelId;
                const channel = this.channels.find(ch => ch.id === channelId);
                
                // Update UI
                document.querySelectorAll('.channel-item').forEach(item => {
                    item.classList.remove('selected');
                });
                event.target.closest('.channel-item').classList.add('selected');
                
                // Show channel details
                this.showChannelDetails(channel);
                
                // Request user list
                this.sendMessage({
                    type: 'get_channel_users',
                    channelId: channelId
                });
            }

            showChannelDetails(channel) {
                const detailsDiv = document.getElementById('channelDetails');
                const isHost = channel.hostId === this.sessionId;
                const isJoined = this.currentChannel === channel.id;
                
                detailsDiv.innerHTML = `
                    <div class="channel-header">
                        <h3>Channel: ${channel.name}</h3>
                        ${isHost ? '<span class="host-badge">You are the host</span>' : ''}
                    </div>
                    
                    <div class="tab-bar">
                        <button class="detail-tab active" onclick="app.showDetailTab('users')">Users</button>
                        <button class="detail-tab" onclick="app.showDetailTab('settings')">Stream Settings</button>
                    </div>
                    
                    <div class="detail-content">
                        <div id="users-tab" class="detail-pane active">
                            <button class="btn btn-primary" onclick="app.sendMessage({type: 'get_channel_users', channelId: '${channel.id}'})">
                                Refresh Users
                            </button>
                            <div id="userList" class="user-list">
                                <p>Loading users...</p>
                            </div>
                            <div class="channel-actions">
                                ${!isJoined ? 
                                    `<button class="btn btn-success" onclick="app.showJoinDialog('${channel.id}', '${channel.name}', ${channel.isPasswordProtected})">Join</button>` :
                                    !isHost ? 
                                        `<button class="btn btn-danger" onclick="app.leaveChannel()">Leave</button>` : 
                                        ''
                                }
                                ${this.isStreaming ? 
                                    `<button class="btn btn-danger" onclick="app.toggleStream()">Stop Stream</button>` :
                                    `<button class="btn btn-success" onclick="app.toggleStream()">Start Stream</button>`
                                }
                                <button class="btn btn-secondary" onclick="app.switchTab('stream')">View Stream</button>
                            </div>
                        </div>
                        
                        <div id="settings-tab" class="detail-pane">
                            ${this.renderCompactSettings()}
                        </div>
                    </div>
                `;
            }

            renderCompactSettings() {
                return `
                    <div class="compact-settings">
                        <h4>Video Settings</h4>
                        <div class="form-group">
                            <label>Resolution:</label>
                            <select onchange="app.updateStreamSettings(event, 'resolution')">
                                <option value="1920x1080">1920x1080</option>
                                <option value="1280x720" selected>1280x720</option>
                                <option value="1024x768">1024x768</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Framerate: <span>${this.streamSettings.framerate}</span> fps</label>
                            <input type="range" min="15" max="120" value="${this.streamSettings.framerate}" 
                                   oninput="app.updateStreamSettings(event, 'framerate')">
                        </div>
                        <div class="form-group">
                            <label>Bitrate: <span>${this.streamSettings.bitrate / 1000000}</span> Mbps</label>
                            <input type="range" min="0.5" max="50" value="${this.streamSettings.bitrate / 1000000}" step="0.5"
                                   oninput="app.updateStreamSettings(event, 'bitrate')">
                        </div>
                    </div>
                `;
            }

            showDetailTab(tab) {
                document.querySelectorAll('.detail-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.detail-pane').forEach(p => p.classList.remove('active'));
                
                event.target.classList.add('active');
                document.getElementById(`${tab}-tab`).classList.add('active');
            }

            updateUserList(users) {
                const userList = document.getElementById('userList');
                if (!userList) return;
                
                userList.innerHTML = users.map(user => `
                    <div class="user-item">
                        <span class="user-name">${user.username}</span>
                        ${user.isHost ? '<span class="host-indicator">(Host)</span>' : ''}
                        ${user.isStreaming ? '<span class="streaming-indicator">ðŸ“¹</span>' : ''}
                    </div>
                `).join('');
            }

            // Streaming functionality
            async toggleStream() {
                if (this.isStreaming) {
                    this.stopStream();
                } else {
                    this.startStream();
                }
            }

            async startStream() {
                if (!this.currentChannel) {
                    alert('Please join a channel first');
                    return;
                }
                
                try {
                    // Get display media
                    this.localStream = await navigator.mediaDevices.getDisplayMedia({
                        video: {
                            width: { ideal: parseInt(this.streamSettings.resolution.split('x')[0]) },
                            height: { ideal: parseInt(this.streamSettings.resolution.split('x')[1]) },
                            frameRate: { ideal: this.streamSettings.framerate }
                        },
                        audio: false
                    });
                    
                    // Show local stream if enabled
                    const localVideo = document.getElementById('localStream');
                    localVideo.srcObject = this.localStream;
                    
                    if (document.getElementById('showOwnStream').checked) {
                        localVideo.style.display = 'block';
                    }
                    
                    // Update UI
                    this.isStreaming = true;
                    document.getElementById('streamToggle').textContent = 'Stop Stream';
                    document.getElementById('streamToggle').classList.add('streaming');
                    document.getElementById('streamPlaceholder').style.display = 'none';
                    
                    // Notify server
                    this.sendMessage({
                        type: 'start_stream',
                        channelId: this.currentChannel
                    });
                    
                    // Set up WebRTC
                    this.setupWebRTC();
                    
                    // Start stats monitoring
                    this.startStatsMonitoring();
                    
                    // Handle stream end
                    this.localStream.getTracks()[0].onended = () => {
                        this.stopStream();
                    };
                    
                } catch (error) {
                    console.error('Error starting stream:', error);
                    alert('Failed to start screen capture');
                }
            }

            stopStream() {
                if (this.localStream) {
                    this.localStream.getTracks().forEach(track => track.stop());
                    this.localStream = null;
                }
                
                if (this.rtcConnection) {
                    this.rtcConnection.close();
                    this.rtcConnection = null;
                }
                
                // Update UI
                this.isStreaming = false;
                document.getElementById('streamToggle').textContent = 'Start Stream';
                document.getElementById('streamToggle').classList.remove('streaming');
                document.getElementById('localStream').style.display = 'none';
                
                if (!document.getElementById('remoteStream').srcObject) {
                    document.getElementById('streamPlaceholder').style.display = 'flex';
                }
                
                // Stop stats
                this.stopStatsMonitoring();
                
                // Notify server
                this.sendMessage({
                    type: 'stop_stream',
                    channelId: this.currentChannel
                });
            }

            // WebRTC setup
            async setupWebRTC() {
                const configuration = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' }
                    ]
                };
                
                this.rtcConnection = new RTCPeerConnection(configuration);
                
                // Add local stream
                this.localStream.getTracks().forEach(track => {
                    const sender = this.rtcConnection.addTrack(track, this.localStream);
                    
                    // Configure encoding parameters
                    const params = sender.getParameters();
                    if (params.encodings && params.encodings[0]) {
                        params.encodings[0].maxBitrate = this.streamSettings.bitrate;
                        params.encodings[0].maxFramerate = this.streamSettings.framerate;
                        sender.setParameters(params);
                    }
                });
                
                // Set up data channel for low-latency control
                this.dataChannel = this.rtcConnection.createDataChannel('control', {
                    ordered: false,
                    maxRetransmits: 0
                });
                
                this.dataChannel.onopen = () => {
                    console.log('Data channel opened');
                    this.updateConnectionStatus('streaming');
                };
                
                this.dataChannel.onmessage = (event) => {
                    this.handleDataChannelMessage(event.data);
                };
                
                // Handle ICE candidates
                this.rtcConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        this.sendMessage({
                            type: 'ice_candidate',
                            candidate: event.candidate,
                            channelId: this.currentChannel
                        });
                    }
                };
                
                // Create and send offer
                const offer = await this.rtcConnection.createOffer();
                await this.rtcConnection.setLocalDescription(offer);
                
                this.sendMessage({
                    type: 'offer',
                    offer: offer,
                    channelId: this.currentChannel
                });
            }

            // Handle WebRTC signaling
            async handleOffer(message) {
                if (!this.rtcConnection) {
                    const configuration = {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' }
                        ]
                    };
                    
                    this.rtcConnection = new RTCPeerConnection(configuration);
                    
                    this.rtcConnection.ontrack = (event) => {
                        const remoteVideo = document.getElementById('remoteStream');
                        remoteVideo.srcObject = event.streams[0];
                        remoteVideo.style.display = 'block';
                        document.getElementById('streamPlaceholder').style.display = 'none';
                    };
                    
                    this.rtcConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            this.sendMessage({
                                type: 'ice_candidate',
                                candidate: event.candidate,
                                channelId: this.currentChannel
                            });
                        }
                    };
                    
                    this.rtcConnection.ondatachannel = (event) => {
                        const channel = event.channel;
                        channel.onmessage = (event) => {
                            this.handleDataChannelMessage(event.data);
                        };
                    };
                }
                
                await this.rtcConnection.setRemoteDescription(message.offer);
                const answer = await this.rtcConnection.createAnswer();
                await this.rtcConnection.setLocalDescription(answer);
                
                this.sendMessage({
                    type: 'answer',
                    answer: answer,
                    channelId: this.currentChannel,
                    to: message.from
                });
            }

            async handleAnswer(message) {
                if (this.rtcConnection) {
                    await this.rtcConnection.setRemoteDescription(message.answer);
                }
            }

            async handleIceCandidate(message) {
                if (this.rtcConnection) {
                    await this.rtcConnection.addIceCandidate(message.candidate);
                }
            }

            handleDataChannelMessage(data) {
                const message = JSON.parse(data);
                switch (message.type) {
                    case 'input':
                        if (this.streamSettings.inputControl !== 'none') {
                            this.handleRemoteInput(message);
                        }
                        break;
                    case 'stats':
                        this.updateRemoteStats(message.stats);
                        break;
                }
            }

            // Stats monitoring
            startStatsMonitoring() {
                this.statsInterval = setInterval(async () => {
                    if (!this.rtcConnection) return;
                    
                    const stats = await this.rtcConnection.getStats();
                    let videoStats = null;
                    
                    stats.forEach(report => {
                        if (report.type === 'outbound-rtp' && report.kind === 'video') {
                            videoStats = {
                                bitrate: report.bytesSent,
                                framerate: report.framesPerSecond,
                                width: report.frameWidth,
                                height: report.frameHeight,
                                packets: report.packetsSent,
                                packetsLost: report.packetsLost || 0
                            };
                        }
                    });
                    
                    if (videoStats) {
                        this.updateStreamStats(videoStats);
                    }
                }, 1000);
            }

            stopStatsMonitoring() {
                if (this.statsInterval) {
                    clearInterval(this.statsInterval);
                    this.statsInterval = null;
                }
                document.getElementById('streamStats').textContent = '';
            }

            updateStreamStats(stats) {
                const statsText = `${stats.width}x${stats.height} @ ${stats.framerate}fps | ${(stats.bitrate / 1000000).toFixed(2)} Mbps`;
                document.getElementById('streamStats').textContent = statsText;
                
                if (this.dataChannel && this.dataChannel.readyState === 'open') {
                    this.dataChannel.send(JSON.stringify({
                        type: 'stats',
                        stats: stats
                    }));
                }
            }

            // UI Functions
            switchTab(tab) {
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelectorAll('.tab-pane').forEach(pane => {
                    pane.classList.remove('active');
                });
                
                document.querySelector(`[data-tab="${tab}"]`).classList.add('active');
                document.getElementById(`${tab}-tab`).classList.add('active');
            }

            showModal(modalId) {
                document.getElementById(modalId).style.display = 'flex';
            }

            closeModal(modalId) {
                document.getElementById(modalId).style.display = 'none';
            }

            showConnectDialog() {
                this.showModal('connectModal');
            }

            showCreateChannel() {
                this.showModal('createChannelModal');
            }

            showJoinDialog(channelId, channelName, isPasswordProtected) {
                document.getElementById('joinChannelName').textContent = `Join channel: ${channelName}`;
                document.getElementById('channelPasswordGroup').style.display = isPasswordProtected ? 'block' : 'none';
                this.pendingJoinChannelId = channelId;
                this.showModal('joinChannelModal');
            }

            async createChannel() {
                const name = document.getElementById('channelName').value || 'Unnamed Channel';
                const password = document.getElementById('channelPassword').value;
                
                this.sendMessage({
                    type: 'create_channel',
                    name: name,
                    password: password
                });
                
                this.closeModal('createChannelModal');
            }

            async joinChannel() {
                const password = document.getElementById('joinChannelPassword').value;
                
                this.sendMessage({
                    type: 'join_channel',
                    channelId: this.pendingJoinChannelId,
                    password: password
                });
                
                this.closeModal('joinChannelModal');
            }

            joinChannelById(channelId) {
                const channel = this.channels.find(ch => ch.id === channelId);
                if (channel) {
                    if (channel.isPasswordProtected) {
                        this.showJoinDialog(channelId, channel.name, true);
                    } else {
                        this.sendMessage({
                            type: 'join_channel',
                            channelId: channelId
                        });
                    }
                }
            }

            leaveChannel() {
                if (this.currentChannel) {
                    this.sendMessage({
                        type: 'leave_channel',
                        channelId: this.currentChannel
                    });
                    this.currentChannel = null;
                    if (this.isStreaming) {
                        this.stopStream();
                    }
                    this.refreshChannelList();
                }
            }

            // Stream settings
            updateFramerate() {
                const value = document.getElementById('framerate').value;
                this.streamSettings.framerate = parseInt(value);
                document.getElementById('framerateValue').textContent = value;
                
                if (this.isStreaming) {
                    this.updateEncoderSettings();
                }
            }

            updateBitrate() {
                const value = document.getElementById('bitrate').value;
                this.streamSettings.bitrate = parseFloat(value) * 1000000;
                document.getElementById('bitrateValue').textContent = value;
                
                if (this.isStreaming) {
                    this.updateEncoderSettings();
                }
            }

            updateStreamSettings(event, setting) {
                const value = event.target.value;
                switch (setting) {
                    case 'resolution':
                        this.streamSettings.resolution = value;
                        break;
                    case 'framerate':
                        this.streamSettings.framerate = parseInt(value);
                        event.target.nextElementSibling.textContent = value;
                        break;
                    case 'bitrate':
                        this.streamSettings.bitrate = parseFloat(value) * 1000000;
                        event.target.nextElementSibling.textContent = value;
                        break;
                }
                
                if (this.isStreaming) {
                    this.updateEncoderSettings();
                }
            }

            updateEncoderSettings() {
                if (this.rtcConnection) {
                    const senders = this.rtcConnection.getSenders();
                    senders.forEach(sender => {
                        if (sender.track && sender.track.kind === 'video') {
                            const params = sender.getParameters();
                            if (params.encodings && params.encodings[0]) {
                                params.encodings[0].maxBitrate = this.streamSettings.bitrate;
                                params.encodings[0].maxFramerate = this.streamSettings.framerate;
                                sender.setParameters(params);
                            }
                        }
                    });
                }
            }

            resetSettings() {
                this.streamSettings = {
                    resolution: '1280x720',
                    framerate: 30,
                    bitrate: 5000000,
                    codec: 'H264',
                    inputControl: 'none'
                };
                
                document.getElementById('resolution').value = '1280x720';
                document.getElementById('framerate').value = 30;
                document.getElementById('framerateValue').textContent = '30';
                document.getElementById('bitrate').value = 5;
                document.getElementById('bitrateValue').textContent = '5.0';
                document.getElementById('codec').value = 'H264';
                document.getElementById('inputControl').value = 'none';
            }

            toggleStreamSettings() {
                const panel = document.getElementById('streamSettingsPanel');
                const toggle = document.getElementById('settingsToggle');
                
                if (panel.style.display === 'none') {
                    panel.style.display = 'block';
                    toggle.textContent = 'Hide Settings';
                } else {
                    panel.style.display = 'none';
                    toggle.textContent = 'Show Settings';
                }
            }

            toggleOwnStream() {
                const show = document.getElementById('showOwnStream').checked;
                const localVideo = document.getElementById('localStream');
                
                if (show && this.isStreaming) {
                    localVideo.style.display = 'block';
                } else {
                    localVideo.style.display = 'none';
                }
            }

            toggleFullscreen() {
                const streamDisplay = document.getElementById('streamDisplay');
                if (!document.fullscreenElement) {
                    streamDisplay.requestFullscreen();
                    this.isFullscreen = true;
                } else {
                    document.exitFullscreen();
                    this.isFullscreen = false;
                }
            }

            exitFullscreen() {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                    this.isFullscreen = false;
                }
            }

            requestIDR() {
                this.sendMessage({
                    type: 'request_idr',
                    channelId: this.currentChannel
                });
            }

            forceKeyFrame() {
                // This would require access to the encoder, which browsers don't directly provide
                // Instead, we can restart the stream or use other techniques
                console.log('IDR frame requested');
            }

            // Connection management
            updateConnectionStatus(status) {
                const indicator = document.getElementById('connectionStatus');
                const tcpStatus = document.getElementById('tcpStatus');
                const udpStatus = document.getElementById('udpStatus');
                
                indicator.className = 'status-indicator';
                tcpStatus.className = 'protocol-indicator';
                udpStatus.className = 'protocol-indicator';
                
                switch (status) {
                    case 'connected':
                        indicator.classList.add('connected');
                        tcpStatus.classList.add('active');
                        break;
                    case 'streaming':
                        indicator.classList.add('connected', 'streaming');
                        tcpStatus.classList.add('active');
                        udpStatus.classList.add('active');
                        break;
                    case 'disconnected':
                        // Default styles
                        break;
                }
            }

            startKeepAlive() {
                this.keepAliveInterval = setInterval(() => {
                    this.sendMessage({ type: 'keep_alive' });
                }, 30000); // 30 seconds
            }

            stopKeepAlive() {
                if (this.keepAliveInterval) {
                    clearInterval(this.keepAliveInterval);
                    this.keepAliveInterval = null;
                }
            }

            filterChannels() {
                const filter = document.getElementById('channelSearch').value.toLowerCase();
                const filteredChannels = this.channels.filter(ch => 
                    ch.name.toLowerCase().includes(filter)
                );
                this.updateChannelList(filteredChannels);
            }

            // Remote events
            onRemoteStreamStarted(message) {
                console.log('Remote stream started from:', message.username);
                // Update UI to show who is streaming
                this.sendMessage({
                    type: 'get_channel_users',
                    channelId: this.currentChannel
                });
            }

            onRemoteStreamStopped(message) {
                console.log('Remote stream stopped from:', message.username);
                const remoteVideo = document.getElementById('remoteStream');
                if (remoteVideo.srcObject) {
                    remoteVideo.srcObject = null;
                    remoteVideo.style.display = 'none';
                }
                
                if (!this.isStreaming) {
                    document.getElementById('streamPlaceholder').style.display = 'flex';
                }
                
                // Update user list
                this.sendMessage({
                    type: 'get_channel_users',
                    channelId: this.currentChannel
                });
            }
        }

        // Initialize the application
        const app = new ScreenShareApp();
        
        // Auto-connect if configured
        window.addEventListener('load', () => {
            // You can add auto-connect logic here if needed
        });
    </script>
</body>
</html>